<!doctype html>
<html lang="zh_CN">

    

    

    
    
    
    <head>
        
        <title>17 探讨 Fiber 性能优化机制</title>
        
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="基础+源码+实战三管齐下的 React 全解读">
        <meta name="keywords" content="慕课网">
        <meta name="author" content="">
        <meta name = "format-detection" content="telephone=no">
        <meta http-equiv="Cache-Control" content="no-transform " />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <link rel="shortcut icon" href="https://m.imooc.com/static/wap/static/favicon.ico" />
        
        
        
        <script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/flexible.js"></script>
        
        <script type="text/javascript">
            var userInfo = "";
            
                var isApp = 0;
            
        </script>
         
<!-- 专栏首页列表模板 -->
<script type="text/template" id="index-list-tpl">
<ul class="list-con">
    {@each data.data as item}
        <li>
            <a href="/read/${item.id}" class="item clearfix">
                <div class="img l" style="background-image: url(${item.app_pic1})">
                    {@if item.is_new }
                        <div class="icon new">
                            上新
                        </div>
                    {@else if item.is_marking} 
                        <div class="icon">
                            经典
                        </div>
                    {@/if} 
                </div>
                <div class="text-con l">
                    <div class="title">
                        ${item.title}
                    </div>
                    <div class="desc">
                        ${item.chapter_num}节 · ${item.description}
                    </div>
                     <div class="user-info">
                        ${item.nickname}
                        {@if item.author_title }
                        <span class="dot">
                            ·
                        </span>
                        ${item.author_title}
                        {@/if}
                    </div>
                    <div class="info clearfix">
                    {@if !item.isBuy } 
                        <!-- 未购买才显示 -->
                        <div class="price-con l">
                        {@if item.open_discount == "1" }
                            <span class="now">￥${item.pay_price}</span>
                            <span class="ori">￥${item.price}</span>
                            <p class="sale">${item.discount_name}</p>
                        {@else}
                            <span class="now">￥${item.price}</span>
                        {@/if}
                        </div>
                    {@/if}
                        <div class="taste-con r">
                            <span>${item.numbers}人订阅</span>
                            {@if !item.isBuy }
                                <span class="gotaste">试读</span>
                            {@else}
                                <span class="gotaste">学习</span>
                            {@/if}
                        </div>
                    </div>
                </div>
            </a>
        </li>
    {@/each}
</ul>
</script>



<!-- 专栏目录 买后目录页、 -->
<script type="text/template" id="detail-catalog-tpl">
<ul class="catalog-list">
{@each data.list as item}
    <li class="zhang">
        {@if data.structure_mode == "1" }
            <!--章节模式-->
            <div class="zhang-title">
                ${item.title}（${item.count}节）
            </div>
            <div class="zhang-sub-title">
                ${item.short_introduce}
            </div>
        {@/if}  
        <ul class="zhang-detail">
            {@each item.list as it,i}
                <li class="jie">
                    {@if data.isLogin }
                        <!-- 购买了  -->
                        {@if data.isBuy }
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read">
                        {@else}
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read" >
                        {@/if}
                    {@else}
                        <!-- 未登录  -->
                        {@if data.isApp }
                            <a href="javascript:;" onclick="window.nativeSupport.login();">
                        {@else}
                            <a href="//m.imooc.com/account/login?backurl=/read/${data.column_id}">
                        {@/if}
                    {@/if}
                        <div class="jie-con {@if data.last_chapter == it.id }recent{@/if}">
                            
                            <div class="text-con">
                                <div class="jie-title">
                                    ${it.title}
                                </div>
                                <div class="jie-status">
                                    {@if it.is_open == "0" }
                                        <span class="update-time" >${it.open_time_fmt}</span>
                                    {@/if}
                                    {@if it.view_num > 100 }
                                    <div class="learn-num">
                                        <i class="imwap-set-sns"></i>
                                        <span>${it.view_num}</span>
                                    </div>
                                    {@/if}
                                    {@if it.in_24hours == "1" }
                                        <span class="update-recent">最近更新</span>
                                    {@/if}
                                </div>
                            </div>
                        </div>
                        {@if it.is_learned }
                            <div class="jie-right haslearn is_learned js-learn" data-type="1">
                                已学
                            </div>
                        {@else}
                            <!-- 购买了  -->
                            {@if data.isBuy }
                                <div class="jie-right learn js-learn" data-type="1">
                                    学习
                                </div>
                            {@else}
                                {@if it.is_pay == "0" }
                                <!--免费小节 不占用试读次数  -->
                                    <div class="jie-right learn js-learn" data-type="1">
                                        免费
                                    </div>
                                {@else}
                                    <div class="jie-right learn js-learn" data-type="0">
                                        学习
                                    </div>
                                {@/if}
                            {@/if}
                            
                            
                        {@/if}
                    </a>
                </li>
            {@/each}
        </ul>
    </li>
{@/each}
</ul>
</script> 

<!-- 阅读页 阅读页   专栏目录  -->
<script type="text/template" id="catalog-tpl">
<div>
    <h2 class="article-title">${data.a_name}</h2>
    <ul class="catalog">
    {@each data.list as item}
        <li class="zhang">
            {@if data.structure_mode == "1" }
                <!--章节模式-->
                <div class="zhang-title">
                    ${item.title}
                    <!-- <div class="num">共${item.count}节</div> -->
                </div>
            {@/if}  
            <ul class="zhang-detail">
                {@each item.list as it,i}
                    <li class="jie">
                        <!--买了且开放的-->
                        <a href="/read/${data.column_id}/article/${it.id}">
                            <div class="jie-title clearfix full">
                                <p>
                                    {@if data.last_chapter == it.id }
                                        <span class="recent">最近阅读</span>
                                    {@/if}
                                    ${it.title}
                                </p>
                            </div>
                        </a>
                    </li>
                {@/each}
            </ul>
        </li>
    {@/each}
    </ul>
</div>
</script>





<script type="text/javascript">
	var isApp = "";
	var clientVersion = "0";
	var count_num = "0";
	var chapter_id = "2217";
	var chapter_title = "17 探讨 Fiber 性能优化机制";
	var aid = "83";
	var a_name = "专业技术团队出品：React深度剖析+实战";
	var a_price = "58.00";
	var a_pic = "https://img3.mukewang.com/5f0d82e10001220c05400720.jpg";
	var userId = 0;

	var column_id = '83';
	var isLogin = 0;
	

</script>
<!-- 引入字体 -->
<script type="text/javascript" src="//cdn.webfont.youziku.com/wwwroot/js/wf/youziku.api.min.js"></script>
<script type="text/javascript">
$youziku.load(".top-con .title, .cl-preview-section h1,.cl-preview-section h2,.cl-preview-section h3,.cl-preview-section h4,.cl-preview-section h5,.cl-preview-section h6", "37af461390fa4d138f5c3d277f7286dc", "SourceHanSerifSC-Heavy"); // 思源宋体heavy
$youziku.load(".lead-motto, .cl-preview-section blockquote", "d9a0d855583142c3b2cc3bf1646a8473", "SourceHanSerifSC-Regular"); // 思源宋体regular
$youziku.load("#article_content, .cl-preview-section pre, .cl-preview-section code, #code-copy", "3d84aabcf9e44b6f8c6fa91c61fa926e", "HYQiHei-55S"); // 汉仪旗黑55s
$youziku.load(".cl-preview-section strong", "fd94fff3a17546a28913a79613bddcec", "HYQiHei-77S"); // 汉仪旗黑70s

$youziku.draw();
</script>

<style type="text/css">
  header{
    display: none!important;
  }
  
  #wrapper{
  	padding-top:0px !important;
  }
  
</style>



    <link rel="stylesheet" href="https://m.imooc.com/static/wap/static/common/css/common_d42b1ef.css" /><link rel="stylesheet" href="https://m.imooc.com/static/wap/static/css/read/7.2.8/article_2d28313.css" /></head>
    <body >
        
          
        

        
          
        

        
          







<header class="directory2">
	<div class="header clearfix">
		
			
				<div class="page-title clearfix">
					<a href="//m.imooc.com" class="imwap-icon-imooc"></a>
					<div class="page-title-name js-page-name">
						<span>专栏</span>
						<i class="imwap-arrow_d"></i>
					</div>
				</div>
			

			
			<div class="drawer-box js-drawer-more">
				<i class="imwap-more_vert"></i>
				<div class="drawer-content js-drawer-content">
					<p class="line-row"></p>
					<a class="drawer-item" href="//m.imooc.com"><i class="imwap-center"></i>回到首页</a>
					<a class="drawer-item" href="//www.imooc.com/m/web/user/usercenter.html"><i class="imwap-peaple"></i>个人中心</a>
					<a class="drawer-item" href="//m.imooc.com/feedback"><i class="imwap-comment"></i>反馈问题</a>
					
					<a class="drawer-item" href="//m.imooc.com/account/login"><i class="imwap-out"></i>注册登录</a>
					
				</div>
			</div>
			

			
				<a id="js-appload" href="Javascript:;" class="app-load"><span>下载APP</span></a>
			

		
	</div>
	
	<div class="page-tab-wrap">
		<div class="page-tab-list">
			<a href="//m.imooc.com" class="page-tab-item">首页</a>
			<a href="//m.imooc.com/course/list" class="page-tab-item">课程</a>
			<a href="//coding.m.imooc.com" class="page-tab-item">实战</a>
			<a href="//class.m.imooc.com" class="page-tab-item">金职位</a>
			<a href="//m.imooc.com/article" class="page-tab-item">手记</a>
			<a href="//m.imooc.com/read" class="page-tab-item active">专栏</a>
			<a href="//m.imooc.com/wenda" class="page-tab-item">猿问</a>
			<a href="//m.imooc.com/wiki" class="page-tab-item">慕课教程</a>
			
		</div>
	</div>
	
</header>


        

        <div id="wrapper">
            <div id="middle" class="container ">

                

                
	
		
	
	<div class="top-con">
		<p class="update-time"><span>2020-07-21&nbsp;&nbsp;&nbsp;更新</span></p>
		<div class="title">
			17 探讨 Fiber 性能优化机制
		</div>
	</div>
	
		<div class="article-img" style="background-image: url('https://img1.mukewang.com/5f0fbbaa0001a93606400359.jpg')"></div>
	
	
		<a href="/read/83">
			<div class="course-entry">
				<img src="https://img.mukewang.com/5f16532e00018d6b10061006-40-40.jpg" alt="BetterFE">
				<h3>专业技术团队出品：React深度剖析+实战</h3>
				<p>BetterFE · 业务中台前端组</p>
				<i class="imwap-arrow_r"></i>
			</div>
		</a>
	
	
		<div class="lead-motto">
			<div class="content">知识犹如人体的血液一样宝贵。<p class="author">——高士其</p></div>
		</div>
	
	
		<div class="content" id="article_content">
			
			<div class="cl-preview-section"><h2 id="引导语">引导语</h2>
</div><div class="cl-preview-section"><p>对于很多人来说，React Fiber 可能有些陌生，React Fiber 是一种架构，通过这种架构，React 实现了性能方面的优化，本章节内容较多，涉及的知识点也比较多，理解起来可能会有些困难，但只要跟着我们的节奏，相信你一定可以彻底搞懂 React Fiber 。</p>
</div><div class="cl-preview-section"><h2 id="javascript-运行机制">JavaScript 运行机制</h2>
</div><div class="cl-preview-section"><p>首先，我们从 JavaScript 运行机制开始谈起。大家都知道， JavaScript 是单线程运行的，同时只能做一件事情，前面一件事做完才能执行下面一件事情。如果前面有一个任务长期霸占 CPU ，那后面的什么事情都干不了，此时浏览器会呈现卡死的状态，这样的情况下，用户体验会很差。</p>
</div><div class="cl-preview-section"><p>对于我们前端框架而言，解决这种问题通常有三个方向：</p>
</div><div class="cl-preview-section"><ol>
<li>优化每个任务，提高它的运行速度，挤压 CPU 运算量；</li>
<li>快速响应用户，让用户觉得快，不阻塞用户的交互；</li>
<li>尝试 Worker 多线程。</li>
</ol>
</div><div class="cl-preview-section"><p>Vue 选择了第一种，而 React 选择了第二种，本节内容也主要针对第二种来展开。</p>
</div><div class="cl-preview-section"><h2 id="为什么要引入-fiber">为什么要引入 Fiber</h2>
</div><div class="cl-preview-section"><p>那么 React 为什么要引入 Fiber 架构呢？ React V15 在渲染时，会递归比对 VirtualDOM 树，找出需要变动的节点，然后同步更新它们， 一气呵成。这个过程 React 称为 Reconcilation 。在 Reconcilation 期间， React 会占据浏览器资源，会导致用户触发的事件得不到响应，并且会导致掉帧，导致用户感觉到卡顿（更多关于 Reconcilation 的知识请参考扩展阅读）。</p>
</div><div class="cl-preview-section"><p>基于 Reconcilation 导致的性能问题，React 如何进行优化呢？为了给用户制造一种应用很快的“假象”，我们不能让一个任务长期霸占着资源。 你可以将浏览器的渲染、布局、绘制、资源加载(例如 HTML 解析)、事件响应、脚本执行视作操作系统的“进程”，我们需要通过某些调度策略合理地分配 CPU 资源，从而提高浏览器的用户响应速率, 同时兼顾任务执行效率。</p>
</div><div class="cl-preview-section"><p>所以 React 通过Fiber 架构，让自己的 Reconcilation 过程变成可被中断。“适时”地让出 CPU 执行权，除了可以让浏览器及时地响应用户的交互，还有其他好处:</p>
</div><div class="cl-preview-section"><ol>
<li>与其一次性操作大量 DOM 节点相比, 分批延时对DOM进行操��，可以得到更好的用户体验；</li>
<li>给浏览器一点喘息的机会，他会对代码进行编译优化（JIT）及进行热代码优化，或者对 reflow 进行修正。</li>
</ol>
</div><div class="cl-preview-section"><p>这就是为什么 React 要使用 Fiber 的原因。</p>
</div><div class="cl-preview-section"><h2 id="初识-fiber">初识 Fiber</h2>
</div><div class="cl-preview-section"><p>Fiber 也称协程、或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。</p>
</div><div class="cl-preview-section"><p>在这里，协程其实和 ES6 中的 Generator 很相似，比如我们执行普调函数时，执行的过程无法被中断和恢复，函数只要被调用了，就会从头执行到尾。</p>
</div><div class="cl-preview-section"><p>普调函数的执行过程，会从头执行到尾。</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">init</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'函数开始执行'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'函数结束执行'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 函数开始执行</span>
<span class="token comment">// 函数结束执行</span>
</code></pre>
</div><div class="cl-preview-section"><p>对于 Generator 函数：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">init</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'函数开始执行'</span><span class="token punctuation">)</span>
  <span class="token keyword">yield</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'暂停执行'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'函数结束执行'</span><span class="token punctuation">)</span>
  <span class="token keyword">yield</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'暂停执行'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> gen <span class="token operator">=</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 函数开始执行</span>
<span class="token comment">// 暂停执行</span>
<span class="token comment">// {value: undefined, done: false}</span>
gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//函数结束执行</span>
<span class="token comment">// 暂停执行</span>
<span class="token comment">// {value: undefined, done: false}</span>
gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// {value: undefined, done: true}</span>
</code></pre>
</div><div class="cl-preview-section"><p>Generator 运行过程中，当遇到 yield 时，函数可以被暂停，并在下一次执行 next() 后，接着上一次暂停的位置继续运行。并且在函数暂停的过程中，可以执行其他的函数或进行别的操作。</p>
</div><div class="cl-preview-section"><p>React Fiber 的思想就是如此， 渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</p>
</div><div class="cl-preview-section"><p>到这里，大家肯定有一个疑问， React Fiber 该何时执行、何时把控制权交给浏览器呢？<br>
理解这个问题，我们从一个最根本的问题开始说起： 为什么 JavaScript 一直占用主线程就会导致卡顿，卡顿是如何产生的？</p>
</div><div class="cl-preview-section"><h3 id="浏览器渲染的每一帧">浏览器渲染的每一帧</h3>
</div><div class="cl-preview-section"><p>页面是一帧一帧绘制出来的，通常当每秒的帧数（FPS）达到 60 时，页面就是顺畅的，小于这个值，用户就会感觉到卡顿。通常我们屏幕的帧率就是 60Hz ，这也代表每秒的画面由 60 个不同的画面组合而成。</p>
</div><div class="cl-preview-section"><p>每秒 60 帧，所以执行每一帧时间为：1000 / 60 ≈ 16.67 ms 。所以只要每次执行代码的时间小于 16.67 ms ，我们就能看到流畅的画面。</p>
</div><div class="cl-preview-section"><p>下面的图代表了浏览器每一帧所完成的事情，更多内容参考扩展阅读。</p>
</div><div class="cl-preview-section"><p><img src="https://image.guazistatic.com/gz01200420/11/09/c7f2cba1c1ba06fa53bd115bbdb1607c.png" alt=""></p>
</div><div class="cl-preview-section"><p>在主线程（ Main Thread ）中，一帧内主要完成以下五个部分的内容：<br>
<img src="https://image.guazistatic.com/gz01200420/11/10/caf78cbd1177ecabff5fea77453db76a.png" alt=""></p>
</div><div class="cl-preview-section"><ol>
<li>解析执行 JavaScript
<ul>
<li>事件处理</li>
<li>requestAnimationFrame</li>
</ul>
</li>
<li>样式计算</li>
<li>布局</li>
<li>绘制</li>
<li>合成</li>
</ol>
</div><div class="cl-preview-section"><p>在以上五个主要步骤中，任何一步所占用的时间过长，总时间超过 了 16.67ms ，浏览器本来该执行下一帧的内容，但由于上一帧内容未执行完，用户也就感受到了卡顿。</p>
</div><div class="cl-preview-section"><h3 id="解决卡顿的解决方案">解决卡顿的解决方案</h3>
</div><div class="cl-preview-section"><p>通过前面的分析，我们只要把渲染更新过程拆分成多个子任务，每次只做一小部分并保证在 16.67ms 之内完成，完成后再看看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行。 这种策略叫做 Cooperative Scheduling（合作式调度）。</p>
</div><div class="cl-preview-section"><p>合作式调度主要就是用来分配任务的，当有更新任务来的时候，不会马上去做 Diff 操作，而是先把当前的更新送入一个 Update Queue 中，然后交给 Scheduler 去处理，Scheduler 会根据当前主线程的使用情况去处理这次 Update。为了实现这种特性，使用了 <code>requestIdelCallback</code>。对于不支持这个 API 的浏览器，React 会加上 pollyfill 。</p>
</div><div class="cl-preview-section"><p>也就是前面我们说的，浏览器按照一帧一帧来执行，在一帧执行完成之后，检查主线程是否还有空闲时间，通过 <code>requestIdelCallback</code> 可以在这个空闲期（ Idle Period ）调用空闲期回调（ Idle Callback ），来执行一些任务。如图， Madin Thread 中最后执行：<code>requestIdelCallback</code> 。<br>
<img src="https://image.guazistatic.com/gz01200420/11/10/474fe461daebd1501862c298d8074ed4.png" alt=""></p>
</div><div class="cl-preview-section"><p>requestIdleCallback API 代码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript">window<span class="token punctuation">.</span><span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>
  callback<span class="token punctuation">:</span> <span class="token punctuation">(</span>dealine<span class="token punctuation">:</span> IdleDeadline<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span><span class="token punctuation">,</span>
  option<span class="token operator">?</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>timeout<span class="token punctuation">:</span> number<span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>IdleDeadline 对象如下</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">interface</span> <span class="token class-name">IdleDealine</span> <span class="token punctuation">{</span>
  didTimeout<span class="token punctuation">:</span> boolean <span class="token comment">// 表示任务执行是否超过约定时间</span>
  <span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> DOMHighResTimeStamp <span class="token comment">// 任务可供执行的剩余时间</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>requestIdleCallback 在执行的过程中会按下面的规则来进行：</p>
</div><div class="cl-preview-section"><ol>
<li>低优先级任务由 requestIdleCallback 处理；</li>
<li>高优先级任务，如动画相关的由 requestAnimationFrame 处理；</li>
<li>requestIdleCallback 可以在多个空闲期调用空闲期回调，执行任务；</li>
<li>requestIdleCallback 方法提供 deadline ，即任务执行限制时间，以切分任务，避免长时间执行，阻塞 UI 渲染而导致掉帧。</li>
</ol>
</div><div class="cl-preview-section"><h2 id="执行单元">执行单元</h2>
</div><div class="cl-preview-section"><p>Fiber 从某种意义上说就是一个执行单元，并且 React 没有使用 Generator 这些语言/语法层面的让出机制，而是实现了自己的调度让出机制。这个机制就是基于 Fiber 这个执行单元的，它的过程如下：<br>
假设用户调用 setState 更新组件, 这个待更新的任务会先放入队列中, 然后通过 requestIdleCallback 请求浏览器调度：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript">updateQueue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>updateTask<span class="token punctuation">)</span>
<span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>performWork<span class="token punctuation">,</span> <span class="token punctuation">{</span>timeout<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>现在浏览器有空闲或者超时了就会调用 performWork 来执行任务：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token comment">// 1 performWork 会拿到一个Deadline，表示剩余时间</span>
<span class="token keyword">function</span> <span class="token function">performWork</span><span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>

  <span class="token comment">// 2 循环取出updateQueue中的任务</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>updateQueue<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> ENOUGH_TIME<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">workLoop</span><span class="token punctuation">(</span>deadline<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 3 如果在本次执行中，未能将所有任务执行完毕，那就再请求浏览器调度</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>updateQueue<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">requestIdleCallback</span><span class="token punctuation">(</span>performWork<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>workLoop 从更新队列（updateQueue）中弹出更新任务来执行，每执行完一个执行单元，就检查一下剩余时间是否充足，如果充足就进行执行下一个执行单元，反之则停止执行，保存现场，等下一次有执行权时恢复：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token comment">// 保存当前的处理现场</span>
<span class="token keyword">let</span> nextUnitOfWork<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> undefined <span class="token comment">// 保存下一个需要处理的工作单元</span>
<span class="token keyword">let</span> topWork<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> undefined        <span class="token comment">// 保存第一个工作单元</span>

<span class="token keyword">function</span> <span class="token function">workLoop</span><span class="token punctuation">(</span>deadline<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// updateQueue中获取下一个或者恢复上一次中断的执行单元</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>nextUnitOfWork <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    nextUnitOfWork <span class="token operator">=</span> topWork <span class="token operator">=</span> <span class="token function">getNextUnitOfWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">//  每执行完一个执行单元，检查一次剩余时间</span>
  <span class="token comment">// 如果被中断，下一次执行还是从 nextUnitOfWork 开始处理</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>nextUnitOfWork <span class="token operator">&amp;&amp;</span> deadline<span class="token punctuation">.</span><span class="token function">timeRemaining</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> ENOUGH_TIME<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 下文我们再看performUnitOfWork</span>
    nextUnitOfWork <span class="token operator">=</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>nextUnitOfWork<span class="token punctuation">,</span> topWork<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 提交工作，下文会介绍</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingCommit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">commitAllWork</span><span class="token punctuation">(</span>pendingCommit<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>以下的流程图为 Fiber 的执行过程：<br>
<img src="https://image.guazistatic.com/gz01200420/11/10/608ff7a855608e5a38e9902037e1544e.png" alt=""></p>
</div><div class="cl-preview-section"><h2 id="调整数据结构">调整数据结构</h2>
</div><div class="cl-preview-section"><p>React 16 之前，Reconcilation 是同步的、递归执行的。是基于函数调用栈的 Reconcilation 算法，因此通常也称它为 Stack Reconcilation 。这种依赖于调用栈的方式不能随意中断、也很难被恢复, 不利于异步处理，是一口气执行完。所以，采用 React Fiber 后，需要对数据结构进行调整，首先我们需要对 React 现有的数据结构进行调整，模拟函数调用栈, 将之前需要递归进行处理的事情分解成增量的执行单元，将递归转换成迭代。</p>
</div><div class="cl-preview-section"><h3 id="fiber-tree">Fiber Tree</h3>
</div><div class="cl-preview-section"><p>React 目前的做法是使用链表, 每个 VirtualDOM 节点内部现在使用 Fiber表示, 它的结构大概如下：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">interface</span> <span class="token class-name">Fiber</span> <span class="token punctuation">{</span>
  <span class="token comment">/**
   *  节点的类型信息
   */</span>
  <span class="token comment">// 标记 Fiber 类型, 例如函数组件、类组件、宿主组件</span>
  tag<span class="token punctuation">:</span> WorkTag<span class="token punctuation">,</span>
  <span class="token comment">// 节点元素类型, 是具体的类组件、函数组件、宿主组件(字符串)</span>
  type<span class="token punctuation">:</span> any<span class="token punctuation">,</span>

  <span class="token comment">/**
   * 结构信息
   */</span> 
  <span class="token keyword">return</span><span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  child<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  sibling<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token comment">// 子节点的唯一键, 即我们渲染列表传入的key属性</span>
  key<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>

  <span class="token comment">/**
   * 节点的状态
   */</span>
  <span class="token comment">// 节点实例(状态)：</span>
  <span class="token comment">//        对于宿主组件，这里保存宿主组件的实例, 例如DOM节点。</span>
  <span class="token comment">//        对于类组件来说，这里保存类组件的实例</span>
  <span class="token comment">//        对于函数组件说，这里为空，因为函数组件没有实例</span>
  stateNode<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// 新的、待处理的props</span>
  pendingProps<span class="token punctuation">:</span> any<span class="token punctuation">,</span>
  <span class="token comment">// 上一次渲染的props</span>
  memoizedProps<span class="token punctuation">:</span> any<span class="token punctuation">,</span> <span class="token comment">// The props used to create the output.</span>
  <span class="token comment">// 上一次渲染的组件状态</span>
  memoizedState<span class="token punctuation">:</span> any<span class="token punctuation">,</span>


  <span class="token comment">/**
   * 副作用
   */</span>
  <span class="token comment">// 当前节点的副作用类型，例如节点更新、删除、移动</span>
  effectTag<span class="token punctuation">:</span> SideEffectTag<span class="token punctuation">,</span>
  <span class="token comment">// 和节点关系一样，React 同样使用链表来将所有有副作用的Fiber连接起来</span>
  nextEffect<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>

  <span class="token comment">/**
   * 替身
   * 指向旧树中的节点
   */</span>
  alternate<span class="token punctuation">:</span> Fiber <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>更详细的代码参考 <a href="https://github.com/facebook/react/blob/v16.2.0/packages/react-reconciler/src/ReactFiber.js#L91">ReactFiber.js</a></p>
</div><div class="cl-preview-section"><p>有了这个数据结构调整，现在可以以迭代的方式来处理这些节点了。来看看 performUnitOfWork 的实现, 它其实就是一个深度优先的遍历：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token comment">/**
 * @params fiber 当前需要处理的节点
 * @params topWork 本次更新的根节点
 */</span>
<span class="token keyword">function</span> <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">:</span> Fiber<span class="token punctuation">,</span> topWork<span class="token punctuation">:</span> Fiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 对该节点进行处理</span>
  <span class="token function">beginWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 如果存在子节点，那么下一个待处理的就是子节点</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>child<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> fiber<span class="token punctuation">.</span>child<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 没有子节点了，上溯查找兄弟节点</span>
  <span class="token keyword">let</span> temp <span class="token operator">=</span> fiber<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">completeWork</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 到顶层节点了, 退出</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">===</span> topWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 找到，下一个要处理的就是兄弟节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>sibling<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> temp<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 没有, 继续上溯</span>
    temp <span class="token operator">=</span> temp<span class="token punctuation">.</span><span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>配合上文的 workLoop ，Fiber 就是我们所说的工作单元，performUnitOfWork 负责对 Fiber 进行操作，并按照深度遍历的顺序返回下一个 Fiber。<br>
因为使用了链表结构，即使处理流程被中断了，我们随时可以从上次未处理完的Fiber继续遍历下去。</p>
</div><div class="cl-preview-section"><h2 id="两个执行阶段">两个执行阶段</h2>
</div><div class="cl-preview-section"><p>React 的 reconciler 叫做 Stack reconciler，也就是自顶向下的更新过程，无法中断，一口气干完所有事，影响布局、动画等任务的执行。React 16 之后的 reconciler 执行过程分为 2 个阶段（phase）：</p>
</div><div class="cl-preview-section"><ol>
<li>
<p><strong>协调阶段</strong>：（可中断）render/reconciliation 通过构造 workInProgress tree 得出 change ，其实可以认为这是个 Diff 阶段。下面的生命周期钩子函数会在此阶段被调用：</p>
<ul>
<li><code>constructor</code></li>
<li><code>componentWillMount</code> (废弃)</li>
<li><code>componentWillReceiveProps</code> (废弃)</li>
<li><code>static getDerivedStateFromProps</code></li>
<li><code>shouldComponentUpdate</code></li>
<li><code>componentWillUpdate</code> (废弃)</li>
<li><code>render</code></li>
</ul>
</li>
<li>
<p><strong>提交阶段</strong>：（不可中断）commit 应用这些 DOM change 。下面这些生命周期钩子函数会在此阶段被调用：</p>
<ul>
<li><code>getSnapshotBeforeUpdate</code> 严格来说，这个是在进入 commit 阶段前调用</li>
<li><code>componentDidMount</code></li>
<li><code>componentDidUpdate</code></li>
<li><code>componentWillUnmount</code></li>
</ul>
</li>
</ol>
</div><div class="cl-preview-section"><p>也就是说，在协调阶段如果时间片用完，React就会选择让出控制权。因为协调阶段执行的工作不会导致任何用户可见的变更，所以在这个阶段让出控制权不会有什么问题。</p>
</div><div class="cl-preview-section"><blockquote>
<p>因为协调阶段可能被中断、恢复，甚至重做，React 协调阶段的生命周期钩子可能会被调用多次! 例如 componentWillMount ， 可能会被调用两次。因此建议协调阶段的生命周期钩子不要包含副作用（DOM变更、发起的异步请求等）。</p>
</blockquote>
</div><div class="cl-preview-section"><h3 id="reconciliation">Reconciliation</h3>
</div><div class="cl-preview-section"><p>看上面的 Fiber 结构的代码，包含的属性可以划分为 5 个部分：</p>
</div><div class="cl-preview-section"><ol>
<li><strong>结构信息</strong>：这个上文我们已经见过了，Fiber 使用链表的形式来表示节点在树中的定位；</li>
<li><strong>节点类型信息</strong>：这个也容易理解，tag 表示节点的分类、type 保存具体的类型值，如 div、MyComponent；</li>
<li><strong>节点的状态</strong>：节点的组件实例、props、state 等，它们将影响组件的输出；</li>
<li><strong>副作用</strong>：这个也是新东西. 在 Reconciliation 过程中发现的’副作用’(变更需求)就保存在节点的 effectTag 中(想象为打上一个标记)，那么怎么将本次渲染的所有节点副作用都收集起来呢？ 这里也使用了链表结构，在遍历过程中 React 会将所有有‘副作用’的节点都通过 nextEffect 连接起来；</li>
<li><strong>替身</strong>：React 在 Reconciliation 过程中会构建一颗新的树(官方称为 workInProgress tree，WIP 树)，可以认为是一颗表示当前工作进度的树。还有一颗表示已渲染界面的旧树，React 就是一边和旧树比对，一边构建WIP树的。 alternate 指向旧树的同等节点。</li>
</ol>
</div><div class="cl-preview-section"><p>接着看看 <code>beginWork</code> 是如何对 Fiber 进行比较的：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">beginWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">:</span> Fiber<span class="token punctuation">)</span><span class="token punctuation">:</span> Fiber <span class="token operator">|</span> undefined <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>tag <span class="token operator">===</span> WorkTag<span class="token punctuation">.</span>HostComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 宿主节点diff</span>
    <span class="token function">diffHostComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>tag <span class="token operator">===</span> WorkTag<span class="token punctuation">.</span>ClassComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类组件节点diff</span>
    <span class="token function">diffClassComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>tag <span class="token operator">===</span> WorkTag<span class="token punctuation">.</span>FunctionComponent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 函数组件节点diff</span>
    <span class="token function">diffFunctionalComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// ... 其他类型节点，省略</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>宿主节点对比：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">diffHostComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">:</span> Fiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 新增节点</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>stateNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fiber<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token function">createHostComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">updateHostComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> newChildren <span class="token operator">=</span> fiber<span class="token punctuation">.</span>pendingProps<span class="token punctuation">.</span>children<span class="token punctuation">;</span>

  <span class="token comment">// 比对子节点</span>
  <span class="token function">diffChildren</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> newChildren<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>类组件节点对比：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">diffClassComponent</span><span class="token punctuation">(</span>fiber<span class="token punctuation">:</span> Fiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建组件实例</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>stateNode <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fiber<span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token function">createInstance</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>hasMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用更新前生命周期钩子</span>
    <span class="token function">applybeforeUpdateHooks</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 调用挂载前生命周期钩子</span>
    <span class="token function">applybeforeMountHooks</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 渲染新节点</span>
  <span class="token keyword">const</span> newChildren <span class="token operator">=</span> fiber<span class="token punctuation">.</span>stateNode<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 比对子节点</span>
  <span class="token function">diffChildren</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> newChildren<span class="token punctuation">)</span><span class="token punctuation">;</span>

  fiber<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> fiber<span class="token punctuation">.</span>stateNode<span class="token punctuation">.</span>state
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>子节点对比：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">diffChildren</span><span class="token punctuation">(</span>fiber<span class="token punctuation">:</span> Fiber<span class="token punctuation">,</span> newChildren<span class="token punctuation">:</span> React<span class="token punctuation">.</span>ReactNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> oldFiber <span class="token operator">=</span> fiber<span class="token punctuation">.</span>alternate <span class="token operator">?</span> fiber<span class="token punctuation">.</span>alternate<span class="token punctuation">.</span>child <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 全新节点，直接挂载</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">mountChildFibers</span><span class="token punctuation">(</span>fiber<span class="token punctuation">,</span> newChildren<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> newFiber <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 新子节点</span>
  <span class="token keyword">const</span> elements <span class="token operator">=</span> <span class="token function">extraElements</span><span class="token punctuation">(</span>newChildren<span class="token punctuation">)</span>

  <span class="token comment">// 比对子元素</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> elements<span class="token punctuation">.</span>length <span class="token operator">||</span> oldFiber <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> prevFiber <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token keyword">const</span> element <span class="token operator">=</span> elements<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
    <span class="token keyword">const</span> sameType <span class="token operator">=</span> <span class="token function">isSameType</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> oldFiber<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sameType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newFiber <span class="token operator">=</span> <span class="token function">cloneFiber</span><span class="token punctuation">(</span>oldFiber<span class="token punctuation">,</span> element<span class="token punctuation">)</span>
      <span class="token comment">// 更新关系</span>
      newFiber<span class="token punctuation">.</span>alternate <span class="token operator">=</span> oldFiber
      <span class="token comment">// 打上Tag</span>
      newFiber<span class="token punctuation">.</span>effectTag <span class="token operator">=</span> UPDATE
      newFiber<span class="token punctuation">.</span><span class="token keyword">return</span> <span class="token operator">=</span> fiber
    <span class="token punctuation">}</span>

    <span class="token comment">// 新节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>sameType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      newFiber <span class="token operator">=</span> <span class="token function">createFiber</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>
      newFiber<span class="token punctuation">.</span>effectTag <span class="token operator">=</span> PLACEMENT
      newFiber<span class="token punctuation">.</span><span class="token keyword">return</span> <span class="token operator">=</span> fiber
    <span class="token punctuation">}</span>

    <span class="token comment">// 删除旧节点</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>sameType<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldFiber<span class="token punctuation">.</span>effectTag <span class="token operator">=</span> DELETION<span class="token punctuation">;</span>
      oldFiber<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> fiber<span class="token punctuation">.</span>nextEffect
      fiber<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> oldFiber
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldFiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oldFiber <span class="token operator">=</span> oldFiber<span class="token punctuation">.</span>sibling<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      fiber<span class="token punctuation">.</span>child <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>prevFiber <span class="token operator">&amp;&amp;</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevFiber<span class="token punctuation">.</span>sibling <span class="token operator">=</span> newFiber<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    index<span class="token operator">++</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>上面的代码很粗糙地还原了 Reconciliation 的过程, 但是对于我们理解React的基本原理已经足够了。<br>
这张图很详细的描述了整个过程，可以在扩展阅读中查看。<br>
<img src="https://image.guazistatic.com/gz01200420/11/11/14aec1c3479a1812d26848a3f25503c4.png" alt=""></p>
</div><div class="cl-preview-section"><h3 id="双缓冲">双缓冲</h3>
</div><div class="cl-preview-section"><p>WIP 树构建这种技术类似于图形化领域的’双缓存（Double Buffering）‘ 技术，图形绘制引擎一般会使用双缓冲技术，先将图片绘制到一个缓冲区，再一次性传递给屏幕进行显示，这样可以防止屏幕抖动，优化渲染性能。<br>
放到 React 中，WIP 树就是一个缓冲，它在 Reconciliation 完毕后一次性提交给浏览器进行渲染。它可以减少内存分配和垃圾回收，WIP 的节点不完全是新的，比如某颗子树不需要变动，React 会克隆复用旧树中的子树。<br>
双缓存技术还有另外一个重要的场景就是异常的处理，比如当一个节点抛出异常，仍然可以继续沿用旧树的节点，避免整棵树挂掉。<br>
有一个非常恰当的比喻，那就是 Git 功能分支，你可以将 WIP 树想象成从旧树中 Fork 出来的功能分支，你在这新分支中添加或移除特性，即使是操作失误也不会影响旧的分支。当你这个分支经过了测试和完善，就可以合并到旧分支，将其替换掉. 这或许就是’提交（commit）阶段‘的提交一词的来源。</p>
</div><div class="cl-preview-section"><h3 id="副作用的收集和提交">副作用的收集和提交</h3>
</div><div class="cl-preview-section"><p>接下来就是将所有打了 Effect 标记的节点串联起来，这个可以在 completeWork 中做, 例如：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">completeWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> parent <span class="token operator">=</span> fiber<span class="token punctuation">.</span><span class="token keyword">return</span>

  <span class="token comment">// 到达顶端</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> fiber <span class="token operator">===</span> topWork<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pendingCommit <span class="token operator">=</span> fiber
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>effectTag <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>nextEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent<span class="token punctuation">.</span>nextEffect<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> fiber
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      parent<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> fiber
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>nextEffect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    parent<span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> fiber<span class="token punctuation">.</span>nextEffect
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>最后将所有副作用提交：</p>
</div><div class="cl-preview-section"><pre class="  language-javascript"><code class="prism  language-javascript"><span class="token keyword">function</span> <span class="token function">commitAllWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> next <span class="token operator">=</span> fiber
  <span class="token keyword">while</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fiber<span class="token punctuation">.</span>effectTag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 提交，偷一下懒，这里就不展开了</span>
      <span class="token function">commitWork</span><span class="token punctuation">(</span>fiber<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    next <span class="token operator">=</span> fiber<span class="token punctuation">.</span>nextEffect
  <span class="token punctuation">}</span>

  <span class="token comment">// 清理现场</span>
  pendingCommit <span class="token operator">=</span> nextUnitOfWork <span class="token operator">=</span> topWork <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>

</code></pre>
</div><div class="cl-preview-section"><h2 id="中断和恢复">中断和恢复</h2>
</div><div class="cl-preview-section"><p>中断：检查当前正在处理的工作单元，保存当前成果（firstEffect, lastEffect），修改 tag 标记一下，迅速收尾并再开一个 requestIdleCallback，下次有机会再做；<br>
断点恢复：下次再处理到该工作单元时，看 tag 是被打断的任务，接着做未完成的部分或者重做。</p>
</div><div class="cl-preview-section"><h2 id="小结">小结</h2>
</div><div class="cl-preview-section"><p>本章节探讨了浏览器为什么会产生卡顿的问题，并讲解了 React Fiber 的全过程。内容很多并且理解起来不是很容易，大家可以继续阅读知识扩展阅读来加深理解。</p>
</div><div class="cl-preview-section"><h2 id="知识扩展阅读">知识扩展阅读</h2>
</div><div class="cl-preview-section"><p><a href="https://www.reactjscn.com/docs/reconciliation.html">协调（Reconciliation）</a><br>
<a href="http://es6.ruanyifeng.com/#docs/generator">Generator 函数入门</a><br>
<a href="https://juejin.im/post/5c9c66075188251dab07413d">[译] 浏览器帧原理剖析</a><br>
<a href="https://developers.google.com/web/updates/2015/08/using-requestidlecallback?hl=en">使用requestIdleCallback</a><br>
<a href="https://juejin.im/post/5ab7b3a2f265da2378403e57">React Fiber</a></p>
</div>
			
		</div>
	
	
	<div class="finish-learn">
		<p class="copyright">©版权归慕课网所有，未经许可不得转载</p>
		
		
		
		<div class="ad_pic">
			<img src="https://img4.mukewang.com/5f0fbbb2000109e706700192.jpg">
		</div>
		
		
		
		
	</div>
	<div class="comment-con">
		<h4 class="title">
			精选留言
			
				<a href="javascript: void(0);" class="add-comment js-comment-click"><i class="imwap-xieliuyan"></i><span>写留言</span></a>
			
		</h4>
		
			<p class="bottom-text empty">暂无精选留言</p>
		
	</div>
	
	

	
		
	
	
	
		<div class="bottom-con">
			
			
				<div class="inner">
					
						<div class="price-con js-price-con">
							<span class="now">￥58.00</span>
						</div>
							
					
					
					<a class="gobuy js-gobuy" href="//m.imooc.com/account/login?backurl=//m.imooc.com/confirmorder?type=30&typeid=83">
					
						立即购买
					</a>  
				</div>
			
		</div>
	
	<div class="layer-catalog js-layer-catalog hide">
		<div class="layer-title clearfix">
			<div class="l">
				课程目录
			</div>
			
		</div>
		<div class="layer-wrap">
			<div class="js-catalog-container">
			</div>
		</div>
	</div>
	<div class="layer-comment">
		<div class="inner">
			<h5>
				<span class="btn l js-cancel-comment">取消</span>
				评论
				<span class="btn r js-send-comment">发送</span>
			</h5>
			<textarea id="comment-txt" maxlength="20000" placeholder="欢迎在这里发表留言，作者筛选后可公开显示"></textarea>
		</div>
	</div>


            </div>
        </div>
        
            
         
        
        
        
        




<script>
	// 设置字号大小及选中
	(function() {
			var fs = window.localStorage.getItem('font-size') || 'normal';
			var $c = document.querySelector('#middle>.content');
			var $points = document.querySelectorAll('.setting-box .point');
			try{
				// 抢读完了时 该元素不渲染 会有报错
				$c.className = 'content ' + fs;
				for(var i = 0; i < $points.length; i++) {
					if($points[i].className.indexOf(fs) > -1) {
						$points[i].className = $points[i].className + ' current';
					}
				}
			} catch(e) {}
			
	})();
</script>

<script type="text/javascript">
	window.onload = function() {
			zhuge.track('LearnCourse', {
					'Category': '专栏',
					'Name': '17 探讨 Fiber 性能优化机制',
					'CID': '2217',
					'Teacher': 'BetterFE'
			});
	}
</script>

        
            <script type="text/javascript">
                var shareData = { 
                    title:  "17 探讨 Fiber 性能优化机制",
                    desc: "基础+源码+实战三管齐下的 React 全解读",
                    imgUrl: 'https:https://img3.mukewang.com/5f0d82e10001220c05400720.jpg',
                    otherImgUrl: 'https://img3.mukewang.com/5f0d82e10001220c05400720.jpg',
                    text: '我正在参加@慕课网的课程，很不错哦！快来一起学习吧！',
                    // url: 'https://www.imooc.com' + window.location.pathname + window.location.search
                    url: 'https://m.imooc.com/read/83',
                    link: 'https://m.imooc.com/read/83'
                }
            </script>
            
        
        <div style="display:none;">
            <!-- 百度统计 -->
            <script>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?c92536284537e1806a07ef3e6873f2b3";
              var s = document.getElementsByTagName("script")[0];
              s.parentNode.insertBefore(hm, s);
            })();
            </script>

            <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
            </script>
        </div>
        
    <script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/zhugeio/init_f9752c3.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/jquery-2.1.0.min_ac9f840.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/common_84429c0.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/juicer/juicer.min_8643248.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/previewImage/previewImage.min_43b970d.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/msg_bed8d10.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/read/7.2.8/article_30e5762.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/course/advertisementReport_6e58a98.js"></script></body>
</html>
