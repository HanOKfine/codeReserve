<!doctype html>
<html lang="zh_CN">

    

    

    
    
    
    <head>
        
        <title>12 从头做起：实现最简单的 TCP 客户端和服务器</title>
        
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="学好通用知识，提升技术竞争力">
        <meta name="keywords" content="慕课网">
        <meta name="author" content="">
        <meta name = "format-detection" content="telephone=no">
        <meta http-equiv="Cache-Control" content="no-transform " />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <link rel="shortcut icon" href="https://m.imooc.com/static/wap/static/favicon.ico" />
        
        
        
        <script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/flexible.js"></script>
        
        <script type="text/javascript">
            var userInfo = "";
            
                var isApp = 0;
            
        </script>
         
<!-- 专栏首页列表模板 -->
<script type="text/template" id="index-list-tpl">
<ul class="list-con">
    {@each data.data as item}
        <li>
            <a href="/read/${item.id}" class="item clearfix">
                <div class="img l" style="background-image: url(${item.app_pic1})">
                    {@if item.is_new }
                        <div class="icon new">
                            上新
                        </div>
                    {@else if item.is_marking} 
                        <div class="icon">
                            经典
                        </div>
                    {@/if} 
                </div>
                <div class="text-con l">
                    <div class="title">
                        ${item.title}
                    </div>
                    <div class="desc">
                        ${item.chapter_num}节 · ${item.description}
                    </div>
                     <div class="user-info">
                        ${item.nickname}
                        {@if item.author_title }
                        <span class="dot">
                            ·
                        </span>
                        ${item.author_title}
                        {@/if}
                    </div>
                    <div class="info clearfix">
                    {@if !item.isBuy } 
                        <!-- 未购买才显示 -->
                        <div class="price-con l">
                        {@if item.open_discount == "1" }
                            <span class="now">￥${item.pay_price}</span>
                            <span class="ori">￥${item.price}</span>
                            <p class="sale">${item.discount_name}</p>
                        {@else}
                            <span class="now">￥${item.price}</span>
                        {@/if}
                        </div>
                    {@/if}
                        <div class="taste-con r">
                            <span>${item.numbers}人订阅</span>
                            {@if !item.isBuy }
                                <span class="gotaste">试读</span>
                            {@else}
                                <span class="gotaste">学习</span>
                            {@/if}
                        </div>
                    </div>
                </div>
            </a>
        </li>
    {@/each}
</ul>
</script>



<!-- 专栏目录 买后目录页、 -->
<script type="text/template" id="detail-catalog-tpl">
<ul class="catalog-list">
{@each data.list as item}
    <li class="zhang">
        {@if data.structure_mode == "1" }
            <!--章节模式-->
            <div class="zhang-title">
                ${item.title}（${item.count}节）
            </div>
            <div class="zhang-sub-title">
                ${item.short_introduce}
            </div>
        {@/if}  
        <ul class="zhang-detail">
            {@each item.list as it,i}
                <li class="jie">
                    {@if data.isLogin }
                        <!-- 购买了  -->
                        {@if data.isBuy }
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read">
                        {@else}
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read" >
                        {@/if}
                    {@else}
                        <!-- 未登录  -->
                        {@if data.isApp }
                            <a href="javascript:;" onclick="window.nativeSupport.login();">
                        {@else}
                            <a href="//m.imooc.com/account/login?backurl=/read/${data.column_id}">
                        {@/if}
                    {@/if}
                        <div class="jie-con {@if data.last_chapter == it.id }recent{@/if}">
                            
                            <div class="text-con">
                                <div class="jie-title">
                                    ${it.title}
                                </div>
                                <div class="jie-status">
                                    {@if it.is_open == "0" }
                                        <span class="update-time" >${it.open_time_fmt}</span>
                                    {@/if}
                                    {@if it.view_num > 100 }
                                    <div class="learn-num">
                                        <i class="imwap-set-sns"></i>
                                        <span>${it.view_num}</span>
                                    </div>
                                    {@/if}
                                    {@if it.in_24hours == "1" }
                                        <span class="update-recent">最近更新</span>
                                    {@/if}
                                </div>
                            </div>
                        </div>
                        {@if it.is_learned }
                            <div class="jie-right haslearn is_learned js-learn" data-type="1">
                                已学
                            </div>
                        {@else}
                            <!-- 购买了  -->
                            {@if data.isBuy }
                                <div class="jie-right learn js-learn" data-type="1">
                                    学习
                                </div>
                            {@else}
                                {@if it.is_pay == "0" }
                                <!--免费小节 不占用试读次数  -->
                                    <div class="jie-right learn js-learn" data-type="1">
                                        免费
                                    </div>
                                {@else}
                                    <div class="jie-right learn js-learn" data-type="0">
                                        学习
                                    </div>
                                {@/if}
                            {@/if}
                            
                            
                        {@/if}
                    </a>
                </li>
            {@/each}
        </ul>
    </li>
{@/each}
</ul>
</script> 

<!-- 阅读页 阅读页   专栏目录  -->
<script type="text/template" id="catalog-tpl">
<div>
    <h2 class="article-title">${data.a_name}</h2>
    <ul class="catalog">
    {@each data.list as item}
        <li class="zhang">
            {@if data.structure_mode == "1" }
                <!--章节模式-->
                <div class="zhang-title">
                    ${item.title}
                    <!-- <div class="num">共${item.count}节</div> -->
                </div>
            {@/if}  
            <ul class="zhang-detail">
                {@each item.list as it,i}
                    <li class="jie">
                        <!--买了且开放的-->
                        <a href="/read/${data.column_id}/article/${it.id}">
                            <div class="jie-title clearfix full">
                                <p>
                                    {@if data.last_chapter == it.id }
                                        <span class="recent">最近阅读</span>
                                    {@/if}
                                    ${it.title}
                                </p>
                            </div>
                        </a>
                    </li>
                {@/each}
            </ul>
        </li>
    {@/each}
    </ul>
</div>
</script>





<script type="text/javascript">
	var isApp = "";
	var clientVersion = "0";
	var count_num = "0";
	var chapter_id = "2101";
	var chapter_title = "12 从头做起：实现最简单的 TCP 客户端和服务器";
	var aid = "80";
	var a_name = "零基础学透网络编程";
	var a_price = "58.00";
	var a_pic = "https://img2.mukewang.com/5ed8c1c600015fc805400720.jpg";
	var userId = 0;

	var column_id = '80';
	var isLogin = 0;
	

</script>
<!-- 引入字体 -->
<script type="text/javascript" src="//cdn.webfont.youziku.com/wwwroot/js/wf/youziku.api.min.js"></script>
<script type="text/javascript">
$youziku.load(".top-con .title, .cl-preview-section h1,.cl-preview-section h2,.cl-preview-section h3,.cl-preview-section h4,.cl-preview-section h5,.cl-preview-section h6", "37af461390fa4d138f5c3d277f7286dc", "SourceHanSerifSC-Heavy"); // 思源宋体heavy
$youziku.load(".lead-motto, .cl-preview-section blockquote", "d9a0d855583142c3b2cc3bf1646a8473", "SourceHanSerifSC-Regular"); // 思源宋体regular
$youziku.load("#article_content, .cl-preview-section pre, .cl-preview-section code, #code-copy", "3d84aabcf9e44b6f8c6fa91c61fa926e", "HYQiHei-55S"); // 汉仪旗黑55s
$youziku.load(".cl-preview-section strong", "fd94fff3a17546a28913a79613bddcec", "HYQiHei-77S"); // 汉仪旗黑70s

$youziku.draw();
</script>

<style type="text/css">
  header{
    display: none!important;
  }
  
  #wrapper{
  	padding-top:0px !important;
  }
  
</style>



    <link rel="stylesheet" href="https://m.imooc.com/static/wap/static/common/css/common_d42b1ef.css" /><link rel="stylesheet" href="https://m.imooc.com/static/wap/static/css/read/7.2.8/article_2d28313.css" /></head>
    <body >
        
          
        

        
          
        

        
          







<header class="directory2">
	<div class="header clearfix">
		
			
				<div class="page-title clearfix">
					<a href="//m.imooc.com" class="imwap-icon-imooc"></a>
					<div class="page-title-name js-page-name">
						<span>专栏</span>
						<i class="imwap-arrow_d"></i>
					</div>
				</div>
			

			
			<div class="drawer-box js-drawer-more">
				<i class="imwap-more_vert"></i>
				<div class="drawer-content js-drawer-content">
					<p class="line-row"></p>
					<a class="drawer-item" href="//m.imooc.com"><i class="imwap-center"></i>回到首页</a>
					<a class="drawer-item" href="//www.imooc.com/m/web/user/usercenter.html"><i class="imwap-peaple"></i>个人中心</a>
					<a class="drawer-item" href="//m.imooc.com/feedback"><i class="imwap-comment"></i>反馈问题</a>
					
					<a class="drawer-item" href="//m.imooc.com/account/login"><i class="imwap-out"></i>注册登录</a>
					
				</div>
			</div>
			

			
				<a id="js-appload" href="Javascript:;" class="app-load"><span>下载APP</span></a>
			

		
	</div>
	
	<div class="page-tab-wrap">
		<div class="page-tab-list">
			<a href="//m.imooc.com" class="page-tab-item">首页</a>
			<a href="//m.imooc.com/course/list" class="page-tab-item">课程</a>
			<a href="//coding.m.imooc.com" class="page-tab-item">实战</a>
			<a href="//class.m.imooc.com" class="page-tab-item">金职位</a>
			<a href="//m.imooc.com/article" class="page-tab-item">手记</a>
			<a href="//m.imooc.com/read" class="page-tab-item active">专栏</a>
			<a href="//m.imooc.com/wenda" class="page-tab-item">猿问</a>
			<a href="//m.imooc.com/wiki" class="page-tab-item">慕课教程</a>
			
		</div>
	</div>
	
</header>


        

        <div id="wrapper">
            <div id="middle" class="container ">

                

                
	
		
	
	<div class="top-con">
		<p class="update-time"><span>2020-06-09&nbsp;&nbsp;&nbsp;更新</span></p>
		<div class="title">
			12 从头做起：实现最简单的 TCP 客户端和服务器
		</div>
	</div>
	
		<div class="article-img" style="background-image: url('https://img3.mukewang.com/5ed9fc9c00018e2906400359.jpg')"></div>
	
	
		<a href="/read/80">
			<div class="course-entry">
				<img src="https://img4.mukewang.com/5458620000018a2602200220-40-40.jpg" alt="陈子兴">
				<h3>零基础学透网络编程</h3>
				<p>陈子兴 · 资深软件架构师</p>
				<i class="imwap-arrow_r"></i>
			</div>
		</a>
	
	
		<div class="lead-motto">
			<div class="content">要成就一件大事业，必须从小事做起。<p class="author">——列宁</p></div>
		</div>
	
	
		<div class="content" id="article_content">
			
			<div class="cl-preview-section"><h2 id="前言">前言</h2>
</div><div class="cl-preview-section"><p>本文将要介绍简单的 TCP 客户端、服务器程序的编写，其实在《初识网络协议大家族》一文中，我们编写了 nwchecker 程序，并且介绍了编写 TCP 客户端、服务器程序所涉及的 API 调用流程，并且在 TCP 三篇专栏中对 nwchecker 程序所支持的功能进行了不同程度的重构。然而这个程序非常的不完善，尤其是 Server 程序有很多缺陷，主要表现在以下几方面：</p>
</div><div class="cl-preview-section"><ul>
<li>服务器不能支持多个客户端的并发连接请求；</li>
<li>服务器不能在后台运行；</li>
<li>服务器出现故障后，立即重启可能会失败；</li>
<li>在数据读写的时候，recv() 和 send() 函数返回值处理不到位；</li>
<li>客户端和服务器都没有处理 SIGPIPE 信号可能会导致程序直接退出。</li>
</ul>
</div><div class="cl-preview-section"><p>当然我们在一篇文章中难以解决所有��题，只能通过后续的专栏逐个解决。</p>
</div><div class="cl-preview-section"><p>本文的代码是基于“\imooc-sock-core-tech\02-07_可靠传输协议_TCP_数据传输”的代码进行修改，代码最终保存在“imooc-sock-core-tech\03-11_最简单的TCP客户端服务器”目录下面。由于 nwchecker client 部分算是比较完善，针对客户端只是介绍相关 API，不做具体代码修改。我们的重点是进一步完善 nwchecker server 的实现。</p>
</div><div class="cl-preview-section"><p>首先让我们对 TCP API 的相关细节做一个全面的了解。</p>
</div><div class="cl-preview-section"><h2 id="tcp-api-介绍">TCP API 介绍</h2>
</div><div class="cl-preview-section"><p>现在请你和我一起回忆一下 nwchecker 的程序结构，图示如下：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5ed9a6580001c81206440635.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>总结起来 nwchecker 程序所涉及的八个 API 分为  3类：</p>
</div><div class="cl-preview-section"><ul>
<li>Client 和 Server 共用的 API 包括 socket()、close()、send()、recv() 四个函数；</li>
<li>Client 特有 API 只有 connect() 函数；</li>
<li>Server 特有 API 包括 bind()、listen()、accept() 三个函数。</li>
</ul>
</div><div class="cl-preview-section"><p>下来我们分别介绍每个 API 的返回值、参数、以及具体用法。除了 close() 函数需要包含 “unistd.h” 头文件外，剩余 7 个函数都是包含在头文件 “sys/socket.h” 和 “sys/types.h”中。</p>
</div><div class="cl-preview-section"><h3 id="头文件">头文件</h3>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token comment">/* close() 函数需要包含 */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token comment">/* 其余七个函数需要包含 */</span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
</code></pre>
</div><div class="cl-preview-section"><h3 id="socket-函数">socket() 函数</h3>
</div><div class="cl-preview-section"><p>socket() 函数用来创建一个 Socket 文件描述符，我们说过 Socket 和 Endpoint 是一个概念，然而程序是通过 <strong>文件描述符（fd）</strong> 来表示一个 Socket 的。</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token keyword">int</span> domain<span class="token punctuation">,</span> <span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">int</span> protocol<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li>
<p>返回值如果是 -1，表示函数调用失败，失败的原因可以参考 errno 的值；如果调用成功，返回一个 Socket 的 fd；</p>
</li>
<li>
<p>domain 表示协议族，一般传入类似 AF_XXX 的枚举值，比如 AF_INET、AF_INET6。当然你也可以传入类似 PF_XXX 的枚举值；</p>
</li>
<li>
<p>type 表示 socket 类型，比如 SOCK_STREAM、SOCK_DGRAM；</p>
</li>
<li>
<p>protocol 表示具体的协议类型，一般都填 0，通过第二个参数 type 就可以决定协议类型。</p>
</li>
</ul>
</div><div class="cl-preview-section"><h3 id="connect-函数">connect() 函数</h3>
</div><div class="cl-preview-section"><p>connect() 函数是客户端程序专有的一个 API，既可以用于 UDP Socket，也可以用于TCP Socket。当 TCP Socket 调用 connect() 函数，客户端会连接服务器，完成<strong>三次握手</strong>过程。当 UDP Socket 调用 connect() 函数，并不会真正的去连接服务器，只是完成一个本地的绑定。</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span>socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li>返回值如果是 -1，表示函数调用失败，失败的原因可以参考 errno 的值；否则表示连接成功或者是本地绑定成功。如果采用<strong>非阻塞 Socket</strong>，connect 返回值会有更多含义，我们后续再介绍；</li>
<li>sockfd 表示 Socket 文件描述符；</li>
<li>addr 表示服务器地址，真实地址结构应该是 struct sockaddr_in 或者 struct sockaddr_in6。包含了目标服务器监听的 IP 和 Port；</li>
<li>addrlen 表示真实地址结构长度。即 sizeof(struct sockaddr_in) 或者是 sizeof(struct sockaddr_in6)。</li>
</ul>
</div><div class="cl-preview-section"><p>当客户端调用 connect 连接服务器，我们只需要指定服务器的 <strong>IP 地址</strong>和<strong>端口</strong>，客户端本地的 <strong>IP 地址</strong>和<strong>端口号</strong>是由操作系统来分配。</p>
</div><div class="cl-preview-section"><p>在 ubuntu 18.04 下查看本地端口范围的方法：</p>
</div><div class="cl-preview-section"><pre><code>ubuntu@10-9-50-2:~$ sudo sysctl -a |grep local_port
net.ipv4.ip_local_port_range = 32768	60999
</code></pre>
</div><div class="cl-preview-section"><p>在 ubuntu 18.04 下，修改本地端口范围的方法：</p>
</div><div class="cl-preview-section"><pre><code>sudo sysctl -w net.ipv4.ip_local_port_range = 10000	60999
</code></pre>
</div><div class="cl-preview-section"><p>在 Windows10 下查看本地端口范围的方法：</p>
</div><div class="cl-preview-section"><pre><code>netsh int ipv4 show dynamicport tcp
netsh int ipv4 show dynamicport udp
netsh int ipv6 show dynamicport tcp
netsh int ipv6 show dynamicport udp
</code></pre>
</div><div class="cl-preview-section"><p>在 Windows10 下修改本地端口范围的方法：</p>
</div><div class="cl-preview-section"><pre><code>netsh int &lt;ipv4|ipv6&gt; set dynamic &lt;tcp|udp&gt; start=number num=range
</code></pre>
</div><div class="cl-preview-section"><p>Windows10 的具体示例：</p>
</div><div class="cl-preview-section"><pre><code>netsh int ipv4 set dynamicport tcp start=10000 num=1000
</code></pre>
</div><div class="cl-preview-section"><h3 id="connect-超时">connect 超时</h3>
</div><div class="cl-preview-section"><p>TCP 客户端调用 connect 函数会触发<strong>三次握手</strong>，当客户端发送 SYN 报文段以后，收不到服务器的 SYN + ACK 报文段，那么 TCP 会重传 SYN 报文段，采用的是<strong>指数退避</strong>（exponential backoff）策略，每一次超时重传等待的时间是前一次等待时间的 2 倍。重传的次数，一般采用 5 次或者 6 次，Ubuntu18.04 默认 6 次。</p>
</div><div class="cl-preview-section"><pre><code>ubuntu@10-9-50-2:~$ sudo sysctl -a |grep syn
net.ipv4.tcp_syn_retries = 6
net.ipv4.tcp_synack_retries = 5
</code></pre>
</div><div class="cl-preview-section"><p>这个实验很好做，打开浏览器访问一台 Linux 主机，但是没有启动 Web 服务，就可以重现。Linux 上抓包显示的重传过程：</p>
</div><div class="cl-preview-section"><pre><code>16:14:16.979206 IP 192.168.1.121.56878 &gt; 192.168.10.181.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">http</i>: Flags [S], seq 993432495, win 29200, options [mss 1460,sackOK,TS val 1427054 ecr 0,nop,wscale 7], length 0
16:14:17.977774 IP 192.168.1.121.56878 &gt; 192.168.10.181.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">http</i>: Flags [S], seq 993432495, win 29200, options [mss 1460,sackOK,TS val 1427304 ecr 0,nop,wscale 7], length 0
16:14:19.981726 IP 192.168.1.121.56878 &gt; 192.168.10.181.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">http</i>: Flags [S], seq 993432495, win 29200, options [mss 1460,sackOK,TS val 1427805 ecr 0,nop,wscale 7], length 0
16:14:23.993767 IP 192.168.1.121.56878 &gt; 192.168.10.181.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">http</i>: Flags [S], seq 993432495, win 29200, options [mss 1460,sackOK,TS val 1428808 ecr 0,nop,wscale 7], length 0
16:14:32.009767 IP 192.168.1.121.56878 &gt; 192.168.10.181.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">http</i>: Flags [S], seq 993432495, win 29200, options [mss 1460,sackOK,TS val 1430812 ecr 0,nop,wscale 7], length 0
16:14:48.025791 IP 192.168.1.121.56878 &gt; 192.168.10.181.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">http</i>: Flags [S], seq 993432495, win 29200, options [mss 1460,sackOK,TS val 1434816 ecr 0,nop,wscale 7], length 0
16:15:20.089775 IP 192.168.1.121.56878 &gt; 192.168.10.181.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">http</i>: Flags [S], seq 993432495, win 29200, options [mss 1460,sackOK,TS val 1442832 ecr 0,nop,wscale 7], length 0
</code></pre>
</div><div class="cl-preview-section"><p>从这个实验结果可以看出，SYN 报文段发送一次，重传了 6 次，每次重传的超时时间间隔分别是：1s、2s、4s、8s、16s、32s，总共需要 63s。</p>
</div><div class="cl-preview-section"><h3 id="send-函数">send() 函数</h3>
</div><div class="cl-preview-section"><p>send() 函数用于向对端发送数据，有时 send、sendto、write 可以交替使用，有兴趣可以参考相关文档，本文不会展开讲解。</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c">ssize_t <span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li>返回值如果是 -1，表示函数调用失败，失败的原因可以参考 errno 的值。如果 send() 调用成功，返回值表示本次发送的数据长度，单位是<strong>字节</strong>。我们经常需要在程序中处理错误码 EAGAIN，这是非阻塞 Socket 需要处理的逻辑；还有就是错误码 EINTR，比如在发送数据之前系统产生了中断，会返回 EINTR 错误码，此时还需继续调用 send() 函数去发送数据；</li>
<li>sockfd 表示 Socket 文件描述符；</li>
<li>buf 表示要发送的数据缓���区地址，由调用者提供；</li>
<li>len 表示要发送的数据长度；</li>
<li>flags 主要是一些标记用于对发送进行控制。比如 MSG_DONTWAIT、MSG_NOSIGNAL，不同标记通过<strong>按位或</strong>进行传递。</li>
</ul>
</div><div class="cl-preview-section"><h3 id="recv-函数">recv() 函数</h3>
</div><div class="cl-preview-section"><p>recv() 函数用于接收对方的数据。</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c">ssize_t <span class="token function">recv</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li>返回值如果是 -1，表示函数调用失败，失败的原因可以参考 errno 的值。返回值如果是 0，表示连接已经被对方关闭。返回值如果是大于 0，表示接收的数据长度，单位是字节。我们经常需要在程序中处理错误码 EAGAIN，这是非阻塞 Socket 需要处理的逻辑；还有就是错误码 EINTR，比如在接收数据之前系统产生了中断，会返回 EINTR 错误码，此时还需继续调用 recv() 函数去接收数据；</li>
<li>sockfd 表示 Socket 文件描述符；</li>
<li>buf 表示接收数据缓冲区地址，由调用者提供缓冲区，OS 协议栈会拷贝数据；</li>
<li>len 表示调用者提供的接收数据缓冲区的长度，OS 协议栈不会拷贝超过缓冲区长度的数据；</li>
<li>flags 主要是一些标记用于对接收进行控制。不同标记通过<strong>按位或</strong>进行传递。</li>
</ul>
</div><div class="cl-preview-section"><h3 id="bind-函数">bind() 函数</h3>
</div><div class="cl-preview-section"><p>当你调用 socket() 函数会创建一个 Socket 文件描述符，但是并没有和本地网络接口做绑定。如果是 Server 程序，必须调用 bind() 函数绑定一个本地地址。TCP 和 UDP 都可以调用 bind() 函数进行绑定。</p>
</div><div class="cl-preview-section"><p>绑定的 IP 地址可以是指定网卡的 IP 地址，也可以是通配符 IP 地址，比如 IPv4 的 0.0.0.0，IPv6 的 ::。如果绑定的是通配符地址，那么当你的服务器配置有多个网卡的时候，只要客户端访问了正确的监听端口号，从任意一个网卡入口的请求都可以被监听的服务监听到。一般来说，很少有服务器绑定固定 IP 地址，除非是安全需求。</p>
</div><div class="cl-preview-section"><p>如果绑定的端口号设置为 0，那么系统会从本地端口区间随机分配一个端口号，一般在内网分布式集群中会这样使用，避免手动配置端口号带来的麻烦。</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span>socklen_t addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li>返回值如果是 -1，表示函数调用失败，失败的原因可以参考 errno 的值；否则表示连接绑定成功；</li>
<li>sockfd 是<strong>文件描述符</strong>；</li>
<li>addr 表示服务器本地监听地址，真实地址结构应该是 struct sockaddr_in 或者 struct sockaddr_in6。包含了服务器监听的 IP 和 Port。IP 可以是通配符，比如 0.0.0.0 或者 :: ；</li>
<li>addrlen 表示真实地址结构长度。即 sizeof(struct sockaddr_in) 或者是 sizeof(struct sockaddr_in6)。</li>
</ul>
</div><div class="cl-preview-section"><h3 id="listen-函数">listen() 函数</h3>
</div><div class="cl-preview-section"><p>listen() 函数是实现被动打开，主要是用在 TCP 服务器 Socket 编程。</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li>返回值如果是 -1，表示函数调用失败，失败的原因可以参考 errno 的值；否则表示被动监听成功；</li>
<li>sockfd 是监听 Socket 的<strong>文件描述符</strong>；</li>
<li>backlog 表示 TCP 连接未完成队列（pending queue）的长度。如果并发访问的客户端导致连接未完成队列满，那么服务器会返回 ECONNREFUSED 的错误给客户端。</li>
</ul>
</div><div class="cl-preview-section"><p>listen 的基本工作原理如下图所示：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5ed9a674000180ab11270474.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>上图展示了 TCP 的三次握手过程，服务器中执行的逻辑用红色数字表示。<br>
TCP 的监听逻辑维护了两个队列：<strong>连接未完成队列</strong>和<strong>连接已完成队列</strong>。当服务器收到客户端的 SYN 报文段，会将此客户端加入到<strong>连接未完成队列</strong>，如标号 （1）所示；当收到客户端的 ACK，表示完成<strong>三次握手</strong>，如标号（2）所示；将此客户端从<strong>连接未完成队列</strong>移到<strong>连接已完成队列</strong>，如标号（3）所示，此时服务器应用程序的 accept 调用就会返回，新连接正式建立。</p>
</div><div class="cl-preview-section"><h3 id="accept-函数">accept() 函数</h3>
</div><div class="cl-preview-section"><p>accept() 函数用于接收新的客户端连接请求。</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token keyword">int</span> sockfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> sockaddr <span class="token operator">*</span>addr<span class="token punctuation">,</span> socklen_t <span class="token operator">*</span>addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li>返回值如果是 -1，表示函数调用失败，失败的原因可以参考 errno 的值；否则会返回新连接的 Socket 的 fd。</li>
<li>addr 表示客户端的 Socket 地址，由调用者提供地址的内存空间，由协议栈来填写具体的值。真实地址结构应该是 struct sockaddr_in 或者 struct sockaddr_in6。包含了客户端公网出口 IP 和 Port。还记得我们在链路层讲过的 NAT 工作原理吗？</li>
<li>addrlen 表示真实地址结构长度。即 sizeof(struct sockaddr_in) 或者是 sizeof(struct sockaddr_in6)。</li>
</ul>
</div><div class="cl-preview-section"><blockquote>
<p>提示：参数 addrlen 传入的是指针类型，调用者必须要用真实地址长度对 addrlen 进行初始化，否则函数调用会返回错误。</p>
</blockquote>
</div><div class="cl-preview-section"><h3 id="close-函数">close() 函数</h3>
</div><div class="cl-preview-section"><p>close() 函数用于关闭连接，其实包含两层含义：一是释放 Socket 文件描述符；二是关闭 TCP 连接。还记得执行主动关闭的一方最终会进入 2MSL 等待周期吗？可以说你调用完 close() 函数，文件描述符是马上释放了，但是底层 TCP 连接可能还没有立即关闭掉。</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token keyword">int</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li>返回值如果是 -1，表示函数调用失败，失败的原因可以参考 errno 的值；否则表示连接关闭成功；</li>
<li>fd 是要关闭的<strong>文件描述符</strong>。</li>
</ul>
</div><div class="cl-preview-section"><p>下来我们尝试进一步完善 nwchecker server 程序。</p>
</div><div class="cl-preview-section"><h2 id="nwchecker-支持多客户端">nwchecker 支持多客户端</h2>
</div><div class="cl-preview-section"><p>我们采用传统多进程的方式来支持多客户端的并发请求，基本思想是：主进程循环监听客户端的连接请求，当 accept() 调用成功返回以后，创建一个子进程来和对应的客户端进行数据通信；主进程回头再去监听新客户端的连接请求，这样就可以达到并发处理的目的。架构图如下：<br>
<img src="https://img.mukewang.com/5ed9a68100015c6809420693.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>从图中可以看出<strong>三次握手</strong>是在主进程中完成，当连接建立以后，主进程会 fork 一个子进程，数据通信是由子进程和客户端进程完成的。图中的绿色虚线是一条虚链路表示 TCP 连接。</p>
</div><div class="cl-preview-section"><p>在 03-11_最简单的TCP客户端服务器/nwchecker_server.c 文件增加了如下代码片段：</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token number">126</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token number">127</span>         client_addr_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">128</span>         client_sock_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> sockaddr<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> <span class="token punctuation">(</span>socklen_t<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_addr_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">129</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>client_sock_fd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token number">131</span>             <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token number">132</span>         <span class="token punctuation">}</span>
<span class="token number">138</span>
<span class="token number">139</span>         <span class="token keyword">struct</span> nwc_connection <span class="token operator">*</span>nwc <span class="token operator">=</span> <span class="token function">alloc_nwc_conn</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> client_sock_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">140</span>         nwc<span class="token operator">-&gt;</span>echo_mode <span class="token operator">=</span> echo_mode<span class="token punctuation">;</span>
<span class="token number">141</span>         nwc<span class="token operator">-&gt;</span>sleep_time <span class="token operator">=</span> sleep_time<span class="token punctuation">;</span>
<span class="token number">142</span>
<span class="token number">143</span>         pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">144</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token number">146</span>             <span class="token function">free_nwc_conn</span><span class="token punctuation">(</span>nwc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">147</span>             nwc <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token number">148</span>
<span class="token number">149</span>             <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token number">150</span>         <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token number">151</span>             <span class="token comment">// Child process</span>
<span class="token number">152</span>             <span class="token function">worker_process</span><span class="token punctuation">(</span>nwc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">153</span>         <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
<span class="token number">154</span>             <span class="token comment">// Parent process</span>
<span class="token number">155</span>             nwc<span class="token operator">-&gt;</span>pid <span class="token operator">=</span> pid<span class="token punctuation">;</span>
<span class="token number">156</span>             <span class="token function">close</span><span class="token punctuation">(</span>client_sock_fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">157</span>             <span class="token function">add_nwc_tail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>nwc_hdr<span class="token punctuation">,</span> nwc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">158</span>         <span class="token punctuation">}</span>
<span class="token number">159</span>     <span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>你可能已经发现代码片段的行号不连续，是因为我删除了打印 log 的代码，这样可以节省篇幅，但并不影响说明问题。代码片段说明：</p>
</div><div class="cl-preview-section"><ul>
<li>在 126 行增加了 while(1) 语句，让我们的服务能够循环监听客户端的连接请求，而不像老的实现只能接收一个客户端连接；</li>
<li>127 ~ 132 行是 accept() 函数调用，没有什么变化。</li>
</ul>
</div><div class="cl-preview-section"><blockquote>
<p>注意：127 行语句表明在调用 accept() 之前，对参数 client_addr_len 进行了初始化，这一步是非常关键的！</p>
</blockquote>
</div><div class="cl-preview-section"><ul>
<li>139 ~ 141 行构造了 struct nwc_connection 类型的一个对象，此类型代表一个新建的 TCP 连接，用于保存连接相关的参数。比如，fd、进程 pid、命令行选项参数等。</li>
<li>143 行是一个 fork() 函数调用。fork 的调用相对简单，函数原型以及所在的头文件如下代码片段：</li>
</ul>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
pid_t <span class="token function">fork</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p>调用 fork() 函数后，如果返回值不是 -1，那么系统会创建一个新的进程，我们把调用 fork 的进程叫做<strong>父进程</strong>，被创建的新进程叫做<strong>子进程</strong>。fork 函数调用完后，<strong>父进程</strong>和<strong>子进程</strong>都会返回。如果函数返回值是 0，表示子进程返回，此时可以执行子进程相关的逻辑；如果返回值大于 0，表示父进程返回，此时返回值是子进程的<strong>进程 ID</strong>(pid)；</p>
</div><div class="cl-preview-section"><p>子进程会复用父进程的资源，所以父进程调用 accept() 函数返回的 Socket fd，在子进程中直接可以使用。当然，子进程和父进程拥有独立的地址空间，完全是两个进程。</p>
</div><div class="cl-preview-section"><ul>
<li>
<p>144 ~ 149 行表示 fork 函数调用失败，我们继续执行监听；</p>
</li>
<li>
<p>150 ~ 152 行表示<strong>子进程</strong>返回，调用 worker_process() 函数，此函数会在子进程内执行，完成的主要逻辑是就是调用 recv() 函数和 send() 函数进行数据收发。函数的参数就是 struct nwc_connection 类型，用于传递连接上下文信息；</p>
</li>
<li>
<p>153 ~ 157 行表示<strong>父进程</strong>返回，我们把子进程的 pid 保存在 struct nwc_connection 结构中，然后将此连接增加到连接链表中。连接链表是一个双向链表，链表的表头是 nwc_hdr 变量，具体可以参考完整源码。</p>
</li>
</ul>
</div><div class="cl-preview-section"><blockquote>
<p>注意：我们说 fork 创建的子进程会复制父进程的资源，所以 accept() 调用返回的 fd，在父进程和子进程中各存在一份，所以我们要把父进程中的 fd 释放掉。</p>
</blockquote>
</div><div class="cl-preview-section"><p>此时你启动 nwchecker server 端，然后启动多个 nwchecker client 去连接 server，可以实现多客户端同时通信。</p>
</div><div class="cl-preview-section"><p>服务器一般都是不分昼夜后台运行的，怎样达到这样的效果呢？</p>
</div><div class="cl-preview-section"><h2 id="nwchecker-后台运行">nwchecker 后台运行</h2>
</div><div class="cl-preview-section"><p>我们到目前为止都是打开 linux 控制台直接输入命令启动服务的，比如：</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token punctuation">.</span><span class="token operator">/</span>nwc<span class="token punctuation">.</span>exe <span class="token operator">-</span>s <span class="token operator">-</span>p <span class="token number">9820</span>
</code></pre>
</div><div class="cl-preview-section"><p>当你关掉控制台，程序也会退出。如果在关闭控制台以后，我希望服务程序还能继续在后台运行，该如何实现呢？我们可以通过 linux 提供的 deamon() 函数来完成此目标。函数原型如下：</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">daemon</span><span class="token punctuation">(</span><span class="token keyword">int</span> nochdir<span class="token punctuation">,</span> <span class="token keyword">int</span> noclose<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li>返回值如果是 -1，表示函数调用失败，失败的原因可以参考 errno 的值；返回值是 0 表示函数调用成功；</li>
<li>nochdir 取值 0 表示修改进程的工作目录为系统根目录"/"，否则保持进程工作目录不变；</li>
<li>noclose 取值 0 表示将 stdin、stdout、stderr 重定向到 /dev/null，否则不对这些文件描述符做更改。</li>
</ul>
</div><div class="cl-preview-section"><p>在 03-11_最简单的TCP客户端服务器/nwchecker.c 文件增加了如下代码片段：</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token number">129</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">daemon</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token number">131</span>             <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">132</span>         <span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>代码��� 129 ~ 132 就是简单的 daemon() 函数调用，nochdir 和 noclose 两个参数都传入 0，表示要进行相应的更改。</p>
</div><div class="cl-preview-section"><h2 id="设置-so_reuseaddr-选项">设置 SO_REUSEADDR 选项</h2>
</div><div class="cl-preview-section"><p>现在回想一下 TCP 连接关闭过程中，主动关闭的一方会处于 TIME_WAIT 状态，要等待 2MSL 时间。</p>
</div><div class="cl-preview-section"><p>而服务器在工作过程中有可能由于配置的改变而要重启，或者是由于程序异常奔溃要重新启动。在这种情况下，如果服务器监听的 Socket 处于 TIME_WAIT 状态，那么调用 bind() 函数绑定 socket 就会失败。如果要等待 2MSL 时间，对于服务器来说是难以接受的。要想解决此问题，需要给监听 Socket 设置 SO_REUSEADDR 选项。</p>
</div><div class="cl-preview-section"><p>在 03-11_最简单的TCP客户端服务器/nwchecker_server.c 文件增加了如下代码片段：</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"> <span class="token number">94</span>     <span class="token keyword">int</span> enable <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token number">95</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">setsockopt</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>enable<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>enable<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token number">97</span>         <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token number">98</span>     <span class="token punctuation">}</span>

</code></pre>
</div><div class="cl-preview-section"><p>关于 setsockopt() 函数的用法以及相关 Socket 选项我们在后面专栏介绍。</p>
</div><div class="cl-preview-section"><blockquote>
<p>提示：SO_REUSEADDR 需要在调用 bind() 函数之前设置。</p>
</blockquote>
</div><div class="cl-preview-section"><h2 id="sigpipe-信号">SIGPIPE 信号</h2>
</div><div class="cl-preview-section"><p>如果 TCP 连接被关闭，当你再调用 send() 函数发送数据，系统会产生 SIGPIPE 信号导致程序退出。服务器是不能无故退出的，所以必须处理 SIGPIPE 信号，一般的做法是忽略此信号。如下代码片段：</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token function">signal</span><span class="token punctuation">(</span>SIGPIPE<span class="token punctuation">,</span> SIG_IGN<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p>信号是 linux 系统的一种系统中断通知机制，signal 函数的原型如下：</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>sighandler_t<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sighandler_t <span class="token function">signal</span><span class="token punctuation">(</span><span class="token keyword">int</span> signum<span class="token punctuation">,</span> sighandler_t handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p>信号是操作系统另一个主题，我们不展开讲解，有兴趣可以参考 linux 系统帮助。</p>
</div><div class="cl-preview-section"><h2 id="总结">总结</h2>
</div><div class="cl-preview-section"><p>本文我们重点是对 Socket 的七个 API 进行了详细的介绍，并且对 nwchecker server 进行了完善。一个 TCP server 至少要支持多客户端并发连接请求、能长期在后台运行、遇到故障以后能立即重启运行，同时需要处理由于 SIGPIPE 信号导致的程序异常退出。</p>
</div><div class="cl-preview-section"><p>我们通过 fork 子进程的方式来实现多客户端的并发支持，又引入了<strong>进程间通信</strong>的问题，然而我们并没有<strong>进程间通信</strong>的处理逻辑，因为这是操作系统非常大的一个主题，不是本专栏的重点。但是作为一个完善的服务器，必须要处理好进程间通信，所以建议你抽时间要学习一下这一块内容。</p>
</div><div class="cl-preview-section"><p>我们在 nwchecker server 中所采用的 fork 子进程方式是非常传统、古典的一种做法，在现代服务器中很少用了，但是对于学习来说是非常有价值的。我们在后面的专栏会进一步介绍现代服务器的具体做法。</p>
</div><div class="cl-preview-section"><p>关于信号处理也是操作系统非常重要的一个主题，希望你也能抽时间学习一下。</p>
</div><div class="cl-preview-section"><h2 id="思考时间">思考时间</h2>
</div><div class="cl-preview-section"><ol>
<li>
<p>我们引入了子进程以后，又带来了僵尸（defunct）进程的问题，该如何解决呢？（提示：需要父进程调用 wait() 函数）。</p>
</li>
<li>
<p>我们说 send() 函数调用可能导致系统产生 SIGPIPE 信号，除了通过文中所说的忽略 SIGPIPE 信号的方式，还有别的解决方案吗？</p>
</li>
</ol>
</div>
			
		</div>
	
	
	<div class="finish-learn">
		<p class="copyright">©版权归慕课网所有，未经许可不得转载</p>
		
		
		
		<div class="ad_pic">
			<img src="https://img3.mukewang.com/5ed9fca1000109e706700192.jpg">
		</div>
		
		
		
		
	</div>
	<div class="comment-con">
		<h4 class="title">
			精选留言
			
				<a href="javascript: void(0);" class="add-comment js-comment-click"><i class="imwap-xieliuyan"></i><span>写留言</span></a>
			
		</h4>
		
			<p class="bottom-text empty">暂无精选留言</p>
		
	</div>
	
	

	
		
	
	
	
		<div class="bottom-con">
			
			
				<div class="inner">
					
						<div class="price-con js-price-con">
							<span class="now">￥58.00</span>
						</div>
							
					
					
					<a class="gobuy js-gobuy" href="//m.imooc.com/account/login?backurl=//m.imooc.com/confirmorder?type=30&typeid=80">
					
						立即购买
					</a>  
				</div>
			
		</div>
	
	<div class="layer-catalog js-layer-catalog hide">
		<div class="layer-title clearfix">
			<div class="l">
				课程目录
			</div>
			
		</div>
		<div class="layer-wrap">
			<div class="js-catalog-container">
			</div>
		</div>
	</div>
	<div class="layer-comment">
		<div class="inner">
			<h5>
				<span class="btn l js-cancel-comment">取消</span>
				评论
				<span class="btn r js-send-comment">发送</span>
			</h5>
			<textarea id="comment-txt" maxlength="20000" placeholder="欢迎在这里发表留言，作者筛选后可公开显示"></textarea>
		</div>
	</div>


            </div>
        </div>
        
            
         
        
        
        
        




<script>
	// 设置字号大小及选中
	(function() {
			var fs = window.localStorage.getItem('font-size') || 'normal';
			var $c = document.querySelector('#middle>.content');
			var $points = document.querySelectorAll('.setting-box .point');
			try{
				// 抢读完了时 该元素不渲染 会有报错
				$c.className = 'content ' + fs;
				for(var i = 0; i < $points.length; i++) {
					if($points[i].className.indexOf(fs) > -1) {
						$points[i].className = $points[i].className + ' current';
					}
				}
			} catch(e) {}
			
	})();
</script>

<script type="text/javascript">
	window.onload = function() {
			zhuge.track('LearnCourse', {
					'Category': '专栏',
					'Name': '12 从头做起：实现最简单的 TCP 客户端和服务器',
					'CID': '2101',
					'Teacher': '陈子兴'
			});
	}
</script>

        
            <script type="text/javascript">
                var shareData = { 
                    title:  "12 从头做起：实现最简单的 TCP 客户端和服务器",
                    desc: "学好通用知识，提升技术竞争力",
                    imgUrl: 'https:https://img2.mukewang.com/5ed8c1c600015fc805400720.jpg',
                    otherImgUrl: 'https://img2.mukewang.com/5ed8c1c600015fc805400720.jpg',
                    text: '我正在参加@慕课网的课程，很不错哦！快来一起学习吧！',
                    // url: 'https://www.imooc.com' + window.location.pathname + window.location.search
                    url: 'https://m.imooc.com/read/80',
                    link: 'https://m.imooc.com/read/80'
                }
            </script>
            
        
        <div style="display:none;">
            <!-- 百度统计 -->
            <script>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?c92536284537e1806a07ef3e6873f2b3";
              var s = document.getElementsByTagName("script")[0];
              s.parentNode.insertBefore(hm, s);
            })();
            </script>

            <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
            </script>
        </div>
        
    <script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/zhugeio/init_f9752c3.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/jquery-2.1.0.min_ac9f840.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/common_84429c0.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/juicer/juicer.min_8643248.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/previewImage/previewImage.min_43b970d.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/msg_bed8d10.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/read/7.2.8/article_30e5762.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/course/advertisementReport_6e58a98.js"></script></body>
</html>
