<!doctype html>
<html lang="zh_CN">

    

    

    
    
    
    <head>
        
        <title>23 关于 SQL 查询语句，有什么好的建议吗？</title>
        
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="打包 MySQL 常用高级技巧特性">
        <meta name="keywords" content="慕课网">
        <meta name="author" content="">
        <meta name = "format-detection" content="telephone=no">
        <meta http-equiv="Cache-Control" content="no-transform " />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <link rel="shortcut icon" href="https://m.imooc.com/static/wap/static/favicon.ico" />
        
        
        
        <script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/flexible.js"></script>
        
        <script type="text/javascript">
            var userInfo = "";
            
                var isApp = 0;
            
        </script>
         
<!-- 专栏首页列表模板 -->
<script type="text/template" id="index-list-tpl">
<ul class="list-con">
    {@each data.data as item}
        <li>
            <a href="/read/${item.id}" class="item clearfix">
                <div class="img l" style="background-image: url(${item.app_pic1})">
                    {@if item.is_new }
                        <div class="icon new">
                            上新
                        </div>
                    {@else if item.is_marking} 
                        <div class="icon">
                            经典
                        </div>
                    {@/if} 
                </div>
                <div class="text-con l">
                    <div class="title">
                        ${item.title}
                    </div>
                    <div class="desc">
                        ${item.chapter_num}节 · ${item.description}
                    </div>
                     <div class="user-info">
                        ${item.nickname}
                        {@if item.author_title }
                        <span class="dot">
                            ·
                        </span>
                        ${item.author_title}
                        {@/if}
                    </div>
                    <div class="info clearfix">
                    {@if !item.isBuy } 
                        <!-- 未购买才显示 -->
                        <div class="price-con l">
                        {@if item.open_discount == "1" }
                            <span class="now">￥${item.pay_price}</span>
                            <span class="ori">￥${item.price}</span>
                            <p class="sale">${item.discount_name}</p>
                        {@else}
                            <span class="now">￥${item.price}</span>
                        {@/if}
                        </div>
                    {@/if}
                        <div class="taste-con r">
                            <span>${item.numbers}人订阅</span>
                            {@if !item.isBuy }
                                <span class="gotaste">试读</span>
                            {@else}
                                <span class="gotaste">学习</span>
                            {@/if}
                        </div>
                    </div>
                </div>
            </a>
        </li>
    {@/each}
</ul>
</script>



<!-- 专栏目录 买后目录页、 -->
<script type="text/template" id="detail-catalog-tpl">
<ul class="catalog-list">
{@each data.list as item}
    <li class="zhang">
        {@if data.structure_mode == "1" }
            <!--章节模式-->
            <div class="zhang-title">
                ${item.title}（${item.count}节）
            </div>
            <div class="zhang-sub-title">
                ${item.short_introduce}
            </div>
        {@/if}  
        <ul class="zhang-detail">
            {@each item.list as it,i}
                <li class="jie">
                    {@if data.isLogin }
                        <!-- 购买了  -->
                        {@if data.isBuy }
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read">
                        {@else}
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read" >
                        {@/if}
                    {@else}
                        <!-- 未登录  -->
                        {@if data.isApp }
                            <a href="javascript:;" onclick="window.nativeSupport.login();">
                        {@else}
                            <a href="//m.imooc.com/account/login?backurl=/read/${data.column_id}">
                        {@/if}
                    {@/if}
                        <div class="jie-con {@if data.last_chapter == it.id }recent{@/if}">
                            
                            <div class="text-con">
                                <div class="jie-title">
                                    ${it.title}
                                </div>
                                <div class="jie-status">
                                    {@if it.is_open == "0" }
                                        <span class="update-time" >${it.open_time_fmt}</span>
                                    {@/if}
                                    {@if it.view_num > 100 }
                                    <div class="learn-num">
                                        <i class="imwap-set-sns"></i>
                                        <span>${it.view_num}</span>
                                    </div>
                                    {@/if}
                                    {@if it.in_24hours == "1" }
                                        <span class="update-recent">最近更新</span>
                                    {@/if}
                                </div>
                            </div>
                        </div>
                        {@if it.is_learned }
                            <div class="jie-right haslearn is_learned js-learn" data-type="1">
                                已学
                            </div>
                        {@else}
                            <!-- 购买了  -->
                            {@if data.isBuy }
                                <div class="jie-right learn js-learn" data-type="1">
                                    学习
                                </div>
                            {@else}
                                {@if it.is_pay == "0" }
                                <!--免费小节 不占用试读次数  -->
                                    <div class="jie-right learn js-learn" data-type="1">
                                        免费
                                    </div>
                                {@else}
                                    <div class="jie-right learn js-learn" data-type="0">
                                        学习
                                    </div>
                                {@/if}
                            {@/if}
                            
                            
                        {@/if}
                    </a>
                </li>
            {@/each}
        </ul>
    </li>
{@/each}
</ul>
</script> 

<!-- 阅读页 阅读页   专栏目录  -->
<script type="text/template" id="catalog-tpl">
<div>
    <h2 class="article-title">${data.a_name}</h2>
    <ul class="catalog">
    {@each data.list as item}
        <li class="zhang">
            {@if data.structure_mode == "1" }
                <!--章节模式-->
                <div class="zhang-title">
                    ${item.title}
                    <!-- <div class="num">共${item.count}节</div> -->
                </div>
            {@/if}  
            <ul class="zhang-detail">
                {@each item.list as it,i}
                    <li class="jie">
                        <!--买了且开放的-->
                        <a href="/read/${data.column_id}/article/${it.id}">
                            <div class="jie-title clearfix full">
                                <p>
                                    {@if data.last_chapter == it.id }
                                        <span class="recent">最近阅读</span>
                                    {@/if}
                                    ${it.title}
                                </p>
                            </div>
                        </a>
                    </li>
                {@/each}
            </ul>
        </li>
    {@/each}
    </ul>
</div>
</script>





<script type="text/javascript">
	var isApp = "";
	var clientVersion = "0";
	var count_num = "1";
	var chapter_id = "1843";
	var chapter_title = "23 关于 SQL 查询语句，有什么好的建议吗？";
	var aid = "71";
	var a_name = "实战派 MySQL 高阶应用指南";
	var a_price = "68.00";
	var a_pic = "https://img.mukewang.com/5e65bd6e0001444005400720.jpg";
	var userId = 0;

	var column_id = '71';
	var isLogin = 0;
	

</script>
<!-- 引入字体 -->
<script type="text/javascript" src="//cdn.webfont.youziku.com/wwwroot/js/wf/youziku.api.min.js"></script>
<script type="text/javascript">
$youziku.load(".top-con .title, .cl-preview-section h1,.cl-preview-section h2,.cl-preview-section h3,.cl-preview-section h4,.cl-preview-section h5,.cl-preview-section h6", "37af461390fa4d138f5c3d277f7286dc", "SourceHanSerifSC-Heavy"); // 思源宋体heavy
$youziku.load(".lead-motto, .cl-preview-section blockquote", "d9a0d855583142c3b2cc3bf1646a8473", "SourceHanSerifSC-Regular"); // 思源宋体regular
$youziku.load("#article_content, .cl-preview-section pre, .cl-preview-section code, #code-copy", "3d84aabcf9e44b6f8c6fa91c61fa926e", "HYQiHei-55S"); // 汉仪旗黑55s
$youziku.load(".cl-preview-section strong", "fd94fff3a17546a28913a79613bddcec", "HYQiHei-77S"); // 汉仪旗黑70s

$youziku.draw();
</script>

<style type="text/css">
  header{
    display: none!important;
  }
  
  #wrapper{
  	padding-top:0px !important;
  }
  
</style>



    <link rel="stylesheet" href="https://m.imooc.com/static/wap/static/common/css/common_d42b1ef.css" /><link rel="stylesheet" href="https://m.imooc.com/static/wap/static/css/read/7.2.8/article_2d28313.css" /></head>
    <body >
        
          
        

        
          
        

        
          







<header class="directory2">
	<div class="header clearfix">
		
			
				<div class="page-title clearfix">
					<a href="//m.imooc.com" class="imwap-icon-imooc"></a>
					<div class="page-title-name js-page-name">
						<span>专栏</span>
						<i class="imwap-arrow_d"></i>
					</div>
				</div>
			

			
			<div class="drawer-box js-drawer-more">
				<i class="imwap-more_vert"></i>
				<div class="drawer-content js-drawer-content">
					<p class="line-row"></p>
					<a class="drawer-item" href="//m.imooc.com"><i class="imwap-center"></i>回到首页</a>
					<a class="drawer-item" href="//www.imooc.com/m/web/user/usercenter.html"><i class="imwap-peaple"></i>个人中心</a>
					<a class="drawer-item" href="//m.imooc.com/feedback"><i class="imwap-comment"></i>反馈问题</a>
					
					<a class="drawer-item" href="//m.imooc.com/account/login"><i class="imwap-out"></i>注册登录</a>
					
				</div>
			</div>
			

			
				<a id="js-appload" href="Javascript:;" class="app-load"><span>下载APP</span></a>
			

		
	</div>
	
	<div class="page-tab-wrap">
		<div class="page-tab-list">
			<a href="//m.imooc.com" class="page-tab-item">首页</a>
			<a href="//m.imooc.com/course/list" class="page-tab-item">课程</a>
			<a href="//coding.m.imooc.com" class="page-tab-item">实战</a>
			<a href="//class.m.imooc.com" class="page-tab-item">金职位</a>
			<a href="//m.imooc.com/article" class="page-tab-item">手记</a>
			<a href="//m.imooc.com/read" class="page-tab-item active">专栏</a>
			<a href="//m.imooc.com/wenda" class="page-tab-item">猿问</a>
			<a href="//m.imooc.com/wiki" class="page-tab-item">慕课教程</a>
			
		</div>
	</div>
	
</header>


        

        <div id="wrapper">
            <div id="middle" class="container ">

                

                
	
		
	
	<div class="top-con">
		<p class="update-time"><span>2020-05-11&nbsp;&nbsp;&nbsp;更新</span></p>
		<div class="title">
			23 关于 SQL 查询语句，有什么好的建议吗？
		</div>
	</div>
	
		<div class="article-img" style="background-image: url('https://img.mukewang.com/5ea184000001139406400359.jpg')"></div>
	
	
		<a href="/read/71">
			<div class="course-entry">
				<img src="https://img4.mukewang.com/5c36c432000158e609600960-40-40.jpg" alt="勤一">
				<h3>实战派 MySQL 高阶应用指南</h3>
				<p>勤一 · BAT 高级研发工程师</p>
				<i class="imwap-arrow_r"></i>
			</div>
		</a>
	
	
		<div class="lead-motto">
			<div class="content">人的影响短暂而微弱，书的影响则广泛而深远。<p class="author">——普希金</p></div>
		</div>
	
	
		<div class="content" id="article_content">
			
			<div class="cl-preview-section"><p>对于 SQL 查询来说，查询的方式、列值的顺序、索引的定义等等都有可能会影响到查询效率。当然，我们同样不能忽视数据表的定义，毕竟数据表是查询的源头。这一节里，我会结合工作经验对 SQL 语句的编写、数据表的定义给出建议，旨在提高你的 SQL 编写能力，提升工作效率。</p>
</div><div class="cl-preview-section"><h2 id="建表时需要考虑的优化策略">1. 建表时需要考虑的优化策略</h2>
</div><div class="cl-preview-section"><p>创建数据表是迈入 SQL 查询的第一步，它的重要性自然不言而喻。除了对业务需求的分析之外，理解 MySQL 的特性也是必备的技能。下面，我将结合我在开发、学习中遇到的问题、经验来谈一谈关于建表的优化策略。</p>
</div><div class="cl-preview-section"><h3 id="enum-也许会比-charvarchar-更好">1.1 ENUM 也许会比 CHAR/VARCHAR 更好</h3>
</div><div class="cl-preview-section"><p>MySQL 中的 ENUM 类型是一个热点话题，且大多数时候它都是被排斥的对象。其主要原因是更改 ENUM 类型的字段，代价是十分昂贵的。例如，我们把 ENUM(‘a’, ‘b’, ‘c’) 修改为 ENUM(‘a’, ‘b’, ‘d’)，MySQL 就需要重构整个数据表，并且在数据池中查找无效值 c。可想而知，如果枚举值可能会出现变化，ENUM 类型肯定是不合适的。</p>
</div><div class="cl-preview-section"><p>但是，仍然不可否认，ENUM 类型的速度是非常快的，因为 MySQL 实际上会使用 TINYINT 保存数据，字符串只是它的外衣。所以，当你能够确定枚举值是固定、不会发生变化的，ENUM 类型会比 CHAR/VARCHAR 好很多。</p>
</div><div class="cl-preview-section"><h3 id="保证列值是-not-null-的">1.2 保证列值是 NOT NULL 的</h3>
</div><div class="cl-preview-section"><p>首先来说，为什么很多人会把列值设置为允许 NULL 呢 ？主要有两点原因：</p>
</div><div class="cl-preview-section"><ul>
<li>数据表列默认就是 NULL 的，对于初级或者经验不足的同学没有显示指定 NOT NULL</li>
<li>NULL 列在插入时不需要指定数据，也不需要判断，比较方便简约</li>
</ul>
</div><div class="cl-preview-section"><p>但是，为什么又需要保证列值是 NOT NULL 的呢 ？来看一看 MySQL 官方文档怎么说吧：</p>
</div><div class="cl-preview-section"><blockquote>
<p>NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.</p>
</blockquote>
</div><div class="cl-preview-section"><p>它的意思是说：NULL 列需要额外的存储空间，且 MySQL 内部需要做特殊的处理。MySQL 难以优化 NULL 列的查询，它会使索引、索引统计更���复杂。特别是对于 MyISAM 存储引擎的表，它可能会导致固定大小的索引变成可变大小的索引。</p>
</div><div class="cl-preview-section"><h3 id="ip-地址存成-unsigned-int">1.3 IP 地址存成 UNSIGNED INT</h3>
</div><div class="cl-preview-section"><p>相信你一定知道，IP 地址可以与整型互转，且 MySQL 也提供了这样的函数。如下所示：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> INET_ATON<span class="token punctuation">(</span><span class="token string">'10.0.5.9'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">-----------------------+</span>
<span class="token operator">|</span> INET_ATON<span class="token punctuation">(</span><span class="token string">'10.0.5.9'</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-----------------------+</span>
<span class="token operator">|</span>             <span class="token number">167773449</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-----------------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> INET_NTOA<span class="token punctuation">(</span><span class="token number">167773449</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----------------------+</span>
<span class="token operator">|</span> INET_NTOA<span class="token punctuation">(</span><span class="token number">167773449</span><span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------------------+</span>
<span class="token operator">|</span> <span class="token number">10.0</span><span class="token punctuation">.</span><span class="token number">5.9</span>             <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------------------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>既然这样，就一定不要去使用 CHAR 或者 VARCHAR 去存储 IP 地址，因为这至少需要15个字节。如果用 INT（UNSIGNED），则只需要4个字节，且这是一个定长的（IP 地址根据网段的不同，不一定是定长的）字段，查询上也更具有优势。</p>
</div><div class="cl-preview-section"><h3 id="选择适当的索引字段，避免过度索引">1.4 选择适当的索引字段，避免过度索引</h3>
</div><div class="cl-preview-section"><p>索引字段的选择一定要去结合业务需求，找到或者预测会作为查询条件且比较频繁的字段，并在这些字段上建立索引、联合索引等等。但是，不应该在 NULL 列或者 “大的” 数据列上创建索引。</p>
</div><div class="cl-preview-section"><p>虽然索引能加速查询过程，但是，是不是说索引越多越好呢 ？当然不是：每一个索引都会占据额外的存储空间，且会降低 INSERT 和 UPDATE 的效率，因为每一次数据更新都可能导致索引的重建。所以，索引不要创建太多，不能过度，通常单表不应该超过5个。否则，就应该思考下这张表设计的合理性。</p>
</div><div class="cl-preview-section"><h3 id="比较少见的固定长度表">1.5 比较少见的固定长度表</h3>
</div><div class="cl-preview-section"><p>对于 MySQL 来说，如果一张表的所有列长度都是固定的，即表中不存在 VARCHAR、TEXT 这样的列。那么，这个表就被称为是 Static 或 Fixed-Length 表。这样的表肯定是比较少见的，MySQL 的存储引擎也会针对它做一些优化。</p>
</div><div class="cl-preview-section"><p>Static 表最大的特点就是它的每一行数据记录都是固定长度的，所以，计算下一行数据的偏移量是非常简单的。由此，读取行记录的速度也是更快的。但是，它也会有一定的副作用：不论你用不用，MySQL 总是会分配那么多空间。</p>
</div><div class="cl-preview-section"><h3 id="的表都应该是数字主键">1.6 99% 的表都应该是数字主键</h3>
</div><div class="cl-preview-section"><p>你几乎（报表可以不定义）需要给每张表都定义主键，因为 MySQL 的存储引擎在很多情况下都需要依赖主键，例如：存储、分区等等。且主键可以唯一的确定一行记录，也减轻了数据查询的负担。</p>
</div><div class="cl-preview-section"><p>同时，这个主键应该是数字类型（int 或 bigint），而不是其他的类型，且给上 AUTO_INCREMENT 自增标识。这是因为：</p>
</div><div class="cl-preview-section"><ul>
<li>对于自增主键，每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置</li>
<li>对于非自增主键，每次插入的主键值近似随机，因此每次新纪录都要被插到现有索引页的中间某个位置，此时 MySQL 不得不为了将新记录插到合适位置而移动数据（造成节点的分裂和重组）</li>
</ul>
</div><div class="cl-preview-section"><h3 id="使用更小的数据类型">1.7 使用更小的数据类型</h3>
</div><div class="cl-preview-section"><p>毫无疑问，MySQL 的磁盘存储是造成 IO 瓶颈的 “罪魁祸首”。所以，选择足够用且更小的数据类型是非常有必要的。它会带来两个主要的优点：</p>
</div><div class="cl-preview-section"><ul>
<li>数据记录占用的存储空间更少</li>
<li>可以将更多的数据读入内存，提升检索性能</li>
</ul>
</div><div class="cl-preview-section"><p>一个比较经典的案例是地域字典表，它用于存储省和市。此时，主键就不需要使用 INT 或 BIGINT 了，而是应该选择 SMALLINT。</p>
</div><div class="cl-preview-section"><h3 id="字符集编码需要统一">1.8 字符集编码需要统一</h3>
</div><div class="cl-preview-section"><p>对于使用 MySQL 经验不足的同学来说，大概率会遇到中文乱码的问题：明明大家存储的都是中文，在别人的电脑上能正确显示，但是，在我的机器上却显示乱码。这其实就是字符集编码的问题了。</p>
</div><div class="cl-preview-section"><p>这里，我给出一条通用建议：操作系统、服务器、客户端、库、表等等，所有你能想到的会与 MySQL 产生交集的地方，都设置成一样的字符集编码，例如：UTF-8。</p>
</div><div class="cl-preview-section"><h2 id="查询时需要考虑的优化策略">2. 查询时需要考虑的优化策略</h2>
</div><div class="cl-preview-section"><p>关于 SQL 查询，我们一定见识过相同功能但是写法不同的 SQL 语句，查询性能会差距很大。对于经验不足或者犯错次数过少的同学来说，写出性能低下的 SQL 查询再正常不过了。虽然能够完成查询需求，但是严重的情况下会影响到整个系统的性能。接下来，我也将结合我在开发、学习中遇到的问题、经验来谈一谈关于查询的优化策略。</p>
</div><div class="cl-preview-section"><h3 id="尽量避免在-sql-中出现函数">2.1 尽量避免在 SQL 中出现函数</h3>
</div><div class="cl-preview-section"><p>MySQL 提供了很多功能强大的函数，例如：数学运算、时间计算、字符串拼接等等。但是，我并不建议在 SQL 查询中对列值进行函数计算。主要是基于两点原因：</p>
</div><div class="cl-preview-section"><ul>
<li>函数计算会导致 SQL 执行速度变慢，增加访问延迟</li>
<li>函数计算会消耗更多的 MySQL 资源（CPU 和内存），导致其他客户端饥饿</li>
</ul>
</div><div class="cl-preview-section"><p>另外，一个 MySQL 服务可能会被很多产品线使用，更不应该去 “过度消费” 共享资源。如果确实需要对列值做处理计算，把它放到代码中去，我们也可以更加灵活的控制处理过程。</p>
</div><div class="cl-preview-section"><h3 id="慎用-in-和-not-in">2.2 慎用 IN 和 NOT IN</h3>
</div><div class="cl-preview-section"><p>即使你在某一列上加了索引，如果使用不恰当的方式查询，仍然会导致全表扫描。先看看下面两个查询语句：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> salary <span class="token keyword">FROM</span> worker <span class="token keyword">WHERE</span> salary <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> salary <span class="token keyword">FROM</span> worker <span class="token keyword">WHERE</span> salary <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p>由于 IN 和 NOT IN 中定义的值是不确定的，所以，MySQL 不会对上述的两个查询使用索引。这里可以做的优化是，对于连续的数值，我们可以使用 BETWEEN 来代替 IN。由于 BETWEEN 定义的是一个连续的区间，所以，可以使用到索引。如下所示：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> salary <span class="token keyword">FROM</span> worker <span class="token keyword">WHERE</span> salary <span class="token operator">BETWEEN</span> <span class="token number">1</span> <span class="token operator">AND</span> <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><h3 id="禁用-order-by-rand">2.3 禁用 ORDER BY RAND()</h3>
</div><div class="cl-preview-section"><p>“随机” 是很常见的需求，连 MySQL 也预料到了这一点，所以，它提供了 <code>ORDER BY RAND()</code>。可以看看下面的两个例子：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> worker <span class="token keyword">LIMIT</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+------+------+--------+---------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> name <span class="token operator">|</span> salary <span class="token operator">|</span> version <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+--------+---------+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> A    <span class="token operator">|</span> tom  <span class="token operator">|</span>   <span class="token number">1800</span> <span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">2</span> <span class="token operator">|</span> B    <span class="token operator">|</span> jack <span class="token operator">|</span>   <span class="token number">2100</span> <span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">3</span> <span class="token operator">|</span> C    <span class="token operator">|</span> pony <span class="token operator">|</span>   <span class="token boolean">NULL</span> <span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+--------+---------+</span>
<span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> worker <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> RAND<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">LIMIT</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+------+--------+--------+---------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> name   <span class="token operator">|</span> salary <span class="token operator">|</span> version <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+--------+--------+---------+</span>
<span class="token operator">|</span> <span class="token number">10</span> <span class="token operator">|</span> C    <span class="token operator">|</span> jarvis <span class="token operator">|</span>   <span class="token number">1800</span> <span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">6</span> <span class="token operator">|</span> C    <span class="token operator">|</span> tack   <span class="token operator">|</span>   <span class="token number">1200</span> <span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> B    <span class="token operator">|</span> tony   <span class="token operator">|</span>   <span class="token number">3600</span> <span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+--------+--------+---------+</span>
<span class="token number">3</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.02</span> sec<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>很明显，<code>ORDER BY RAND()</code> 打乱了返回数据。但是，为什么这种随机操作不放在代码中去完成呢 ？MySQL 不得不去执行 <code>RAND</code> 函数，且需要对数据记录进行排序，这会使数据库的性能呈指数级下降。</p>
</div><div class="cl-preview-section"><h3 id="功能强大的-limit">2.4 功能强大的 LIMIT</h3>
</div><div class="cl-preview-section"><p>我们的日常工作中，使用 <code>LIMIT</code> 关键字的频率还是非常高的。确实，这是一个非常重要的优化，当我们不需要返回 “很多” 数据时，加上 <code>LIMIT</code> 限定关键字，数据库引擎将会在找到所需的数据记录之后停止检索，而不是继续执行任务。</p>
</div><div class="cl-preview-section"><p>可是，你知道吗 ？<code>LIMIT</code> 还能避免误删除数据记录：当你能够确定所要删除的数据记录数时，在 <code>DELETE</code> 后面加上 <code>LIMIT</code> 吧。例如：我想要删除 worker 表中的三条记录，可以这样写：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> worker <span class="token keyword">LIMIT</span> <span class="token number">3</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">3</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.06</span> sec<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><h3 id="尽量避免在-where-子句中对字段进行表达式操作">2.5 尽量避免在 WHERE 子句中对字段进行表达式操作</h3>
</div><div class="cl-preview-section"><p>虽然 SQL 支持我们做表达式计算，但是，这将会导致优化器引擎放弃使用索引，转而去进行全表的扫描，严重降低服务器性能。就比如下面这个例子：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token comment">-- 假设我们给 salary 创建了索引</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> worker <span class="token keyword">WHERE</span> salary <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">4000</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+------+-------+--------+---------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> name  <span class="token operator">|</span> salary <span class="token operator">|</span> version <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+-------+--------+---------+</span>
<span class="token operator">|</span>  <span class="token number">8</span> <span class="token operator">|</span> B    <span class="token operator">|</span> clock <span class="token operator">|</span>   <span class="token number">2000</span> <span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+-------+--------+---------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>其实，完全可以把表达式计算 “调换” 过来，即 <code>WHERE salary = 4000 / 2</code>。此时，SQL 优化器将会使用到索引进行检索。</p>
</div><div class="cl-preview-section"><h3 id="尽量避免在-where-子句中对字段进行函数操作">2.6 尽量避免在 WHERE 子句中对字段进行函数操作</h3>
</div><div class="cl-preview-section"><p>其实这和上面的一条建议非常类似，在 WHERE 子句中对字段进行函数操作，即使是所在字段创建了索引，优化器也将 “视而不见”，直接进行全表的扫描。举个例子：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token comment">-- 假设我们给 name 创建了索引</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> worker <span class="token keyword">WHERE</span> SUBSTRING<span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">'to'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+------+------+--------+---------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> name <span class="token operator">|</span> salary <span class="token operator">|</span> version <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+--------+---------+</span>
<span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> B    <span class="token operator">|</span> tony <span class="token operator">|</span>   <span class="token number">3600</span> <span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+--------+---------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>由于对 name 字段加上了 <code>SUBSTRING</code> 函数，导致列值的不确定性（这是不能使用索引的原因），所以，SQL 将不会使用索引。不过，我们可以想办法修改下这个查询：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token comment">-- 由于至少知道 name 的前两个字节是 “to”，所以，可以使用索引检索</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> worker <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">'to%'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+------+------+--------+---------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> name <span class="token operator">|</span> salary <span class="token operator">|</span> version <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+--------+---------+</span>
<span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> B    <span class="token operator">|</span> tony <span class="token operator">|</span>   <span class="token number">3600</span> <span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+--------+---------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.01</span> sec<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><h3 id="尽量避免在-where-子句中判断不等于">2.7 尽量避免在 WHERE 子句中判断不等于</h3>
</div><div class="cl-preview-section"><p>“不等于” 在 SQL 中是 “非” 的语义，这同样是很难使用到索引的，毕竟索引是有序存储来达到快速匹配 “是” 的语义。所以，如果检索的数据量不大，最好的做法是在代码中进行过滤操作。</p>
</div><div class="cl-preview-section"><p>最后，来做一个总结：不要在 WHERE 子句中对字段值进行函数、算数运算或其他的表达式计算，这将会使列值处于不确定性的状态，SQL 优化器大概率不能使用到索引去优化查询。</p>
</div><div class="cl-preview-section"><h3 id="group-by-考虑禁止排序">2.8 GROUP BY 考虑禁止排序</h3>
</div><div class="cl-preview-section"><p>我们几乎都知道，<code>GROUP BY</code> 的性能是比较低的，特别是对于比较大的数据记录或无法使用索引时（想要使用索引，必须满足 <code>GROUP BY</code> 的字段同时存放于同一个索引中，且该索引是一个有序索引），需要通过临时表来完成操作。</p>
</div><div class="cl-preview-section"><p>但是，<code>GROUP BY</code> 还有一个特性很容易被忽略：默认情况下，MySQL 会按照 <code>GROUP BY</code> 所指定的字段进行排序，不论你有没有指定 <code>ORDER BY</code>。如果我们的查询需要 <code>GROUP BY</code>，但是，你又想避免排序带来的性能损耗，可以这样：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token comment">-- 显示指定 ORDER BY NULL 禁止排序</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> version<span class="token punctuation">,</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span> <span class="token keyword">FROM</span> worker <span class="token keyword">GROUP</span> <span class="token keyword">BY</span> version <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------+----------------+</span>
<span class="token operator">|</span> version <span class="token operator">|</span> <span class="token function">COUNT</span><span class="token punctuation">(</span>version<span class="token punctuation">)</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+----------------+</span>
<span class="token operator">|</span>       <span class="token number">0</span> <span class="token operator">|</span>              <span class="token number">7</span> <span class="token operator">|</span>
<span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span>              <span class="token number">1</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------+----------------+</span>
<span class="token number">2</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><h3 id="避免出现大事务">2.9 避免出现大事务</h3>
</div><div class="cl-preview-section"><p>对 “大事务” 的定义其实是比较模糊的，我们通常认为运行时间比较长，操作数据比较多的事务就是大事务。大事务主要会造成两个问题：</p>
</div><div class="cl-preview-section"><ul>
<li>锁定太多的数据，造成大量的阻塞和锁超时，严重影响数据库性能</li>
<li>执行时间过长，延迟较大，容易造成主从延迟</li>
</ul>
</div><div class="cl-preview-section"><p>所以，更好的做法是将大事务进行拆分，把单个复杂的 SQL 拆分为多个小的 SQL。同时，简单较小的 SQL 更容易利用到 MySQL 的查询缓存。</p>
</div><div class="cl-preview-section"><h3 id="合理的分页非常重要">2.10 合理的分页非常重要</h3>
</div><div class="cl-preview-section"><p>将表中的所有数据（或者根据一定的条件筛选出的数据）一次性返回给前端是很傻的做法，由此产生了分页的思想。通常，分页包含三个部分：总数、上一页和下一页，查询语句可能会像这样：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token comment">-- 查询 worker 表总记录数</span>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> worker<span class="token punctuation">;</span>
<span class="token comment">-- 查询分页数据</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> worker <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> worker <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p>这种实现方式当然是可以的，但是，对于分页查询来说，越往后执行的时间会越长。因为对于 <code>LIMIT M, N</code> 的写法，MySQL 总是会去扫描 M + N 条数据来得到你想要的数据，慢的原因也就是大量的数据扫描。此时，我们可以换一种方式来实现：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> worker<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> worker <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id <span class="token keyword">DESC</span> <span class="token keyword">LIMIT</span> <span class="token number">10000</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> worker_ <span class="token keyword">WHERE</span> worker<span class="token punctuation">.</span>id <span class="token operator">=</span> worker_<span class="token punctuation">.</span>id<span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p>先去查询分页中需要数据的主键 id，之后再根据主键 id 去查询你所需要的数据信息，这个查询数据的过程是依赖主键索引完成的，所以，效率提升非常明显。</p>
</div><div class="cl-preview-section"><h3 id="小心使用-like">2.11 小心使用 LIKE</h3>
</div><div class="cl-preview-section"><p><code>LIKE</code> 关键字实现的是模糊查询的功能，同样，你应该少用这个关键字。特别是下面这种情况：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token comment">-- 注意：% 放在前面</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> worker <span class="token keyword">WHERE</span> name <span class="token operator">LIKE</span> <span class="token string">'%ah'</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p>由于无法确定前缀，优化器不能使用索引，导致全表扫描。如果确实需要类似的查询，应该是预估可能的前缀，再对结果集做筛选。</p>
</div><div class="cl-preview-section"><h3 id="少用-select-…-for-update">2.12 少用 SELECT … FOR UPDATE</h3>
</div><div class="cl-preview-section"><p><code>FOR UPDATE</code> 由 InnoDB 存储引擎提供，且必须在事务块（BEGIN/COMMIT）中才能生效。通过 <code>FOR UPDATE</code> 语句，MySQL 会对查询结果集中每行数据都添加排他锁，其他线程对该记录的更新与删除操作都会阻塞。用法如下：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> worker <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">10</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p>但是，需要注意，使用 <code>FOR UPDATE</code> 必须确保字段存在索引，否则，行锁将会上升为表锁。很多情况下的死锁都是由 <code>FOR UPDATE</code> 造成。所以，除非必要，不要使用 <code>SELECT … FOR UPDATE</code>。</p>
</div><div class="cl-preview-section"><h2 id="常见问题的思考">3. 常见问题的思考</h2>
</div><div class="cl-preview-section"><p>很多时候，我们只是听到建议说：“不要这样用”、“这样写效率很低” 等等类似的话。但是，为什么这样不好的答案却鲜有人能说得出来。这里，我将举例说明一些常见的问题，解释说明它们为什么好、又为什么不好，其目的是要知其然也知其所以然。</p>
</div><div class="cl-preview-section"><h3 id="select--会降低查询速度，你知道吗-？">3.1 SELECT * 会降低查询速度，你知道吗 ？</h3>
</div><div class="cl-preview-section"><p>关于这个问题，我以 worker(id, type, name, salary, version) 表来举例说明。除了主键（聚簇）索引之外，我还给 name 列加上了一个普通索引。此时，对于 worker 表来说，它包含两棵 B+ 树：</p>
</div><div class="cl-preview-section"><ul>
<li>聚簇索引：是由 MySQL 根据主键自动生成的，保存的数据是 (id, type, name, salary, version)</li>
<li>辅助索引：自行定义的 name 列索引，保存的数据是 (name, id)</li>
</ul>
</div><div class="cl-preview-section"><p>如果我们的查询条件（WHERE 子句）可以通过 name 来过滤，查询优化器就会选择辅助索引。且如果我们只是 <code>SELECT id, name</code>，则查询会直接返回，也就是使用到了覆盖索引。但是，如果是直接 <code>SELECT *</code>，就不得不再去查询一次聚簇索引，速度肯定会慢很多。</p>
</div><div class="cl-preview-section"><p>由于辅助索引通常都会比较小，所以，MySQL 会把它载入内存中（有可能会是这样）。如果通过覆盖索引满足要求，就不需要再去读磁盘（聚簇索引在磁盘上），性能上肯定是有大幅提升的。而对于我们的业务来说，能使用到一张表所有字段的场景是比较少的，所以，更应该去设置合理的索引，而不要使用 <code>SELECT *</code>。</p>
</div><div class="cl-preview-section"><h3 id="你知道哪些情况会让查询缓存失效吗-？">3.2 你知道哪些情况会让查询缓存失效吗 ？</h3>
</div><div class="cl-preview-section"><p>在解析器解析一个 SQL 查询之前，如果查询缓存是打开的，MySQL 会优先检查这个查询是否会命中查询缓存中的数据。如果查询恰好命中查询缓存，则直接从缓存中拿到数据返回给客户端（当然，还会校验用户权限的问题）。这种情况下，查询不会被解析、生成执行计划及执行。所以，查询性能会大幅提升。</p>
</div><div class="cl-preview-section"><p>默认情况下，查询缓存是关闭的，它所对应的 MySQL 变量是 query_cache_type（默认值是 OFF）。我们需要修改配置文件以打开查询缓存，修改 my.cnf（需要重启 MySQL 服务）：</p>
</div><div class="cl-preview-section"><pre class="  language-bash"><code class="prism  language-bash"><span class="token comment"># 打开查询缓存</span>
query_cache_type <span class="token operator">=</span> ON
</code></pre>
</div><div class="cl-preview-section"><p>验证查询缓存已经打开，可以查看 query_cache_type 变量的值，如下所示。</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'query_cache_type'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">------------------+-------+</span>
<span class="token operator">|</span> Variable_name    <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------------+-------+</span>
<span class="token operator">|</span> query_cache_type <span class="token operator">|</span> <span class="token keyword">ON</span>    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------------+-------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>对于我们的线上服务来说，查询缓存大多都是打开的，这是提高查询性能最有效的方法之一。但是，需要注意，某些查询方式会导致 MySQL 不使用查询缓存，总结如下：</p>
</div><div class="cl-preview-section"><ul>
<li>查询缓存的内容是 <code>SELECT</code> 的结果集，缓存会使用完整的 SQL 字符串作为 KEY，且区分大小写和空格。所以，只有完全一致的 SQL 才可能会命中缓存</li>
<li>Prepared Statements 几乎不会命中查询缓存，即使参数完全一样</li>
<li><code>WHERE</code> 子句中如果包含任何一个不确定的函数，将永远不会命中缓存。最经典的示例是时间函数，如下的 SQL 将不会被缓存：</li>
</ul>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token comment">-- 由于 CURDATE 返回值是不确定的，所以，这条查询结果不会被缓存</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> daily_creative_stat <span class="token keyword">WHERE</span> <span class="token keyword">date</span> <span class="token operator">&lt;=</span> CURDATE<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li>特别大的结果集将不会被缓存，这个阈值由 query_cache_limit 参数控制</li>
<li>在分库分表环境下，查询缓存将不起作用</li>
<li>SQL 中存在自定义函数、触发器时，查询缓存将不起作用</li>
</ul>
</div><div class="cl-preview-section"><h3 id="我可以强制使用索引查询吗-？">3.3 我可以强制使用索引查询吗 ？</h3>
</div><div class="cl-preview-section"><p>有些情况下，虽然我们知道可以使用索引，但是 MySQL 的优化器可能会放弃。例如在 <code>WHERE</code> 子句中使用参数查询的情况：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">SET</span> <span class="token variable">@sal</span> <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

<span class="token comment">-- WHERE 子句中使用参数，会导致全表扫描</span>
mysql<span class="token operator">&gt;</span> <span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> salary <span class="token keyword">FROM</span> worker <span class="token keyword">WHERE</span> salary <span class="token operator">&gt;=</span> <span class="token variable">@sal</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p>但是，我们确切的可以知道，当前的查询语句是可以使用索引的。那么，就可以显示的声明强制索引查询。语法及使用方法如下：</p>
</div><div class="cl-preview-section"><pre class="  language-sql"><code class="prism  language-sql"><span class="token comment">-- 语法</span>
<span class="token keyword">FORCE</span> <span class="token keyword">INDEX</span><span class="token punctuation">(</span>索引名称<span class="token operator">/</span>主键<span class="token punctuation">)</span>

<span class="token comment">-- 强制使用 salary_name_idx 索引（salary_name_idx 需要存在）</span>
<span class="token keyword">SELECT</span> id<span class="token punctuation">,</span> name<span class="token punctuation">,</span> salary <span class="token keyword">FROM</span> worker <span class="token keyword">FORCE</span> <span class="token keyword">INDEX</span><span class="token punctuation">(</span>salary_name_idx<span class="token punctuation">)</span> <span class="token keyword">WHERE</span> salary <span class="token operator">&gt;=</span> <span class="token variable">@sal</span><span class="token punctuation">;</span>
</code></pre>
</div><div class="cl-preview-section"><p>强制存储引擎使用索引时，首先会检查索引是否可用，如果不可用，还是需要扫描全表来执行查询计划。MySQL 官方也对强制使用索引进行了说明，主要意思就是不需要担心强制索引存在的副作用，原文如下。</p>
</div><div class="cl-preview-section"><blockquote>
<p>The FORCE INDEX hint acts like USE INDEX (index_list), with the addition that a table scan is assumed to be very expensive. In other words, a table scan is used only if there is no way to use one of the named indexes to find rows in the table.</p>
</blockquote>
</div><div class="cl-preview-section"><h2 id="总结">4. 总结</h2>
</div><div class="cl-preview-section"><p>日常工作中，我们几乎每天都会接触到 MySQL（我几乎每天都会定位、排查慢查询），所以，优化查询的重要性不言而喻。我在这一节里总结的表、语句相关的优化策略，基本上能够 “应付” 日常的开发工作了。更多的优化方法和经验，就需要你在工作中多去思考和总结了。</p>
</div><div class="cl-preview-section"><h2 id="问题">5. 问题</h2>
</div><div class="cl-preview-section"><p>对于创建数据表，你有怎样的经验和建议呢 ？<br><br>
你能总结下，哪些使用方法会导致索引失效吗 ？<br><br>
你能说一说，你在工作、学习中都使用过哪些优化查询的方法吗 ？<br></p>
</div><div class="cl-preview-section"><h2 id="参考资料">6. 参考资料</h2>
</div><div class="cl-preview-section"><p>《高性能 MySQL（第三版）》<br><br>
<a href="https://dev.mysql.com/doc/refman/5.7/en/miscellaneous-functions.html">MySQL 官方文档：Miscellaneous Functions</a><br><br>
<a href="https://dev.mysql.com/doc/refman/5.7/en/static-format.html">MySQL 官方文档：Static (Fixed-Length) Table Characteristics</a><br><br>
<a href="https://dev.mysql.com/doc/refman/5.7/en/storage-requirements.html">MySQL 官方文档：Data Type Storage Requirements</a><br><br>
<a href="https://dev.mysql.com/doc/refman/5.7/en/optimization.html">MySQL 官方文档：Optimization</a><br><br>
<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">MySQL 官方文档：The InnoDB Storage Engine</a></p>
</div>
			
		</div>
	
	
	<div class="finish-learn">
		<p class="copyright">©版权归慕课网所有，未经许可不得转载</p>
		
		
		
		<div class="ad_pic">
			<img src="https://img3.mukewang.com/5ea1840500011d7f06700192.jpg">
		</div>
		
		
		
		
	</div>
	<div class="comment-con">
		<h4 class="title">
			精选留言
			
				<a href="javascript: void(0);" class="add-comment js-comment-click"><i class="imwap-xieliuyan"></i><span>写留言</span></a>
			
		</h4>
		
			<ul class="comment-content">
				
				<li class="item">
					<a href="/read/commentdetail/5417">
						<img src="https://img.mukewang.com/599cc57b00015fa302110206-100-100.jpg" alt="" class="avatar">
						<h4 class="nickname">街边七号</h4>
						<div class="comment-text">1. a.自增主键. b.尽量保证字段小一些. c.适当的冗余存储. d. 尽量让列值非空. 
2. where子句字段类型和操作值的类型不一致如varchar类型的列`year`判断时使用where year = '2020';  like模糊前缀匹配;  对于聚簇索引条件丢失前缀匹配;  where中使用SQL函数; 查询不使用索引列.
3.</div>
						<div>
							
						</div>
					</a>
					<p class="bottom">
						<span class="l">2020-05-11</span>
						<a href="/read/commentdetail/5417">
							<span class="icon r"><i class="imwap-comment"></i><em>0</em></span>
						</a>
						<span data-cid="5417" class="icon r js-comment-upvote "><i class="imwap-thumb_up"></i><em>1</em></span>
					</p>
				</li>
				
			</ul>
			
		
	</div>
	
	

	
		
	
	
	
		<div class="bottom-con">
			
			
				<div class="inner">
					
						<div class="price-con js-price-con">
							<span class="now">￥68.00</span>
						</div>
							
					
					
					<a class="gobuy js-gobuy" href="//m.imooc.com/account/login?backurl=//m.imooc.com/confirmorder?type=30&typeid=71">
					
						立即购买
					</a>  
				</div>
			
		</div>
	
	<div class="layer-catalog js-layer-catalog hide">
		<div class="layer-title clearfix">
			<div class="l">
				课程目录
			</div>
			
		</div>
		<div class="layer-wrap">
			<div class="js-catalog-container">
			</div>
		</div>
	</div>
	<div class="layer-comment">
		<div class="inner">
			<h5>
				<span class="btn l js-cancel-comment">取消</span>
				评论
				<span class="btn r js-send-comment">发送</span>
			</h5>
			<textarea id="comment-txt" maxlength="20000" placeholder="欢迎在这里发表留言，作者筛选后可公开显示"></textarea>
		</div>
	</div>


            </div>
        </div>
        
            
         
        
        
        
        




<script>
	// 设置字号大小及选中
	(function() {
			var fs = window.localStorage.getItem('font-size') || 'normal';
			var $c = document.querySelector('#middle>.content');
			var $points = document.querySelectorAll('.setting-box .point');
			try{
				// 抢读完了时 该元素不渲染 会有报错
				$c.className = 'content ' + fs;
				for(var i = 0; i < $points.length; i++) {
					if($points[i].className.indexOf(fs) > -1) {
						$points[i].className = $points[i].className + ' current';
					}
				}
			} catch(e) {}
			
	})();
</script>

<script type="text/javascript">
	window.onload = function() {
			zhuge.track('LearnCourse', {
					'Category': '专栏',
					'Name': '23 关于 SQL 查询语句，有什么好的建议吗？',
					'CID': '1843',
					'Teacher': '勤一'
			});
	}
</script>

        
            <script type="text/javascript">
                var shareData = { 
                    title:  "23 关于 SQL 查询语句，有什么好的建议吗？",
                    desc: "打包 MySQL 常用高级技巧特性",
                    imgUrl: 'https:https://img.mukewang.com/5e65bd6e0001444005400720.jpg',
                    otherImgUrl: 'https://img.mukewang.com/5e65bd6e0001444005400720.jpg',
                    text: '我正在参加@慕课网的课程，很不错哦！快来一起学习吧！',
                    // url: 'https://www.imooc.com' + window.location.pathname + window.location.search
                    url: 'https://m.imooc.com/read/71',
                    link: 'https://m.imooc.com/read/71'
                }
            </script>
            
        
        <div style="display:none;">
            <!-- 百度统计 -->
            <script>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?c92536284537e1806a07ef3e6873f2b3";
              var s = document.getElementsByTagName("script")[0];
              s.parentNode.insertBefore(hm, s);
            })();
            </script>

            <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
            </script>
        </div>
        
    <script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/zhugeio/init_f9752c3.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/jquery-2.1.0.min_ac9f840.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/common_84429c0.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/juicer/juicer.min_8643248.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/previewImage/previewImage.min_43b970d.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/msg_bed8d10.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/read/7.2.8/article_30e5762.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/course/advertisementReport_6e58a98.js"></script></body>
</html>
