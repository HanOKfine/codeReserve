<!doctype html>
<html lang="zh_CN">

    

    

    
    
    
    <head>
        
        <title>36 类和继承相关面试题精讲</title>
        
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="突破技术瓶颈，迈向更高岗位">
        <meta name="keywords" content="慕课网">
        <meta name="author" content="">
        <meta name = "format-detection" content="telephone=no">
        <meta http-equiv="Cache-Control" content="no-transform " />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <link rel="shortcut icon" href="https://m.imooc.com/static/wap/static/favicon.ico" />
        
        
        
        <script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/flexible.js"></script>
        
        <script type="text/javascript">
            var userInfo = "";
            
                var isApp = 0;
            
        </script>
         
<!-- 专栏首页列表模板 -->
<script type="text/template" id="index-list-tpl">
<ul class="list-con">
    {@each data.data as item}
        <li>
            <a href="/read/${item.id}" class="item clearfix">
                <div class="img l" style="background-image: url(${item.app_pic1})">
                    {@if item.is_new }
                        <div class="icon new">
                            上新
                        </div>
                    {@else if item.is_marking} 
                        <div class="icon">
                            经典
                        </div>
                    {@/if} 
                </div>
                <div class="text-con l">
                    <div class="title">
                        ${item.title}
                    </div>
                    <div class="desc">
                        ${item.chapter_num}节 · ${item.description}
                    </div>
                     <div class="user-info">
                        ${item.nickname}
                        {@if item.author_title }
                        <span class="dot">
                            ·
                        </span>
                        ${item.author_title}
                        {@/if}
                    </div>
                    <div class="info clearfix">
                    {@if !item.isBuy } 
                        <!-- 未购买才显示 -->
                        <div class="price-con l">
                        {@if item.open_discount == "1" }
                            <span class="now">￥${item.pay_price}</span>
                            <span class="ori">￥${item.price}</span>
                            <p class="sale">${item.discount_name}</p>
                        {@else}
                            <span class="now">￥${item.price}</span>
                        {@/if}
                        </div>
                    {@/if}
                        <div class="taste-con r">
                            <span>${item.numbers}人订阅</span>
                            {@if !item.isBuy }
                                <span class="gotaste">试读</span>
                            {@else}
                                <span class="gotaste">学习</span>
                            {@/if}
                        </div>
                    </div>
                </div>
            </a>
        </li>
    {@/each}
</ul>
</script>



<!-- 专栏目录 买后目录页、 -->
<script type="text/template" id="detail-catalog-tpl">
<ul class="catalog-list">
{@each data.list as item}
    <li class="zhang">
        {@if data.structure_mode == "1" }
            <!--章节模式-->
            <div class="zhang-title">
                ${item.title}（${item.count}节）
            </div>
            <div class="zhang-sub-title">
                ${item.short_introduce}
            </div>
        {@/if}  
        <ul class="zhang-detail">
            {@each item.list as it,i}
                <li class="jie">
                    {@if data.isLogin }
                        <!-- 购买了  -->
                        {@if data.isBuy }
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read">
                        {@else}
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read" >
                        {@/if}
                    {@else}
                        <!-- 未登录  -->
                        {@if data.isApp }
                            <a href="javascript:;" onclick="window.nativeSupport.login();">
                        {@else}
                            <a href="//m.imooc.com/account/login?backurl=/read/${data.column_id}">
                        {@/if}
                    {@/if}
                        <div class="jie-con {@if data.last_chapter == it.id }recent{@/if}">
                            
                            <div class="text-con">
                                <div class="jie-title">
                                    ${it.title}
                                </div>
                                <div class="jie-status">
                                    {@if it.is_open == "0" }
                                        <span class="update-time" >${it.open_time_fmt}</span>
                                    {@/if}
                                    {@if it.view_num > 100 }
                                    <div class="learn-num">
                                        <i class="imwap-set-sns"></i>
                                        <span>${it.view_num}</span>
                                    </div>
                                    {@/if}
                                    {@if it.in_24hours == "1" }
                                        <span class="update-recent">最近更新</span>
                                    {@/if}
                                </div>
                            </div>
                        </div>
                        {@if it.is_learned }
                            <div class="jie-right haslearn is_learned js-learn" data-type="1">
                                已学
                            </div>
                        {@else}
                            <!-- 购买了  -->
                            {@if data.isBuy }
                                <div class="jie-right learn js-learn" data-type="1">
                                    学习
                                </div>
                            {@else}
                                {@if it.is_pay == "0" }
                                <!--免费小节 不占用试读次数  -->
                                    <div class="jie-right learn js-learn" data-type="1">
                                        免费
                                    </div>
                                {@else}
                                    <div class="jie-right learn js-learn" data-type="0">
                                        学习
                                    </div>
                                {@/if}
                            {@/if}
                            
                            
                        {@/if}
                    </a>
                </li>
            {@/each}
        </ul>
    </li>
{@/each}
</ul>
</script> 

<!-- 阅读页 阅读页   专栏目录  -->
<script type="text/template" id="catalog-tpl">
<div>
    <h2 class="article-title">${data.a_name}</h2>
    <ul class="catalog">
    {@each data.list as item}
        <li class="zhang">
            {@if data.structure_mode == "1" }
                <!--章节模式-->
                <div class="zhang-title">
                    ${item.title}
                    <!-- <div class="num">共${item.count}节</div> -->
                </div>
            {@/if}  
            <ul class="zhang-detail">
                {@each item.list as it,i}
                    <li class="jie">
                        <!--买了且开放的-->
                        <a href="/read/${data.column_id}/article/${it.id}">
                            <div class="jie-title clearfix full">
                                <p>
                                    {@if data.last_chapter == it.id }
                                        <span class="recent">最近阅读</span>
                                    {@/if}
                                    ${it.title}
                                </p>
                            </div>
                        </a>
                    </li>
                {@/each}
            </ul>
        </li>
    {@/each}
    </ul>
</div>
</script>





<script type="text/javascript">
	var isApp = "";
	var clientVersion = "0";
	var count_num = "0";
	var chapter_id = "1931";
	var chapter_title = "36 类和继承相关面试题精讲";
	var aid = "76";
	var a_name = "Python 源码深度剖析";
	var a_price = "68.00";
	var a_pic = "https://img4.mukewang.com/5eb68ab400017cda05400720.jpg";
	var userId = 0;

	var column_id = '76';
	var isLogin = 0;
	

</script>
<!-- 引入字体 -->
<script type="text/javascript" src="//cdn.webfont.youziku.com/wwwroot/js/wf/youziku.api.min.js"></script>
<script type="text/javascript">
$youziku.load(".top-con .title, .cl-preview-section h1,.cl-preview-section h2,.cl-preview-section h3,.cl-preview-section h4,.cl-preview-section h5,.cl-preview-section h6", "37af461390fa4d138f5c3d277f7286dc", "SourceHanSerifSC-Heavy"); // 思源宋体heavy
$youziku.load(".lead-motto, .cl-preview-section blockquote", "d9a0d855583142c3b2cc3bf1646a8473", "SourceHanSerifSC-Regular"); // 思源宋体regular
$youziku.load("#article_content, .cl-preview-section pre, .cl-preview-section code, #code-copy", "3d84aabcf9e44b6f8c6fa91c61fa926e", "HYQiHei-55S"); // 汉仪旗黑55s
$youziku.load(".cl-preview-section strong", "fd94fff3a17546a28913a79613bddcec", "HYQiHei-77S"); // 汉仪旗黑70s

$youziku.draw();
</script>

<style type="text/css">
  header{
    display: none!important;
  }
  
  #wrapper{
  	padding-top:0px !important;
  }
  
</style>



    <link rel="stylesheet" href="https://m.imooc.com/static/wap/static/common/css/common_d42b1ef.css" /><link rel="stylesheet" href="https://m.imooc.com/static/wap/static/css/read/7.2.8/article_2d28313.css" /></head>
    <body >
        
          
        

        
          
        

        
          







<header class="directory2">
	<div class="header clearfix">
		
			
				<div class="page-title clearfix">
					<a href="//m.imooc.com" class="imwap-icon-imooc"></a>
					<div class="page-title-name js-page-name">
						<span>专栏</span>
						<i class="imwap-arrow_d"></i>
					</div>
				</div>
			

			
			<div class="drawer-box js-drawer-more">
				<i class="imwap-more_vert"></i>
				<div class="drawer-content js-drawer-content">
					<p class="line-row"></p>
					<a class="drawer-item" href="//m.imooc.com"><i class="imwap-center"></i>回到首页</a>
					<a class="drawer-item" href="//www.imooc.com/m/web/user/usercenter.html"><i class="imwap-peaple"></i>个人中心</a>
					<a class="drawer-item" href="//m.imooc.com/feedback"><i class="imwap-comment"></i>反馈问题</a>
					
					<a class="drawer-item" href="//m.imooc.com/account/login"><i class="imwap-out"></i>注册登录</a>
					
				</div>
			</div>
			

			
				<a id="js-appload" href="Javascript:;" class="app-load"><span>下载APP</span></a>
			

		
	</div>
	
	<div class="page-tab-wrap">
		<div class="page-tab-list">
			<a href="//m.imooc.com" class="page-tab-item">首页</a>
			<a href="//m.imooc.com/course/list" class="page-tab-item">课程</a>
			<a href="//coding.m.imooc.com" class="page-tab-item">实战</a>
			<a href="//class.m.imooc.com" class="page-tab-item">金职位</a>
			<a href="//m.imooc.com/article" class="page-tab-item">手记</a>
			<a href="//m.imooc.com/read" class="page-tab-item active">专栏</a>
			<a href="//m.imooc.com/wenda" class="page-tab-item">猿问</a>
			<a href="//m.imooc.com/wiki" class="page-tab-item">慕课教程</a>
			
		</div>
	</div>
	
</header>


        

        <div id="wrapper">
            <div id="middle" class="container ">

                

                
	
		
	
	<div class="top-con">
		<p class="update-time"><span>2020-08-31&nbsp;&nbsp;&nbsp;更新</span></p>
		<div class="title">
			36 类和继承相关面试题精讲
		</div>
	</div>
	
		<div class="article-img" style="background-image: url('https://img4.mukewang.com/5f3c86f4000105dd06400426.jpg')"></div>
	
	
		<a href="/read/76">
			<div class="course-entry">
				<img src="https://img2.mukewang.com/5e4a3ec90001ef8d04000400-40-40.jpg" alt="fasionchan">
				<h3>Python 源码深度剖析</h3>
				<p>fasionchan · 资深 Python 研发工程师</p>
				<i class="imwap-arrow_r"></i>
			</div>
		</a>
	
	
		<div class="lead-motto">
			<div class="content">困难只能吓倒懦夫懒汉，而胜利永远属于敢于等科学高峰的人。<p class="author">——茅以升</p></div>
		</div>
	
	
		<div class="content" id="article_content">
			
			<div class="cl-preview-section"><p><em>Python</em> 提供了完整的面向对象编程能力，将面向对象编程思想带到实际项目，可极大提高开发效率。因此，面向对象编程也是 <em>Python</em> 面试中必问的重要话题。</p>
</div><div class="cl-preview-section"><p>想要在 <em>Python</em> 项目中应用面向对象编程技术，除了掌握基本的理论概念外，还要理解 <em>Python</em> 对象模型、 类机制、继承与属性查找的关系、描述符以及元类等诸多知识。这些都是面试中经常考察的关键知识点。</p>
</div><div class="cl-preview-section"><p>本节精选若干典型面试题，以此抛砖引玉。</p>
</div><div class="cl-preview-section"><p><strong>如何理解面向对象编程中的方法重写( overriding )和重载( overloading )？</strong></p>
</div><div class="cl-preview-section"><p>请结合 Python 或其他编程语言进行说明。</p>
</div><div class="cl-preview-section"><p><strong>方法重写</strong> ( <em>overriding</em> )是指在子类中重新实现已在父类中定义的方法。</p>
</div><div class="cl-preview-section"><p>在面向对象编程语言中，子类可以继承父类���的方法，而无须重新编写相同的方法。但有时子类并不想原封不动地继承父类所有功能，想对父类中的某些方法进行修改，这就需要采用方法重写特性。方法重写不能发生在同一个类中，只能发生在子类中。</p>
</div><div class="cl-preview-section"><p>这是一个最简单的方法重写实例：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">:</span>
    
    <span class="token keyword">def</span> <span class="token function">eat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'yummy!'</span><span class="token punctuation">)</span>
    
    <span class="token keyword">def</span> <span class="token function">yelp</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'woof!'</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">Sleuth</span><span class="token punctuation">(</span>Dog<span class="token punctuation">)</span><span class="token punctuation">:</span>
    
    <span class="token keyword">def</span> <span class="token function">yelp</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'WOOF! WOOF! WOOF!'</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>Dog</em> 是一个普通狗类，实现了 <em>eat</em> 和 <em>yelp</em> 方法。猎犬 <em>Sleuth</em> 继承于 <em>Dog</em> 类，因此继承了父类的 <em>eat</em> 方法。注意到，我们对 <em>yelp</em> 方法进行 <strong>重写</strong> ，以连续三个大写的 <em>WOOF</em> 突出猎犬铿锵有力的吠声。</p>
</div><div class="cl-preview-section"><p>这样一来，<em>Sleuth</em> 类继承了 <em>Dog</em> 中的 <em>eat</em> 方法，但自己的 <em>yelp</em> 方法覆盖了 <em>Dog</em> 中的相关定义：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> sleuth <span class="token operator">=</span> Sleuth<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> sleuth<span class="token punctuation">.</span>eat<span class="token punctuation">(</span><span class="token punctuation">)</span>
yummy!
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> sleuth<span class="token punctuation">.</span>yelp<span class="token punctuation">(</span><span class="token punctuation">)</span>
WOOF! WOOF! WOOF!
</code></pre>
</div><div class="cl-preview-section"><p><strong>重载</strong> ( <em>overloading</em> )既可发生在同一个类的方法之间，一般称作方法重载；亦可发生在普通函数间，一般称作函数重载。这个特性允许开发人员定义名字相同，但输入参数不同的类方法或者普通函数，即同名方法/函数的不同版本。</p>
</div><div class="cl-preview-section"><p>当程序调用重载方法或函数时，编译器将根据 <strong>参数个数</strong> 及 <strong>参数类型</strong> ，自动绑定正确的版本。由于方法/函数绑定时涉及类型检查，因此一般只有静态类型编程语言才支持重载特性。</p>
</div><div class="cl-preview-section"><p><em>Python</em> 是一种动态类型编程语言，不支持方法重载，我们举一个简单的 <em>C++</em> 程序作为例子：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token comment">#include &lt;iostream&gt;</span>

using namespace std<span class="token punctuation">;</span>
  
void <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">" Here is int "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

void <span class="token keyword">print</span><span class="token punctuation">(</span>double  f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">" Here is float "</span> <span class="token operator">&lt;&lt;</span> f <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

void <span class="token keyword">print</span><span class="token punctuation">(</span>char const <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">" Here is char* "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token builtin">int</span> main<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token number">10.10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"ten"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>程序定义了 <em>print</em> 函数，分为 <em>3</em> 个不同版本，分别以整型、双精度浮点以及常字符串为参数。<em>main</em> 函数中调用 <em>print</em> 函数时，编译器将根据参数类型，自动选择正确的 <em>print</em> 函数版本。以 <em>print(10)</em> 为例，由于参数 <em>10</em> 是一个整数，编译器可以据此推导出 <em>void print(int i)</em> 版本。</p>
</div><div class="cl-preview-section"><p><strong>Python 支持多继承吗？试说明多继承场景下实例对象类属性查找顺序？</strong></p>
</div><div class="cl-preview-section"><p><em>Python</em> 支持多继承，只需将基类按顺序逐一声明即可：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">Child</span><span class="token punctuation">(</span>Base1<span class="token punctuation">,</span> Base2<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">pass</span>
</code></pre>
</div><div class="cl-preview-section"><p>当子类实例对象查找某个类属性时，先在子类 <em>Child</em> 中查找，再按定义顺序到基类中逐个中查找。如果基类也继承于其他类的基类，<em>Python</em> 将沿着继承链逐级回溯，最终来到 <em>object</em> 。</p>
</div><div class="cl-preview-section"><p>类属性查找顺序决定程序的行为，不可不察，特别是在复杂多继承场景下。实际上，<em>Python</em> 类属性查找顺序是一个特殊的拓扑排序。这个拓扑排序首先是深度优先的，其次需要确保多继承基类按照定义的顺序查找。</p>
</div><div class="cl-preview-section"><p>接下来，我们构造一个多继承关系网，考察决定属性查找顺序的重要因素，例子如下：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">E</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">(</span>D<span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>
</code></pre>
</div><div class="cl-preview-section"><p>例子涉及各个类的继承关系图如下：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5f431ce300018d1412480449.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>子类总比父类先被搜索，因此必须满足以下关系，拓扑排序即可胜任：</p>
</div><div class="cl-preview-section"><ul>
<li><em>F</em> 先于 <em>D</em> ；</li>
<li><em>F</em> 先于 <em>E</em> ；</li>
<li><em>D</em> 先于 <em>C</em> ；</li>
<li><em>C</em> 先于 <em>A</em> ；</li>
<li><em>A</em> 先于 <em>object</em> ；</li>
<li><em>E</em> 先于 <em>A</em> ；</li>
<li><em>E</em> 先于 <em>B</em> ；</li>
<li><em>B</em> 先于 <em>object</em> ；</li>
</ul>
</div><div class="cl-preview-section"><p>而根据多继承基类列表顺序，必须保证：</p>
</div><div class="cl-preview-section"><ul>
<li><em>B</em> 先于 <em>A</em> ；</li>
<li><em>D</em> 先于 <em>E</em> ；</li>
</ul>
</div><div class="cl-preview-section"><p>因此，<em>F</em> 最先被搜索，接着是 <em>D</em> ，然后按照深度优先的原则来到 <em>C</em> ；由于 <em>B</em> 先于 <em>A</em> ，不能接着搜索 <em>A</em> ；这时只能先搜索 <em>E</em> 分支，然后是 <em>B</em> ，再到 <em>A</em> ；<em>A</em> 和 <em>B</em> 皆搜索过后才能搜索 <em>object</em> 。因此，完整的搜索顺序是这样的：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">F <span class="token operator">-</span><span class="token operator">&gt;</span> D <span class="token operator">-</span><span class="token operator">&gt;</span> C <span class="token operator">-</span><span class="token operator">&gt;</span> E <span class="token operator">-</span><span class="token operator">&gt;</span> B <span class="token operator">-</span><span class="token operator">&gt;</span> A <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">object</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>Python</em> 完成类对象初始化后，通过 <em>C3</em> 算法计算类属性搜索顺序，并将其保存在 <em>__mro__</em> 属性中。我们可以据此确认推理结果：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> F<span class="token punctuation">.</span>__mro__
<span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.F'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.D'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.C'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.E'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.B'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.A'</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'object'</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>如果规则前后矛盾，<em>Python</em> 将抛 <em>TypeError</em> 异常。这是一个典型的例子：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> A<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>

<span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> D<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">pass</span>
</code></pre>
</div><div class="cl-preview-section"><p>对于 <em>F</em> 类，基类 <em>C</em> 要求 <em>A</em> 先于 <em>B</em> 被搜索，而基类 <em>D</em> 要求 <em>B</em> 先于 <em>A</em> 被搜索，前后矛盾：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
TypeError<span class="token punctuation">:</span> Cannot create a consistent method resolution
order <span class="token punctuation">(</span>MRO<span class="token punctuation">)</span> <span class="token keyword">for</span> bases A<span class="token punctuation">,</span> B
</code></pre>
</div><div class="cl-preview-section"><p>由于多继承存在一定的歧义性，实际项目开发一般不鼓励复杂的多继承关系。如果多继承不可避免，则需要严谨确认类属性搜索顺序。最好查看 <em>__mro__</em> 属性确认顺序符合预期，切勿想当然。</p>
</div><div class="cl-preview-section"><p><strong>试设计装饰器 mystaticmethod ，实现与 staticmethod 相同的功能</strong></p>
</div><div class="cl-preview-section"><p>根据属性描述符原理，我们需要实现一个装饰器，将函数对象改造成一个特殊的 <strong>非数据描述符</strong> 。当实例对象访问对应属性时，描述符 <em>__get__</em> 方法将被调用，它只需将函数对象原样返回即可：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">mystaticmethod</span><span class="token punctuation">:</span>
    
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> func<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>func <span class="token operator">=</span> func
        
    <span class="token keyword">def</span> <span class="token function">__get__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> instance<span class="token punctuation">,</span> owner<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>func
</code></pre>
</div><div class="cl-preview-section"><p>这样一来，静态函数可以这样来写，以在 <em>Foo</em> 类实现静态方法 <em>add</em> 为例：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">:</span>
    
    @mystaticmethod
    <span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b
    
    <span class="token keyword">def</span> <span class="token function">add2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> a <span class="token operator">+</span> b
</code></pre>
</div><div class="cl-preview-section"><p>接着，我们创建一个实例对象 <em>foo</em> ，并通过实例对象访问 <em>add</em> 属性。我们得到的是原始的 <em>add</em> 函数对象，而不是一个 <em>bound method</em> 对象：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> foo <span class="token operator">=</span> Foo<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> foo<span class="token punctuation">.</span>add
<span class="token operator">&lt;</span>function Foo<span class="token punctuation">.</span>add at <span class="token number">0x1092189d8</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> foo<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token number">3</span>
</code></pre>
</div><div class="cl-preview-section"><p>至此，我们通过自己的聪明才智，成功实现了静态方法装饰器。作为对照，<em>add2</em> 未加装饰，它将成为一个普通的类方法。我们通过 <em>foo</em> 实例对象访问 <em>add2</em> 属性时，将得到一个 <em>bound method</em> 对象：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> foo<span class="token punctuation">.</span>add2
<span class="token operator">&lt;</span>bound method Foo<span class="token punctuation">.</span>add2 of <span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>Foo <span class="token builtin">object</span> at <span class="token number">0x1092349e8</span><span class="token operator">&gt;&gt;</span>
</code></pre>
</div><div class="cl-preview-section"><p><strong>Python 如何实现单例模式？试举例说明。</strong></p>
</div><div class="cl-preview-section"><p>通过 <em>Python</em> 对象模型部分学习，我们知道 <em>Python</em> 对象创建和初始化分别由定义于类型对象中的 <em>tp_new</em> 以及 <em>tp_init</em> 函数负责。相应地，在自定义类中，可以通过 <em>__new__</em> 和 <em>__init__</em> 魔术方法来控制实例对象的实例化。</p>
</div><div class="cl-preview-section"><p>对于类 <em>X</em> ，当我们调用 <code>x = X()</code> 创建实例对象 <em>x</em> 时，<em>Python</em> 内部分为两步进行：</p>
</div><div class="cl-preview-section"><ol>
<li>调用 <em>X.__new__</em> 为实例对象分配内存，这一步完成实例对象的创建；</li>
<li>调用 <em>X.__init__</em> 将实例对象初始化，<em>1</em> 中生成的实例对象作为 <em>self</em> 参数传给 <em>__init__</em> 方法；</li>
</ol>
</div><div class="cl-preview-section"><p>如果 <em>X</em> 类未实现 <em>__new__</em> 方法，<em>Python</em> 将使用其父类的。如果父类也没有实现该方法，<em>Python</em> 最终将调用 <em>object.tp_new</em> 。<em>object</em> 基类型对象是所有类型对象的基类，它提供了一个通用的 <em>tp_new</em> 版本。</p>
</div><div class="cl-preview-section"><p>当 <em>__init__</em> 方法执行时，对象已经完成了创建，因此无法实现全局唯一的约束。但我们可以在 <em>__new__</em> 方法中做手脚，先判断对象是否已经创建，如果是直接将其返回，否则调用父类的 <em>__new__</em> 方法完成进行创建并保存。示例代码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">SomeClass</span><span class="token punctuation">:</span>
    
    instance <span class="token operator">=</span> <span class="token boolean">None</span>
    
    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> cls<span class="token punctuation">.</span>instance <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>
            cls<span class="token punctuation">.</span>instance <span class="token operator">=</span> <span class="token builtin">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span>
            
        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>instance
    
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># do some initialization</span>
        <span class="token keyword">pass</span>
</code></pre>
</div><div class="cl-preview-section"><p>例子中，类属性 <em>instance</em> 用于保存 <em>SomeClass</em> 类全局唯一的实例对象。</p>
</div><div class="cl-preview-section"><p>在 <em>__new__</em> 函数中，我们先检查 <em>instance</em> 属性。如果它为 <em>None</em> ，说明实例尚未创建。这时，我们通过 <em>super</em> 调用父类的 <em>__new__</em> 方法完成实例对象的创建，并将其保存与 <em>instance</em> 属性中。</p>
</div><div class="cl-preview-section"><p>当我们再次调用 <em>SomeClass</em> 类创建实例对象时，<em>__new__</em> 方法也将被调用。但此时，<em>instance</em> 已不再是 <em>None</em> ， <em>__new__</em> 直接将其返回，由此避免重复实例化。</p>
</div><div class="cl-preview-section"><p>这样一来，不管我们调用 <em>SomeClass</em> 多少次，得到的实例对象总是全局唯一的那一个：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> instance <span class="token operator">=</span> SomeClass<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">id</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
<span class="token number">4302595728</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> instance <span class="token operator">=</span> SomeClass<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token builtin">id</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span>
<span class="token number">4302595728</span>
</code></pre>
</div><div class="cl-preview-section"><p><strong>如果程序中有成千上万的 User 类实例对象，如何优化内存使用？</strong></p>
</div><div class="cl-preview-section"><p>提示 <em>User</em> 只包含属性 <em>name</em> 和 <em>email</em> 以及若干个类方法：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">:</span>
    
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> email<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>email <span class="token operator">=</span> email
        
    <span class="token keyword">def</span> <span class="token function">some_method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>
        
    <span class="token keyword">def</span> <span class="token function">another_method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>

user <span class="token operator">=</span> User<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'小菜学编程'</span><span class="token punctuation">,</span> email<span class="token operator">=</span><span class="token string">'coding-fan@mp.weixin.qq.com'</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>根据我们学到的 <em>Python</em> 类机制知识，<em>User</em> 类对象及其实例对象底层内存布局大致如下：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5f431cd00001420417900612.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>中间橘色部分是 <em>User</em> 类对象，它是一个 <em>PyTypeObject</em> 结构体，<em>tp_dict</em> 字段指向类属性空间。类属性空间是一个字典对象，里面保存着类属性，类方法 <em>some_method</em> 也位于其中。</p>
</div><div class="cl-preview-section"><p>而 <em>User</em> 实例对象(如例子中的 <em>user</em> )，如蓝色部分所示，它的结构则简单得多，底层是一个 <em>PyObject</em> 结构体。紧接着 <em>PyObject</em> 的是一个指针，指向实例对象属性空间的字典。实例对象属性空间也是一个字典对象，里面则保存着实例对象的属性 <em>name</em> 和 <em>email</em> 。</p>
</div><div class="cl-preview-section"><p>注意到，<em>User</em> 类对象全局只有一个，而它的实例对象却可以有无数个。那么，一个实例对象占用多少内存空间呢？我们调用 <em>sys.getsizeof</em> 查看一下：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> sys<span class="token punctuation">.</span>getsizeof<span class="token punctuation">(</span>user<span class="token punctuation">)</span>
<span class="token number">64</span>
</code></pre>
</div><div class="cl-preview-section"><p>不对吧？在内建对象部分，我们学习了字典对象的布局，它动辄 <em>200</em> 多字节呢！实际上，<em>getsizeof</em> 只计算蓝色部分内存，这部分是 <em>32</em> 字节，而 <em>PyObject</em> 之前还有 <em>32</em> 字节用于垃圾回收的隐形开销。</p>
</div><div class="cl-preview-section"><p>因此，一个 <em>User</em> 实例对象的内存开销是 <em>64</em> 字节加上属性空间字典对象的内存开销。换句话讲，每创建一个 <em>User</em> 实例，<em>Python</em> 都会帮你创建一个字典对象，来保存实例属性。</p>
</div><div class="cl-preview-section"><p>属性空间字典是一个不小的开销，当前这个场景似乎不需要。因为 <em>User</em> 实例对象属性只有固定的两个，不会出现这样的情况：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> user<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">10</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> user<span class="token punctuation">.</span>age
<span class="token number">10</span>
</code></pre>
</div><div class="cl-preview-section"><p>联想到函数局部名字空间与这个场景非常类似：参数个数是固定的，因此名字空间由一个静态的数组实现，而不是用字典对象。那么，实例属性是不是也可以采用类似的思路呢？答案是肯定的，<em>Python</em> 实现了 <em>slot</em> 机制：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">User</span><span class="token punctuation">:</span>
    
    __slots__ <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'email'</span><span class="token punctuation">)</span>
    
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> email<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name
        self<span class="token punctuation">.</span>email <span class="token operator">=</span> email
        
    <span class="token keyword">def</span> <span class="token function">some_method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>
        
    <span class="token keyword">def</span> <span class="token function">another_method</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>
    
user <span class="token operator">=</span> User<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">'小菜学编程'</span><span class="token punctuation">,</span> email<span class="token operator">=</span><span class="token string">'coding-fan@mp.weixin.qq.com'</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>这个新的 <em>User</em> 类通过 <em>__slots__</em> 将属性 <em>name</em> 和 <em>email</em> 申明为以 <em>slot</em> 形式实现。采用 <em>slot</em> 机制后，<em>Python</em> 便不会为 <em>User</em> 实例对象分配属性空间字典了，而是将属性作为 <em>slot</em> 依次排列在 <em>PyObject</em> 结构体之后：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> user<span class="token punctuation">.</span>__dict__
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
AttributeError<span class="token punctuation">:</span> <span class="token string">'User'</span> <span class="token builtin">object</span> has no attribute <span class="token string">'__dict__'</span>
</code></pre>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5f431cc40001b35f17940608.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>由此一来，动辄几百字节的字典对象被节省下来，内存使用效率得到有效提升。当然了，天下没有免费的午餐，我们丧失了在运行时新增属性的灵活性：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> user<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">10</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
AttributeError<span class="token punctuation">:</span> <span class="token string">'User'</span> <span class="token builtin">object</span> has no attribute <span class="token string">'age'</span>
</code></pre>
</div><div class="cl-preview-section"><p>因此，<em>slot</em> 机制只适用于属性个数固定的场景。</p>
</div><div class="cl-preview-section"><p><strong>用 type 元类型创建一个等价的 MyFloat 类</strong></p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">MyFloat</span><span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    
    <span class="token keyword">def</span> <span class="token function">round</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>根据 <em>Python</em> 对象模型，<em>type</em> 是所有类型对象的类型，调用 <em>type</em> 可以创建新的类型对象。在类机制部分，我们学习了自定义类的创建过程，知道 <em>type</em> 在其中所起的重要作用。</p>
</div><div class="cl-preview-section"><p>使用 <em>type</em> 创建新类型对象，接口如下：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token builtin">type</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> bases<span class="token punctuation">,</span> <span class="token builtin">dict</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> a new <span class="token builtin">type</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li><em>name</em> ，新类型名；</li>
<li><em>bases</em> ，基类列表；</li>
<li><em>dict</em> ，类属性空间；</li>
</ul>
</div><div class="cl-preview-section"><p>显而易见，为创建与 <em>MyFloat</em> 完全等价的类对象，<em>name</em> 必须是 <em>MyFloat</em> ；基类是 <em>float</em> 对象，因而 <em>bases</em> 必须是由 <em>float</em> 组成的元组，即 <em>(float,)</em> ；而作为类属性空间 <em>dict</em> 必须包含 <em>round</em> 函数对象。</p>
</div><div class="cl-preview-section"><p>我们先定义 <em>round</em> 函数以及类属性空间：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">def</span> <span class="token function">round</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">return</span> <span class="token builtin">int</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> attrs <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'round'</span><span class="token punctuation">:</span> <span class="token builtin">round</span><span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>接着，我们调用 <em>type</em> 元类型对象完成新类对象的创建：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> MyFloat <span class="token operator">=</span> <span class="token builtin">type</span><span class="token punctuation">(</span><span class="token string">'MyFloat'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token builtin">float</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">,</span> attrs<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> MyFloat
<span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.MyFloat'</span><span class="token operator">&gt;</span>
</code></pre>
</div><div class="cl-preview-section"><p>最后，我们验证新 <em>MyFloat</em> 类的功能，确认它与例子程序完全等价：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> pi <span class="token operator">=</span> MyFloat<span class="token punctuation">(</span><span class="token string">'3.14'</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> pi<span class="token punctuation">.</span><span class="token builtin">round</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">3</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>type</em> 元类编程提供了在运行时动态创建新类型的强大能力，在框架设计中非常有用。</p>
</div>
			
		</div>
	
	
	<div class="finish-learn">
		<p class="copyright">©版权归慕课网所有，未经许可不得转载</p>
		
		
		
		<div class="ad_pic">
			<img src="https://img4.mukewang.com/5f3c86fa00011d7f06700192.jpg">
		</div>
		
		
		
		
	</div>
	<div class="comment-con">
		<h4 class="title">
			精选留言
			
				<a href="javascript: void(0);" class="add-comment js-comment-click"><i class="imwap-xieliuyan"></i><span>写留言</span></a>
			
		</h4>
		
			<p class="bottom-text empty">暂无精选留言</p>
		
	</div>
	
	

	
		
	
	
	
		<div class="bottom-con">
			
			
				<div class="inner">
					
						<div class="price-con js-price-con">
							<span class="now">￥68.00</span>
						</div>
							
					
					
					<a class="gobuy js-gobuy" href="//m.imooc.com/account/login?backurl=//m.imooc.com/confirmorder?type=30&typeid=76">
					
						立即购买
					</a>  
				</div>
			
		</div>
	
	<div class="layer-catalog js-layer-catalog hide">
		<div class="layer-title clearfix">
			<div class="l">
				课程目录
			</div>
			
		</div>
		<div class="layer-wrap">
			<div class="js-catalog-container">
			</div>
		</div>
	</div>
	<div class="layer-comment">
		<div class="inner">
			<h5>
				<span class="btn l js-cancel-comment">取消</span>
				评论
				<span class="btn r js-send-comment">发送</span>
			</h5>
			<textarea id="comment-txt" maxlength="20000" placeholder="欢迎在这里发表留言，作者筛选后可公开显示"></textarea>
		</div>
	</div>


            </div>
        </div>
        
            
         
        
        
        
        




<script>
	// 设置字号大小及选中
	(function() {
			var fs = window.localStorage.getItem('font-size') || 'normal';
			var $c = document.querySelector('#middle>.content');
			var $points = document.querySelectorAll('.setting-box .point');
			try{
				// 抢读完了时 该元素不渲染 会有报错
				$c.className = 'content ' + fs;
				for(var i = 0; i < $points.length; i++) {
					if($points[i].className.indexOf(fs) > -1) {
						$points[i].className = $points[i].className + ' current';
					}
				}
			} catch(e) {}
			
	})();
</script>

<script type="text/javascript">
	window.onload = function() {
			zhuge.track('LearnCourse', {
					'Category': '专栏',
					'Name': '36 类和继承相关面试题精讲',
					'CID': '1931',
					'Teacher': 'fasionchan'
			});
	}
</script>

        
            <script type="text/javascript">
                var shareData = { 
                    title:  "36 类和继承相关面试题精讲",
                    desc: "突破技术瓶颈，迈向更高岗位",
                    imgUrl: 'https:https://img4.mukewang.com/5eb68ab400017cda05400720.jpg',
                    otherImgUrl: 'https://img4.mukewang.com/5eb68ab400017cda05400720.jpg',
                    text: '我正在参加@慕课网的课程，很不错哦！快来一起学习吧！',
                    // url: 'https://www.imooc.com' + window.location.pathname + window.location.search
                    url: 'https://m.imooc.com/read/76',
                    link: 'https://m.imooc.com/read/76'
                }
            </script>
            
        
        <div style="display:none;">
            <!-- 百度统计 -->
            <script>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?c92536284537e1806a07ef3e6873f2b3";
              var s = document.getElementsByTagName("script")[0];
              s.parentNode.insertBefore(hm, s);
            })();
            </script>

            <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
            </script>
        </div>
        
    <script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/zhugeio/init_f9752c3.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/jquery-2.1.0.min_ac9f840.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/common_84429c0.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/juicer/juicer.min_8643248.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/previewImage/previewImage.min_43b970d.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/msg_bed8d10.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/read/7.2.8/article_30e5762.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/course/advertisementReport_6e58a98.js"></script></body>
</html>
