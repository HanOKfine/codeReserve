<!doctype html>
<html lang="zh_CN">

    

    

    
    
    
    <head>
        
        <title>39 再造轮子：手把手教你设计协程库</title>
        
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="突破技术瓶颈，迈向更高岗位">
        <meta name="keywords" content="慕课网">
        <meta name="author" content="">
        <meta name = "format-detection" content="telephone=no">
        <meta http-equiv="Cache-Control" content="no-transform " />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <link rel="shortcut icon" href="https://m.imooc.com/static/wap/static/favicon.ico" />
        
        
        
        <script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/flexible.js"></script>
        
        <script type="text/javascript">
            var userInfo = "";
            
                var isApp = 0;
            
        </script>
         
<!-- 专栏首页列表模板 -->
<script type="text/template" id="index-list-tpl">
<ul class="list-con">
    {@each data.data as item}
        <li>
            <a href="/read/${item.id}" class="item clearfix">
                <div class="img l" style="background-image: url(${item.app_pic1})">
                    {@if item.is_new }
                        <div class="icon new">
                            上新
                        </div>
                    {@else if item.is_marking} 
                        <div class="icon">
                            经典
                        </div>
                    {@/if} 
                </div>
                <div class="text-con l">
                    <div class="title">
                        ${item.title}
                    </div>
                    <div class="desc">
                        ${item.chapter_num}节 · ${item.description}
                    </div>
                     <div class="user-info">
                        ${item.nickname}
                        {@if item.author_title }
                        <span class="dot">
                            ·
                        </span>
                        ${item.author_title}
                        {@/if}
                    </div>
                    <div class="info clearfix">
                    {@if !item.isBuy } 
                        <!-- 未购买才显示 -->
                        <div class="price-con l">
                        {@if item.open_discount == "1" }
                            <span class="now">￥${item.pay_price}</span>
                            <span class="ori">￥${item.price}</span>
                            <p class="sale">${item.discount_name}</p>
                        {@else}
                            <span class="now">￥${item.price}</span>
                        {@/if}
                        </div>
                    {@/if}
                        <div class="taste-con r">
                            <span>${item.numbers}人订阅</span>
                            {@if !item.isBuy }
                                <span class="gotaste">试读</span>
                            {@else}
                                <span class="gotaste">学习</span>
                            {@/if}
                        </div>
                    </div>
                </div>
            </a>
        </li>
    {@/each}
</ul>
</script>



<!-- 专栏目录 买后目录页、 -->
<script type="text/template" id="detail-catalog-tpl">
<ul class="catalog-list">
{@each data.list as item}
    <li class="zhang">
        {@if data.structure_mode == "1" }
            <!--章节模式-->
            <div class="zhang-title">
                ${item.title}（${item.count}节）
            </div>
            <div class="zhang-sub-title">
                ${item.short_introduce}
            </div>
        {@/if}  
        <ul class="zhang-detail">
            {@each item.list as it,i}
                <li class="jie">
                    {@if data.isLogin }
                        <!-- 购买了  -->
                        {@if data.isBuy }
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read">
                        {@else}
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read" >
                        {@/if}
                    {@else}
                        <!-- 未登录  -->
                        {@if data.isApp }
                            <a href="javascript:;" onclick="window.nativeSupport.login();">
                        {@else}
                            <a href="//m.imooc.com/account/login?backurl=/read/${data.column_id}">
                        {@/if}
                    {@/if}
                        <div class="jie-con {@if data.last_chapter == it.id }recent{@/if}">
                            
                            <div class="text-con">
                                <div class="jie-title">
                                    ${it.title}
                                </div>
                                <div class="jie-status">
                                    {@if it.is_open == "0" }
                                        <span class="update-time" >${it.open_time_fmt}</span>
                                    {@/if}
                                    {@if it.view_num > 100 }
                                    <div class="learn-num">
                                        <i class="imwap-set-sns"></i>
                                        <span>${it.view_num}</span>
                                    </div>
                                    {@/if}
                                    {@if it.in_24hours == "1" }
                                        <span class="update-recent">最近更新</span>
                                    {@/if}
                                </div>
                            </div>
                        </div>
                        {@if it.is_learned }
                            <div class="jie-right haslearn is_learned js-learn" data-type="1">
                                已学
                            </div>
                        {@else}
                            <!-- 购买了  -->
                            {@if data.isBuy }
                                <div class="jie-right learn js-learn" data-type="1">
                                    学习
                                </div>
                            {@else}
                                {@if it.is_pay == "0" }
                                <!--免费小节 不占用试读次数  -->
                                    <div class="jie-right learn js-learn" data-type="1">
                                        免费
                                    </div>
                                {@else}
                                    <div class="jie-right learn js-learn" data-type="0">
                                        学习
                                    </div>
                                {@/if}
                            {@/if}
                            
                            
                        {@/if}
                    </a>
                </li>
            {@/each}
        </ul>
    </li>
{@/each}
</ul>
</script> 

<!-- 阅读页 阅读页   专栏目录  -->
<script type="text/template" id="catalog-tpl">
<div>
    <h2 class="article-title">${data.a_name}</h2>
    <ul class="catalog">
    {@each data.list as item}
        <li class="zhang">
            {@if data.structure_mode == "1" }
                <!--章节模式-->
                <div class="zhang-title">
                    ${item.title}
                    <!-- <div class="num">共${item.count}节</div> -->
                </div>
            {@/if}  
            <ul class="zhang-detail">
                {@each item.list as it,i}
                    <li class="jie">
                        <!--买了且开放的-->
                        <a href="/read/${data.column_id}/article/${it.id}">
                            <div class="jie-title clearfix full">
                                <p>
                                    {@if data.last_chapter == it.id }
                                        <span class="recent">最近阅读</span>
                                    {@/if}
                                    ${it.title}
                                </p>
                            </div>
                        </a>
                    </li>
                {@/each}
            </ul>
        </li>
    {@/each}
    </ul>
</div>
</script>





<script type="text/javascript">
	var isApp = "";
	var clientVersion = "0";
	var count_num = "2";
	var chapter_id = "1935";
	var chapter_title = "39 再造轮子：手把手教你设计协程库";
	var aid = "76";
	var a_name = "Python 源码深度剖析";
	var a_price = "68.00";
	var a_pic = "https://img3.mukewang.com/5eb68ab400017cda05400720.jpg";
	var userId = 0;

	var column_id = '76';
	var isLogin = 0;
	

</script>
<!-- 引入字体 -->
<script type="text/javascript" src="//cdn.webfont.youziku.com/wwwroot/js/wf/youziku.api.min.js"></script>
<script type="text/javascript">
$youziku.load(".top-con .title, .cl-preview-section h1,.cl-preview-section h2,.cl-preview-section h3,.cl-preview-section h4,.cl-preview-section h5,.cl-preview-section h6", "37af461390fa4d138f5c3d277f7286dc", "SourceHanSerifSC-Heavy"); // 思源宋体heavy
$youziku.load(".lead-motto, .cl-preview-section blockquote", "d9a0d855583142c3b2cc3bf1646a8473", "SourceHanSerifSC-Regular"); // 思源宋体regular
$youziku.load("#article_content, .cl-preview-section pre, .cl-preview-section code, #code-copy", "3d84aabcf9e44b6f8c6fa91c61fa926e", "HYQiHei-55S"); // 汉仪旗黑55s
$youziku.load(".cl-preview-section strong", "fd94fff3a17546a28913a79613bddcec", "HYQiHei-77S"); // 汉仪旗黑70s

$youziku.draw();
</script>

<style type="text/css">
  header{
    display: none!important;
  }
  
  #wrapper{
  	padding-top:0px !important;
  }
  
</style>



    <link rel="stylesheet" href="https://m.imooc.com/static/wap/static/common/css/common_d42b1ef.css" /><link rel="stylesheet" href="https://m.imooc.com/static/wap/static/css/read/7.2.8/article_2d28313.css" /></head>
    <body >
        
          
        

        
          
        

        
          







<header class="directory2">
	<div class="header clearfix">
		
			
				<div class="page-title clearfix">
					<a href="//m.imooc.com" class="imwap-icon-imooc"></a>
					<div class="page-title-name js-page-name">
						<span>专栏</span>
						<i class="imwap-arrow_d"></i>
					</div>
				</div>
			

			
			<div class="drawer-box js-drawer-more">
				<i class="imwap-more_vert"></i>
				<div class="drawer-content js-drawer-content">
					<p class="line-row"></p>
					<a class="drawer-item" href="//m.imooc.com"><i class="imwap-center"></i>回到首页</a>
					<a class="drawer-item" href="//www.imooc.com/m/web/user/usercenter.html"><i class="imwap-peaple"></i>个人中心</a>
					<a class="drawer-item" href="//m.imooc.com/feedback"><i class="imwap-comment"></i>反馈问题</a>
					
					<a class="drawer-item" href="//m.imooc.com/account/login"><i class="imwap-out"></i>注册登录</a>
					
				</div>
			</div>
			

			
				<a id="js-appload" href="Javascript:;" class="app-load"><span>下载APP</span></a>
			

		
	</div>
	
	<div class="page-tab-wrap">
		<div class="page-tab-list">
			<a href="//m.imooc.com" class="page-tab-item">首页</a>
			<a href="//m.imooc.com/course/list" class="page-tab-item">课程</a>
			<a href="//coding.m.imooc.com" class="page-tab-item">实战</a>
			<a href="//class.m.imooc.com" class="page-tab-item">金职位</a>
			<a href="//m.imooc.com/article" class="page-tab-item">手记</a>
			<a href="//m.imooc.com/read" class="page-tab-item active">专栏</a>
			<a href="//m.imooc.com/wenda" class="page-tab-item">猿问</a>
			<a href="//m.imooc.com/wiki" class="page-tab-item">慕课教程</a>
			
		</div>
	</div>
	
</header>


        

        <div id="wrapper">
            <div id="middle" class="container ">

                

                
	
		
	
	<div class="top-con">
		<p class="update-time"><span>2020-09-10&nbsp;&nbsp;&nbsp;更新</span></p>
		<div class="title">
			39 再造轮子：手把手教你设计协程库
		</div>
	</div>
	
		<div class="article-img" style="background-image: url('https://img4.mukewang.com/5f4f01980001855c06400426.jpg')"></div>
	
	
		<a href="/read/76">
			<div class="course-entry">
				<img src="https://img3.mukewang.com/5e4a3ec90001ef8d04000400-40-40.jpg" alt="fasionchan">
				<h3>Python 源码深度剖析</h3>
				<p>fasionchan · 资深 Python 研发工程师</p>
				<i class="imwap-arrow_r"></i>
			</div>
		</a>
	
	
		<div class="lead-motto">
			<div class="content">如果不想在世界上虚度一生，那就要学习一辈子。<p class="author">——高尔基</p></div>
		</div>
	
	
		<div class="content" id="article_content">
			
			<div class="cl-preview-section"><p>经过前面章节学习，我们知道生成器可以通过 <em>yield</em> 将执行权还给调用者。这时生成器会记住自己的执行进度，重新调度后将恢复执行。利用这个特性，我们可以实现用户态 <strong>协程</strong> 。但具体如何实施呢？</p>
</div><div class="cl-preview-section"><p>本节，我们将在 <em>Python</em> 交互式终端上探索协程库的设计思路，最终形成一个精简的协程库，代码量仅 <em>100</em> 来行！麻雀虽小，五脏俱全！借此即可彻底掌握 <strong>协程运行原理</strong> 和 <strong>协程库设计精髓</strong> ，玩转协程式应用开发。</p>
</div><div class="cl-preview-section"><h2 id="事件循环建模">事件循环建模</h2>
</div><div class="cl-preview-section"><p>简而言之，我们需要实现一个 <strong>事件循环</strong> ( <em>Event Loop</em> )，它内部有一个 <strong>可执行</strong> ( <em>Runnable</em> )协程队列：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5f4f03100001bbdb08390292.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>事件循���是一个永久循环，每次循环时它先调度可执行队列里的每个协程——即从队列中取出一个可执行协程，然后调用 <em>send</em> 方法驱动它执行：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5f4f031900018bb508340291.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>协程执行的结果可分为两种不同情况。其一，协程没有遇到 <em>IO</em> 操作，一把梭哈到底并最后退出。这时， <em>send</em> 方法抛 <em>StopIteration</em> 异常通知调用者：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5f4f03210001f21f08410303.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>其二，协程需要进行 <em>IO</em> 操作，这时它应该通过 <em>yield</em> 让出执行权，并将 <em>IO</em> 操作上下文提交给事件循环。<em>IO</em> 操作由事件循环负责执行，操作上下文必须记录协程信息：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5f4f032900019dc908270614.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>可执行队列处理完毕后，得到成一个个 <em>IO</em> 操作上下文，事件循环负责将它们注册到 <em>epoll</em> ，以便订阅 <em>IO</em> 事件：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5f4f033a000155d408280613.png" alt="图片描述"><br>
接着，事件循环通过 <em>epoll</em> 等待 <em>IO</em> 事件到达。当某个 <em>IO</em> 操作就绪时，事件循环将把对应协程重新放入可执行队列。假设协程 <em>3</em> 等待的 <em>IO</em> 操作已经就绪，<em>epoll</em> 将返回对应 <em>IO</em> 事件，执行 <em>IO</em> 处理函数并将协程放回可执行队列重新调度：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5f4f03420001940e08260621.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>事件循环处理完所有 <em>epoll</em> 事件后，将进入下一次循环。这时，又开始处理可执行队列，周而复始。</p>
</div><div class="cl-preview-section"><h2 id="epoll">epoll</h2>
</div><div class="cl-preview-section"><p>由于事件循环需要同时关注多个 <em>IO</em> 操作，因此需要采用 <strong>IO多路复用</strong> 技术。那么，什么是 <em>IO</em> 多路复用呢？它又是如何使用的呢？<em>epoll</em> 是 <em>Linux</em> 下的 <em>IO</em> 多路复用技术，很有代表性。我们便以 <em>epoll</em> 为例，简单探讨一下。</p>
</div><div class="cl-preview-section"><p>服务器应用一般需要通过 <strong>套接字</strong> ( <em>socket</em> )监听某个端口，等待客户端连接。这个函数用于创建一个监听套接字：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">from</span> socket <span class="token keyword">import</span> socket<span class="token punctuation">,</span> AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR

<span class="token keyword">def</span> <span class="token function">create_listen_socket</span><span class="token punctuation">(</span>bind_addr<span class="token operator">=</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> bind_port<span class="token operator">=</span><span class="token number">55555</span><span class="token punctuation">,</span> backlogs<span class="token operator">=</span><span class="token number">102400</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 创建套接字</span>
    sock <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>
    <span class="token comment"># 设置地址复用选项</span>
    sock<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token comment"># 绑定监听地址和端口</span>
    sock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>bind_addr<span class="token punctuation">,</span> bind_port<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment"># 开始监听</span>
    sock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span>backlogs<span class="token punctuation">)</span>
    
    <span class="token keyword">return</span> sock
</code></pre>
</div><div class="cl-preview-section"><p>我们以默认参数创建一个监听套接字，并调用 <em>accept</em> 方法接受客户端连接：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s <span class="token operator">=</span> create_listen_socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>accept</em> 调用将 <strong>阻塞</strong> ，直到有客户端连接上来才会返回。现在，我们通过 <em>telnet</em> 命令模拟客户端连接：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">$ telnet <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span> <span class="token number">55555</span>
</code></pre>
</div><div class="cl-preview-section"><p>当客户端连上来后，<em>accept</em> 调用就返回了，返回值是一个元组。元组包含一个与客户端通讯的套接字，以及客户端的地址端口对信息：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">&lt;</span>socket<span class="token punctuation">.</span>socket fd<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> family<span class="token operator">=</span>AddressFamily<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span>SocketKind<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">,</span> proto<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> laddr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">55555</span><span class="token punctuation">)</span><span class="token punctuation">,</span> raddr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">41990</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">41990</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>如果程序还需要处理另一个监听套接字，事情就尴尬了。假设我们在 <em>s</em> 上等待客户端连接，这时 <em>accept</em> 将阻塞；就算 <em>s2</em> 套接字上来了新连接，也无法提前返回：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s2 <span class="token operator">=</span> create_listen_socket<span class="token punctuation">(</span>bind_port<span class="token operator">=</span><span class="token number">44444</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>这该怎么办呢？我们先把套接字设置成 <strong>非阻塞</strong> 状态，<em>accept</em> 就不会一直阻塞了：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>setblocking<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
  File <span class="token string">"/home/fasion/opt/python3.8.5/lib/python3.8/socket.py"</span><span class="token punctuation">,</span> line <span class="token number">292</span><span class="token punctuation">,</span> <span class="token keyword">in</span> accept
    fd<span class="token punctuation">,</span> addr <span class="token operator">=</span> self<span class="token punctuation">.</span>_accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
BlockingIOError<span class="token punctuation">:</span> <span class="token punctuation">[</span>Errno <span class="token number">11</span><span class="token punctuation">]</span> Resource temporarily unavailable
</code></pre>
</div><div class="cl-preview-section"><p>由于 <em>s</em> 套接字上没有新连接，<em>accept</em> 将抛出 <em>BlockingIOError</em> 异常，以此告知调用者。这时，我们就可以抽出身来处理 <em>s2</em> 了。如果 <em>s2</em> 也没有新连接了，我们又再次检查 <em>s</em> 。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s2<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
  File <span class="token string">"/home/fasion/opt/python3.8.5/lib/python3.8/socket.py"</span><span class="token punctuation">,</span> line <span class="token number">292</span><span class="token punctuation">,</span> <span class="token keyword">in</span> accept
    fd<span class="token punctuation">,</span> addr <span class="token operator">=</span> self<span class="token punctuation">.</span>_accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
BlockingIOError<span class="token punctuation">:</span> <span class="token punctuation">[</span>Errno <span class="token number">11</span><span class="token punctuation">]</span> Resource temporarily unavailable
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> s<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
  File <span class="token string">"/home/fasion/opt/python3.8.5/lib/python3.8/socket.py"</span><span class="token punctuation">,</span> line <span class="token number">292</span><span class="token punctuation">,</span> <span class="token keyword">in</span> accept
    fd<span class="token punctuation">,</span> addr <span class="token operator">=</span> self<span class="token punctuation">.</span>_accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
BlockingIOError<span class="token punctuation">:</span> <span class="token punctuation">[</span>Errno <span class="token number">11</span><span class="token punctuation">]</span> Resource temporarily unavailable
</code></pre>
</div><div class="cl-preview-section"><p>最终，我们将在 <em>s</em> 和 <em>s2</em> 间来回 <strong>轮询</strong> ，但轮询很浪费 <em>CPU</em> 资源！特别是套接字很多时，更是如此！如果能让内核同时关注多个套接字，当它们中有新连接达到时再通知我们就好了——这就是 <em>epoll</em> 擅长的事。</p>
</div><div class="cl-preview-section"><p>当监听套接字上有新连接时，它会产生 <strong>读事件</strong> 。因此，我们可以创建一个 <em>epoll</em> 描述符，并将 <em>s</em> 和 <em>s2</em> 注册进去，订阅 <strong>读事件</strong> ( <em>EPOLLIN</em> )：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> select
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> ep <span class="token operator">=</span> select<span class="token punctuation">.</span>epoll<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> ep<span class="token punctuation">.</span>register<span class="token punctuation">(</span>s<span class="token punctuation">.</span>fileno<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> select<span class="token punctuation">.</span>EPOLLIN<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> ep<span class="token punctuation">.</span>register<span class="token punctuation">(</span>s2<span class="token punctuation">.</span>fileno<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> select<span class="token punctuation">.</span>EPOLLIN<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>接着，我们调用 <em>poll</em> 方法，等待我们感兴趣的事件：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> events <span class="token operator">=</span> ep<span class="token punctuation">.</span>poll<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>poll</em> 将一直阻塞，直到 <em>s</em> 或 <em>s2</em> 上有新连接达到。试着连一下 <em>s2</em> ：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python">$ telnet <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span> <span class="token number">44444</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>poll</em> 立马停止阻塞，并向我们返回了一个事件列表，列表项是一个由 <strong>文件描述符</strong> 和 <strong>事件掩码</strong> 组成的元组：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> events
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">for</span> fileno<span class="token punctuation">,</span> event <span class="token keyword">in</span> events<span class="token punctuation">:</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     <span class="token keyword">print</span><span class="token punctuation">(</span>fileno<span class="token punctuation">,</span> event<span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token number">6</span> <span class="token number">1</span>
</code></pre>
</div><div class="cl-preview-section"><p>这个信息告诉我们，哪个套接字上有什么事件发生。如此一来，程序可以精准处理套接字，无须傻傻 <strong>轮询</strong> 。这就是 <em>epoll</em> 的强大能力，它让高效处理大规模套接字成为可能。</p>
</div><div class="cl-preview-section"><h2 id="调度第一个协程">调度第一个协程</h2>
</div><div class="cl-preview-section"><p>开始研究有 <em>IO</em> 操作的协程之前，我们先拿一个纯计算协程练练手。这是一个只做加法运算的协程：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token boolean">False</span><span class="token punctuation">:</span>
        <span class="token keyword">yield</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b
</code></pre>
</div><div class="cl-preview-section"><p><em>if</em> 语句永远不会执行，它只是为了引入 <em>yield</em> 语句，让 <em>Python</em> 将 <em>add</em> 编译成生成器。</p>
</div><div class="cl-preview-section"><p>现在我们创建一个新协程，并调用 <em>send</em> 方法把它调度起来：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co <span class="token operator">=</span> add<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
StopIteration<span class="token punctuation">:</span> <span class="token number">3</span>
</code></pre>
</div><div class="cl-preview-section"><p>正如前面提到的那样，协程一把梭哈到底，<em>StopIteration</em> 异常告诉我们它已经执行完毕，结果是 <em>3</em> 。注意到，协程执行结果(函数返回值)保存在 <em>StopIteration</em> 的 <em>value</em> 属性：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">import</span> sys
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> e <span class="token operator">=</span> sys<span class="token punctuation">.</span>last_value
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> e
StopIteration<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> e<span class="token punctuation">.</span>value
<span class="token number">3</span>
</code></pre>
</div><div class="cl-preview-section"><p>我们还可以写一个函数来调度协程，函数只需调用 <em>send</em> 方法，并在协程执行完毕后输出一些提示：</p>
</div><div class="cl-preview-section"><pre class=" language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">schedule_coroutine</span><span class="token punctuation">(</span>co<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">try</span><span class="token punctuation">:</span>
        co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
    <span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> e<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'coroutine {} completed with result {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>co<span class="token punctuation">.</span>__name__<span class="token punctuation">,</span> e<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><pre class=" language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co <span class="token operator">=</span> add<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> schedule_coroutine<span class="token punctuation">(</span>co<span class="token punctuation">)</span>
coroutine add completed <span class="token keyword">with</span> result <span class="token number">5</span>
</code></pre>
</div><div class="cl-preview-section"><h2 id="io上下文">IO上下文</h2>
</div><div class="cl-preview-section"><p>如果协程中涉及 <em>IO</em> 操作，则需要在 <em>IO</em> 未就绪时通过 <em>yield</em> 让出执行权。在让出执行权的同时，还需要将 <em>IO</em> 上下文提交给事件循环，由它协助处理。那么，<em>IO</em> 上下文需要包含哪些信息呢？</p>
</div><div class="cl-preview-section"><p><em>IOContext</em> 需要保存哪些信息取决于封装程度，但至少要包括协程需要等待的 <strong>文件描述符</strong> 以及感兴趣的 <strong>事件</strong> ：</p>
</div><div class="cl-preview-section"><pre class=" language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">IOContext</span><span class="token punctuation">:</span>
    
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> fileno<span class="token punctuation">,</span> events<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>fileno <span class="token operator">=</span> fileno
        self<span class="token punctuation">.</span>events <span class="token operator">=</span> events
</code></pre>
</div><div class="cl-preview-section"><p>现在我们开始编写一个带 <em>IO</em> 操作的协程，它负责从监听套接字接收新客户端连接：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">accept_client</span><span class="token punctuation">(</span>sock<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> sock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> BlockingIOError<span class="token punctuation">:</span>
            <span class="token keyword">pass</span>
        
        <span class="token keyword">yield</span> IOContext<span class="token punctuation">(</span>sock<span class="token punctuation">.</span>fileno<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> select<span class="token punctuation">.</span>EPOLLIN<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>协程主体逻辑是一个循环，它先调用 <em>accept</em> 尝试接收新连接。如果没有连接就绪，<em>accept</em> 会抛 <em>BlockingIOError</em> 异常。 这时，<em>yield</em> 语句让出执行权，并将 <em>IOContext</em> 提交给事件循环。注意到，协程对套接字上的读事件感兴趣。</p>
</div><div class="cl-preview-section"><p>现在我们创建一个这样的协程，并扮演事件循环，来体会协程调度过程。如果套接字 <em>s</em> 没有就绪连接，<em>send</em> 将收到协程返回的 <em>IOContext</em> ，表明协程期待哪些事件发生：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co <span class="token operator">=</span> accept_client<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> context <span class="token operator">=</span> co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> context
<span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>IOContext <span class="token builtin">object</span> at <span class="token number">0x7fcd58e3ef70</span><span class="token operator">&gt;</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> context<span class="token punctuation">.</span>fileno
<span class="token number">3</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> context<span class="token punctuation">.</span>events
<span class="token number">1</span>
</code></pre>
</div><div class="cl-preview-section"><p>事件循环接到上下文后，需要将当前协程保存到上下文中，并将需要订阅的事件注册到 <em>epoll</em> ：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> context<span class="token punctuation">.</span>co <span class="token operator">=</span> co
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> ep<span class="token punctuation">.</span>register<span class="token punctuation">(</span>context<span class="token punctuation">.</span>fileno<span class="token punctuation">,</span> context<span class="token punctuation">.</span>events<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>接着，事件循环在 <em>epoll</em> 上等待相关事件到达：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> ep<span class="token punctuation">.</span>poll<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>poll</em> 将保持阻塞，直到有注册事件出现。因此，用 <em>telnet</em> 命令再次连接 <em>s</em> 套接字，<em>poll</em> 将返回：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> ep<span class="token punctuation">.</span>poll<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre>
</div><div class="cl-preview-section"><p>根据 <em>p</em>oll 返回的文件描述符 <em>3</em> ，我们知道 <em>context</em> 这次 <em>IO</em> 操作已经就绪了。这时，可以接着调度对应的协程：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> context<span class="token punctuation">.</span>co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
StopIteration<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>socket<span class="token punctuation">.</span>socket fd<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> family<span class="token operator">=</span>AddressFamily<span class="token punctuation">.</span>AF_INET<span class="token punctuation">,</span> <span class="token builtin">type</span><span class="token operator">=</span>SocketKind<span class="token punctuation">.</span>SOCK_STREAM<span class="token punctuation">,</span> proto<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> laddr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">55555</span><span class="token punctuation">)</span><span class="token punctuation">,</span> raddr<span class="token operator">=</span><span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">51528</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">51528</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>至此，协程 <em>co</em> 成功接收了一个客户端连接，并退出了。</p>
</div><div class="cl-preview-section"><h2 id="yield-from">yield from</h2>
</div><div class="cl-preview-section"><p>现有一个用于计算圆面积的协程，它没有涉及 <em>IO</em> 操作：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> math

<span class="token keyword">def</span> <span class="token function">circle_area</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token boolean">False</span><span class="token punctuation">:</span>
        <span class="token keyword">yield</span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span>pi <span class="token operator">*</span> r <span class="token operator">**</span> <span class="token number">2</span>
</code></pre>
</div><div class="cl-preview-section"><p>创建一个这样的协程来计算半径为 <em>2</em> 的圆的面积，并调用 <em>send</em> 方法来调度它，协程执行完毕后将返回结果：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co <span class="token operator">=</span> circle_area<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
StopIteration<span class="token punctuation">:</span> <span class="token number">12.566370614359172</span>
</code></pre>
</div><div class="cl-preview-section"><p>现在，让我们利用这个协程来计算圆柱体积：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">cylindrical_volume</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> circle_area<span class="token punctuation">(</span>r<span class="token punctuation">)</span> <span class="token operator">*</span> h
</code></pre>
</div><div class="cl-preview-section"><p>这样显然是不行的，因为调用 <em>circle_area</em> 返回的是一个代表协程的生成器，需要调度它才能获得计算结果。不过没关系，我们可以这么写：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">cylindrical_volume</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">:</span>
    co <span class="token operator">=</span> circle_area<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            <span class="token keyword">yield</span> co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
        <span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> e<span class="token punctuation">:</span>
            floorage <span class="token operator">=</span> e<span class="token punctuation">.</span>value
            <span class="token keyword">return</span> floorage <span class="token operator">*</span> h
</code></pre>
</div><div class="cl-preview-section"><p>这个是一个协程函数，它先创建一个子协程用于计算底面积，然后用一个永久循环驱动子协程执行。</p>
</div><div class="cl-preview-section"><p>每次循环时，它先调用 <em>send</em> 方法将执行权交给子协程。如果子协程用 <em>yield</em> 语句归还执行权，这里同样用 <em>yield</em> 将执行权交给调用者，<em>yield</em> 值也一并向上传递。如果子协程退出，它将取出子协程执行结果并完成计算。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co <span class="token operator">=</span> cylindrical_volume<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
StopIteration<span class="token punctuation">:</span> <span class="token number">37.69911184307752</span>
</code></pre>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5f4f03760001751517390304.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>因此，<em>cylindrical_volume</em> 就像一个中间人，在调用者和子协程之间来回传递执行权。函数调用很常见，如果涉及协程的函数调用都需要用样板代码传递执行权，那简直就是一个噩梦！为此，<em>Python</em> 引入 <em>yield from</em> ：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">cylindrical_volume</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">:</span>
    floorage <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token keyword">from</span> circle_area<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
    <span class="token keyword">return</span> floorage <span class="token operator">*</span> h
</code></pre>
</div><div class="cl-preview-section"><p>例子中 <em>yield from</em> 的作用相当于上一例子中的 <em>while</em> 循环，因此这两个例子是完全等价的。与业务逻辑无关的样板代码消除后，新函数变得简洁纯粹，更加清晰易懂了！</p>
</div><div class="cl-preview-section"><h2 id="async-await">async await</h2>
</div><div class="cl-preview-section"><p>直接使用生成器实现协程，虽然逻辑上可行，但语义上有点令人摸不着头脑：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co <span class="token operator">=</span> circle_area<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co
<span class="token operator">&lt;</span>generator <span class="token builtin">object</span> circle_area at <span class="token number">0x10500db50</span><span class="token operator">&gt;</span>
</code></pre>
</div><div class="cl-preview-section"><p>为突显协程语义，<em>Python</em> 引入了 <em>async</em> 关键字：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">circle_area</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> math<span class="token punctuation">.</span>pi <span class="token operator">*</span> r <span class="token operator">**</span> <span class="token number">2</span>
</code></pre>
</div><div class="cl-preview-section"><p>被 <em>async</em> 关键字标识的函数会被编译成异步函数，调用后得到一个 <em>coroutine</em> 对象：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co <span class="token operator">=</span> circle_area<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co
<span class="token operator">&lt;</span>coroutine <span class="token builtin">object</span> circle_area at <span class="token number">0x1050f7050</span><span class="token operator">&gt;</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>coroutine</em> 对象与 <em>generator</em> 对象类似，我们可以调用 <em>send</em> 方法来调度 <em>coroutine</em> 对象：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
StopIteration<span class="token punctuation">:</span> <span class="token number">3.141592653589793</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>coroutine</em> 对象的语义更加准确，而且我们再也不需要在函数代码中显式编写 <em>yield</em> 语句了，这未免有点画蛇添足。</p>
</div><div class="cl-preview-section"><p>青出于蓝而胜于蓝，如果 <em>coroutine</em> 没执行完毕便被意外销毁，<em>Python</em> 将输出警告信息：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co <span class="token operator">=</span> circle_area<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> <span class="token keyword">del</span> co
__main__<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">:</span> RuntimeWarning<span class="token punctuation">:</span> coroutine <span class="token string">'circle_area'</span> was never awaited
RuntimeWarning<span class="token punctuation">:</span> Enable tracemalloc to get the <span class="token builtin">object</span> allocation traceback
</code></pre>
</div><div class="cl-preview-section"><p>此外，<em>Python</em> 还引入了 <em>await</em> 关键字，代替前面提到的 <em>yield from</em> 语句。与 <em>yield from</em> 类似，<em>await</em> 将执行权交给子协程，并等待它退出。如果子协程需要暂时归还执行权，<em>await</em> 同样承担起中间人角色，在调用者与子协程间来回接棒。</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">cylindrical_volume</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">:</span>
    floorage <span class="token operator">=</span> <span class="token keyword">await</span> circle_area<span class="token punctuation">(</span>r<span class="token punctuation">)</span>
    <span class="token keyword">return</span> floorage <span class="token operator">*</span> h
</code></pre>
</div><div class="cl-preview-section"><p>无须多言，<em>await</em> 的语义也比 <em>yield from</em> 准确。另外，<em>Python</em> 还引入了 <strong>可等待对象</strong> ( <em>awaitable</em> )。例子如下：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">class</span> <span class="token class-name">Job</span><span class="token punctuation">:</span>
    
    <span class="token keyword">def</span> <span class="token function">__await__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'step 1'</span><span class="token punctuation">)</span>
        <span class="token keyword">yield</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'step 2'</span><span class="token punctuation">)</span>
        <span class="token keyword">yield</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'step 3'</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token string">'coding-fan'</span>
</code></pre>
</div><div class="cl-preview-section"><p>可等待对象需要提供 <em>__await__</em> 魔术方法，实现成普通生成器即可。然后，<em>await</em> 就可以驱动生成器的执行：</p>
</div><div class="cl-preview-section"><pre class=" language-python"><code class="prism  language-python"><span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">do_job</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">:</span>
    value <span class="token operator">=</span> <span class="token keyword">await</span> job
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'job is done with value {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><pre class=" language-python"><code class="prism  language-python"><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co <span class="token operator">=</span> do_job<span class="token punctuation">(</span>Job<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
step <span class="token number">1</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
step <span class="token number">2</span>
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
step <span class="token number">3</span>
job <span class="token keyword">is</span> done <span class="token keyword">with</span> value coding<span class="token operator">-</span>fan
Traceback <span class="token punctuation">(</span>most recent call last<span class="token punctuation">)</span><span class="token punctuation">:</span>
  File <span class="token string">"&lt;stdin&gt;"</span><span class="token punctuation">,</span> line <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">in</span> <span class="token operator">&lt;</span>module<span class="token operator">&gt;</span>
StopIteration
</code></pre>
</div><div class="cl-preview-section"><p>如果你觉得可等待对象 <em>Job</em> 难以理解，可以将它想象成等价的 <em>yield from</em> 形式，便豁然开朗了：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">do_job</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">:</span>
    value <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token keyword">from</span> job<span class="token punctuation">.</span>__await__<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'job is done with value {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>await</em> 本无法驱动普通生成器，可等待对象却另辟蹊径，因而它在协程库中有重要作用。</p>
</div><div class="cl-preview-section"><h2 id="终极作品">终极作品</h2>
</div><div class="cl-preview-section"><p>铺垫了这么东西，终于可以亮出我们的终极作品了：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> select

<span class="token keyword">from</span> collections <span class="token keyword">import</span> deque
<span class="token keyword">from</span> socket <span class="token keyword">import</span> socket<span class="token punctuation">,</span> AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR

<span class="token keyword">def</span> <span class="token function">create_listen_socket</span><span class="token punctuation">(</span>bind_addr<span class="token operator">=</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> bind_port<span class="token operator">=</span><span class="token number">55555</span><span class="token punctuation">,</span> backlogs<span class="token operator">=</span><span class="token number">102400</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    sock <span class="token operator">=</span> socket<span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">)</span>
    sock<span class="token punctuation">.</span>setsockopt<span class="token punctuation">(</span>SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    sock<span class="token punctuation">.</span>bind<span class="token punctuation">(</span><span class="token punctuation">(</span>bind_addr<span class="token punctuation">,</span> bind_port<span class="token punctuation">)</span><span class="token punctuation">)</span>
    sock<span class="token punctuation">.</span>listen<span class="token punctuation">(</span>backlogs<span class="token punctuation">)</span>
    <span class="token keyword">return</span> sock

<span class="token keyword">class</span> <span class="token class-name">Future</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> loop<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>loop <span class="token operator">=</span> loop
        self<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">False</span>
        self<span class="token punctuation">.</span>result <span class="token operator">=</span> <span class="token boolean">None</span>
        self<span class="token punctuation">.</span>co <span class="token operator">=</span> <span class="token boolean">None</span>

    <span class="token keyword">def</span> <span class="token function">set_coroutine</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> co<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>co <span class="token operator">=</span> co

    <span class="token keyword">def</span> <span class="token function">set_result</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>done <span class="token operator">=</span> <span class="token boolean">True</span>
        self<span class="token punctuation">.</span>result <span class="token operator">=</span> result

        <span class="token keyword">if</span> self<span class="token punctuation">.</span>co<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>loop<span class="token punctuation">.</span>add_coroutine<span class="token punctuation">(</span>self<span class="token punctuation">.</span>co<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">__await__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token operator">not</span> self<span class="token punctuation">.</span>done<span class="token punctuation">:</span>
            <span class="token keyword">yield</span> self
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>result

<span class="token keyword">class</span> <span class="token class-name">AsyncSocket</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sock<span class="token punctuation">,</span> loop<span class="token punctuation">)</span><span class="token punctuation">:</span>
        sock<span class="token punctuation">.</span>setblocking<span class="token punctuation">(</span><span class="token boolean">False</span><span class="token punctuation">)</span>

        self<span class="token punctuation">.</span>sock <span class="token operator">=</span> sock
        self<span class="token punctuation">.</span>loop <span class="token operator">=</span> loop

    <span class="token keyword">def</span> <span class="token function">fileno</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>fileno<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">create_future_for_events</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> events<span class="token punctuation">)</span><span class="token punctuation">:</span>
        future <span class="token operator">=</span> self<span class="token punctuation">.</span>loop<span class="token punctuation">.</span>create_future<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">def</span> <span class="token function">handler</span><span class="token punctuation">(</span>fileno<span class="token punctuation">,</span> active_events<span class="token punctuation">)</span><span class="token punctuation">:</span>
            loop<span class="token punctuation">.</span>unregister_from_polling<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fileno<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            future<span class="token punctuation">.</span>set_result<span class="token punctuation">(</span>active_events<span class="token punctuation">)</span>

        self<span class="token punctuation">.</span>loop<span class="token punctuation">.</span>register_for_polling<span class="token punctuation">(</span>self<span class="token punctuation">.</span>fileno<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> events<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>

        <span class="token keyword">return</span> future

    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">accept</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                sock<span class="token punctuation">,</span> addr <span class="token operator">=</span> self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> AsyncSocket<span class="token punctuation">(</span>sock<span class="token operator">=</span>sock<span class="token punctuation">,</span> loop<span class="token operator">=</span>self<span class="token punctuation">.</span>loop<span class="token punctuation">)</span><span class="token punctuation">,</span> addr
            <span class="token keyword">except</span> BlockingIOError<span class="token punctuation">:</span>
                future <span class="token operator">=</span> self<span class="token punctuation">.</span>create_future_for_events<span class="token punctuation">(</span>select<span class="token punctuation">.</span>EPOLLIN<span class="token punctuation">)</span>
                <span class="token keyword">await</span> future

    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">recv</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> bufsize<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span>bufsize<span class="token punctuation">)</span>
            <span class="token keyword">except</span> BlockingIOError<span class="token punctuation">:</span>
                future <span class="token operator">=</span> self<span class="token punctuation">.</span>create_future_for_events<span class="token punctuation">(</span>select<span class="token punctuation">.</span>EPOLLIN<span class="token punctuation">)</span>
                <span class="token keyword">await</span> future

    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">send</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            <span class="token keyword">try</span><span class="token punctuation">:</span>
                <span class="token keyword">return</span> self<span class="token punctuation">.</span>sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>data<span class="token punctuation">)</span>
            <span class="token keyword">except</span> BlockingIOError<span class="token punctuation">:</span>
                future <span class="token operator">=</span> self<span class="token punctuation">.</span>create_future_for_events<span class="token punctuation">(</span>select<span class="token punctuation">.</span>EPOLLOUT<span class="token punctuation">)</span>
                <span class="token keyword">await</span> future

<span class="token keyword">class</span> <span class="token class-name">EventLoop</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>epoll <span class="token operator">=</span> select<span class="token punctuation">.</span>epoll<span class="token punctuation">(</span><span class="token punctuation">)</span>

        self<span class="token punctuation">.</span>runnables <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>handlers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">def</span> <span class="token function">create_future</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> Future<span class="token punctuation">(</span>loop<span class="token operator">=</span>self<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">create_listen_socket</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> bind_addr<span class="token punctuation">,</span> bind_port<span class="token punctuation">,</span> backlogs<span class="token operator">=</span><span class="token number">102400</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        sock <span class="token operator">=</span> create_listen_socket<span class="token punctuation">(</span>bind_addr<span class="token punctuation">,</span> bind_port<span class="token punctuation">,</span> backlogs<span class="token punctuation">)</span>
        <span class="token keyword">return</span> AsyncSocket<span class="token punctuation">(</span>sock<span class="token operator">=</span>sock<span class="token punctuation">,</span> loop<span class="token operator">=</span>loop<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">register_for_polling</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> fileno<span class="token punctuation">,</span> events<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'register fileno={} for events {}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>fileno<span class="token punctuation">,</span> events<span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>handlers<span class="token punctuation">[</span>fileno<span class="token punctuation">]</span> <span class="token operator">=</span> handler
        self<span class="token punctuation">.</span>epoll<span class="token punctuation">.</span>register<span class="token punctuation">(</span>fileno<span class="token punctuation">,</span> events<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">unregister_from_polling</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> fileno<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'unregister fileno={}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>fileno<span class="token punctuation">)</span><span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>epoll<span class="token punctuation">.</span>unregister<span class="token punctuation">(</span>fileno<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>fileno<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">add_coroutine</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> co<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>runnables<span class="token punctuation">.</span>append<span class="token punctuation">(</span>co<span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">run_coroutine</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> co<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">try</span><span class="token punctuation">:</span>
            future <span class="token operator">=</span> co<span class="token punctuation">.</span>send<span class="token punctuation">(</span><span class="token boolean">None</span><span class="token punctuation">)</span>
            future<span class="token punctuation">.</span>set_coroutine<span class="token punctuation">(</span>co<span class="token punctuation">)</span>
        <span class="token keyword">except</span> StopIteration <span class="token keyword">as</span> e<span class="token punctuation">:</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'coroutine {} stopped'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>co<span class="token punctuation">.</span>__name__<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">schedule_runnable_coroutines</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> self<span class="token punctuation">.</span>runnables<span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>run_coroutine<span class="token punctuation">(</span>co<span class="token operator">=</span>self<span class="token punctuation">.</span>runnables<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">def</span> <span class="token function">run_forever</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            self<span class="token punctuation">.</span>schedule_runnable_coroutines<span class="token punctuation">(</span><span class="token punctuation">)</span>

            events <span class="token operator">=</span> self<span class="token punctuation">.</span>epoll<span class="token punctuation">.</span>poll<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> fileno<span class="token punctuation">,</span> event <span class="token keyword">in</span> events<span class="token punctuation">:</span>
                handler <span class="token operator">=</span> self<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>get<span class="token punctuation">(</span>fileno<span class="token punctuation">)</span>
                <span class="token keyword">if</span> handler<span class="token punctuation">:</span>
                    handler<span class="token punctuation">(</span>fileno<span class="token punctuation">,</span> events<span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">TcpServer</span><span class="token punctuation">:</span>

    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> loop<span class="token punctuation">,</span> bind_addr<span class="token operator">=</span><span class="token string">'0.0.0.0'</span><span class="token punctuation">,</span> bind_port<span class="token operator">=</span><span class="token number">55555</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>loop <span class="token operator">=</span> loop
        self<span class="token punctuation">.</span>listen_sock <span class="token operator">=</span> self<span class="token punctuation">.</span>loop<span class="token punctuation">.</span>create_listen_socket<span class="token punctuation">(</span>bind_addr<span class="token operator">=</span>bind_addr<span class="token punctuation">,</span> bind_port<span class="token operator">=</span>bind_port<span class="token punctuation">)</span>
        self<span class="token punctuation">.</span>loop<span class="token punctuation">.</span>add_coroutine<span class="token punctuation">(</span>self<span class="token punctuation">.</span>serve_forever<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">serve_client</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> sock<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            data <span class="token operator">=</span> <span class="token keyword">await</span> sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span>
            <span class="token keyword">if</span> <span class="token operator">not</span> data<span class="token punctuation">:</span>
                <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'client disconnected'</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span>

            <span class="token keyword">await</span> sock<span class="token punctuation">.</span>send<span class="token punctuation">(</span>data<span class="token punctuation">.</span>upper<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">async</span> <span class="token keyword">def</span> <span class="token function">serve_forever</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
            sock<span class="token punctuation">,</span> <span class="token punctuation">(</span>addr<span class="token punctuation">,</span> port<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">await</span> self<span class="token punctuation">.</span>listen_sock<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'client connected addr={} port={}'</span><span class="token punctuation">.</span><span class="token builtin">format</span><span class="token punctuation">(</span>addr<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>

            self<span class="token punctuation">.</span>loop<span class="token punctuation">.</span>add_coroutine<span class="token punctuation">(</span>self<span class="token punctuation">.</span>serve_client<span class="token punctuation">(</span>sock<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    loop <span class="token operator">=</span> EventLoop<span class="token punctuation">(</span><span class="token punctuation">)</span>
    server <span class="token operator">=</span> TcpServer<span class="token punctuation">(</span>loop<span class="token operator">=</span>loop<span class="token punctuation">)</span>
    loop<span class="token punctuation">.</span>run_forever<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>这个程序是一个精简的协程库实现，除了用于演示的应用代码 <em>TcpServer</em> ，整个库也就 <em>100</em> 来行代码！</p>
</div><div class="cl-preview-section"><p>我们模仿常见协程库，引入 <em>Future</em> ，代表一个在未来才能获取到的数据。<em>Future</em> 一般由协程创建，典型的场景是这样的：协程在等待一个 <em>IO</em> 事件，这时它便创建一个 <em>Future</em> 对象，并把执行权归还给事件循环。</p>
</div><div class="cl-preview-section"><p>例子中的 <em>Future</em> 类，有 <em>4</em> 个重要的属性：</p>
</div><div class="cl-preview-section"><ul>
<li><em>loop</em> ，当前事件循环对象；</li>
<li><em>done</em> ，标识目标数据是否就绪；</li>
<li><em>result</em> ，目标数据；</li>
<li><em>co</em> ，关联协程，<em>Future</em> 就绪后，事件循环 <em>loop</em> 将把它放入可执行队列重新调度；</li>
</ul>
</div><div class="cl-preview-section"><p>注意到，<em>Future</em> 是一个 <strong>可等待对象</strong> ( <em>awaitable</em> )，它实现了 <em>__await__</em> 方法。当数据未就绪时，通过 <em>yield</em> 让出执行权，这时事件循环将协程记录在 <em>Future</em> 中。当数据就绪后，事件循环将协程放回可执行队列重新调度。</p>
</div><div class="cl-preview-section"><p>协程库还将套接字进行 <strong>异步化</strong> 封装，抽象出 <em>AsyncSocket</em> 类，接口与原生 <em>socket</em> 对象类似。除了保存原生 <em>socket</em> 对象，它还保存事件循环对象，以便通过事件循环订阅 <em>IO</em> 事件。</p>
</div><div class="cl-preview-section"><p><em>create_future_for_events</em> 方法创建一个 <em>Future</em> 对象，来等待一个不知何时发生的 <em>IO</em> 事件。创建完 <em>Future</em> 对象后，进一步调用 <em>loop</em> 相关方法，将感兴趣的 <em>IO</em> 事件注册到 <em>epoll</em> 。当相关事件就绪时，事件循环将执行回调函数 <em>handler</em> ，它解除 <em>epoll</em> 注册，并将活跃事件作为目标数据设置到 <em>Future</em> 上(注意 <em>set_result</em> 将唤醒协程)。</p>
</div><div class="cl-preview-section"><p>然后是套接字系列操作函数，以 <em>accept</em> 为例，它不断尝试调用原生套接字，而原生套接字已被设为非阻塞。如果套接字已就绪，<em>accept</em> 将直接返回新连接，协程无须等待。</p>
</div><div class="cl-preview-section"><p>否则，<em>accept</em> 方法抛出 <em>BlockingIOError</em> 异常。这时，协程调用 <em>create_future_for_events</em> 方法创建一个 <em>Future</em> 订阅读事件( <em>EPOLLIN</em> )，并等待事件到达。</p>
</div><div class="cl-preview-section"><p><em>recv</em> 、<em>send</em> 方法封装也是类似的，不同的是 <em>send</em> 需要订阅 <strong>可写事件</strong> ( <em>EPOLLOUT</em> )。</p>
</div><div class="cl-preview-section"><p>好了，终于来到协程库了主角事件循环 <em>EventLoop</em> 对象了，它有 <em>3</em> 个重要属性：</p>
</div><div class="cl-preview-section"><ul>
<li><em>epoll</em> ，这是一个 <em>epoll</em> 描述符，用于订阅 <em>IO</em> 事件；</li>
<li><em>runnables</em> ，可执行协程队列；</li>
<li><em>handlers</em> ，<em>IO</em> 事件回调处理函数映射表；</li>
</ul>
</div><div class="cl-preview-section"><p><em>register_for_polling</em> 方法注册感兴趣的 <em>IO</em> 事件和处理函数，它以文件描述符为键，将处理函数记录到映射表中，然后调用 <em>epoll</em> 完成事件订阅。<em>unregister_from_polling</em> 方法则刚好相反，用于取消注册。</p>
</div><div class="cl-preview-section"><p><em>add_coroutine</em> 将一个可运行的协程加入队列。<em>run_coroutine</em> 则调度一个可执行协程，它调用 <em>send</em> 将执行权交给协程。如果协程执行完毕，它将输出提示；协程需要等待时，会通过 <em>yield</em> 归还执行权并提交 <em>Future</em> 对象，它将协程记录到 <em>Future</em> 上下文。<em>schedule_runnable_coroutines</em> 将可执行协程逐个取出并调度，直到队列为空。</p>
</div><div class="cl-preview-section"><p><em>run_forever</em> 是事件循环的主体逻辑，这是一个永久循环。每次循环时，先调度可执行协程；然后通过 <em>poll</em> 等待协程注册的 <em>IO</em> 事件；当有新事件到达时，取出回调函数 <em>handler</em> 函数并调用。</p>
</div><div class="cl-preview-section"><p><em>TcpServer</em> 只是一个普通的协程式应用，无须赘述。接下来，我们逐步分析，看看程序启动后都发生什么事情：</p>
</div><div class="cl-preview-section"><ol>
<li>创建事件循环 <em>EventLoop</em> 对象，它将创建 <em>epoll</em> 描述符；</li>
<li>创建 <em>TcpServer</em> 对象，它通过事件循环 <em>loop</em> 创建监听套接字，并将 <em>serve_forever</em> 协程放入可执行队列；</li>
<li>事件循环 <em>loop.run_forever</em> 开始执行，它先调度可执行队列；</li>
<li>可执行队列一开始只有一个协程 <em>TcpServer.serve_forever</em> ，它将开始执行(由 <em>run_coroutine</em> 驱动)；</li>
<li>执行权来到 <em>TcpServer.serve_forever</em> 协程，它调用 <em>AsyncSocket.accept</em> 准备接受一个新连接；</li>
<li>假设原生套接字未就绪，它将抛出 <em>BlockingIOError</em> 异常；</li>
<li>由于 <em>IO</em> 未就绪，协程创建一个 <em>Future</em> 对象，用来等待一个未来的 <em>IO</em> 事件( <em>AsyncSocket.accept</em> )；</li>
<li>于此同时，协程调用事件循环 <em>register_for_polling</em> 方法订阅 <em>IO</em> 事件，并注册回调处理函数 <em>handler</em> ；</li>
<li><em>future</em> 是可以个可等待对象，<em>await</em> <em>future</em> 将执行权交给它的 <em>__await__</em> 函数；</li>
<li>由于一开始 <em>future</em> 是未就绪的，这时 <em>yield</em> 将协程执行逐层归还给事件循环，<em>future</em> 对象也被同时上报；</li>
<li>执行权回到事件循环，<em>run_coroutine</em> 收到协程上报的 <em>future</em> 后将协程设置进去，以便 <em>future</em> 就绪后重新调度协程；</li>
<li>可执行队列变空后，事件循环开始调用 <em>epoll.poll</em> 等待协程注册的 <em>IO</em> 事件( <em>serve_forever</em> )；</li>
<li>当注册事件到达后，事件循环取出回调处理函数并调用；</li>
<li><em>handler</em> 先将套接字从 <em>epoll</em> 解除注册，然后调用 <em>set_result</em> 将活跃事件作为目标数据记录到 <em>future</em> 中；</li>
<li><em>set_result</em> 将协程重新放回可执行队列；</li>
<li><em>IO</em> 事件处理完毕，进入下一次事件循环；</li>
<li>事件循环再次调度可执行队列，这时 <em>TcpServer.serve_forever</em> 协程再次拿到执行权；</li>
<li><em>TcpServer.serve_forever</em> 协程从 <em>yield</em> 语句恢复执行，开始返回目标数据，也就是先前设置的活跃事件；</li>
<li><em>AsyncSocket.accept</em> 内 <em>await future</em> 语句取得活跃事件，然后循环继续；</li>
<li>循环再次调用原生套接字，这时它早已就绪，得到一个新套接字，简单包装后作为结果返回给调用者；</li>
<li><em>TcpServer.serve_forever</em> 拿到代表新连接的套接字后，创建一个 <em>serve_client</em> 协程并交给事件循环 <em>loop</em> ；</li>
<li><em>TcpServer.serve_forever</em> 进入下一次循环，调用 <em>accept</em> 准备接受下一个客户端连接；</li>
<li>如果监听套接字未就绪，执行权再次回到事件循环；</li>
<li>事件循环接着调度可执行队列里面的协程，*TcpServer.*<em>serve_client</em> 协程也开始执行了；</li>
<li><em>etc</em></li>
</ol>
</div><div class="cl-preview-section"><p>这看着就像一个精密的机械装置，有条不紊的运行着，环环相扣！</p>
</div>
			
		</div>
	
	
	<div class="finish-learn">
		<p class="copyright">©版权归慕课网所有，未经许可不得转载</p>
		
		
		
		<div class="ad_pic">
			<img src="https://img1.mukewang.com/5f4f019f00011d7f06700192.jpg">
		</div>
		
		
		
		
	</div>
	<div class="comment-con">
		<h4 class="title">
			精选留言
			
				<a href="javascript: void(0);" class="add-comment js-comment-click"><i class="imwap-xieliuyan"></i><span>写留言</span></a>
			
		</h4>
		
			<ul class="comment-content">
				
				<li class="item">
					<a href="/read/commentdetail/6923">
						<img src="https://img1.mukewang.com/55d800cb00012bdb04190419-100-100.jpg" alt="" class="avatar">
						<h4 class="nickname">丨稻叶儿ooO</h4>
						<div class="comment-text">windows 环境下，代码无法跑通，好像是 epoll 是 linux 内核的机制，只支持 linux 系统，不支持 windows 系统。</div>
						<div>
							
								<div class="reply">讲师回复：对，可以转个Linux虚拟机来玩~</div>
							
						</div>
					</a>
					<p class="bottom">
						<span class="l">2020-10-08</span>
						<a href="/read/commentdetail/6923">
							<span class="icon r"><i class="imwap-comment"></i><em>1</em></span>
						</a>
						<span data-cid="6923" class="icon r js-comment-upvote "><i class="imwap-thumb_up"></i><em>0</em></span>
					</p>
				</li>
				
				<li class="item">
					<a href="/read/commentdetail/6759">
						<img src="https://img1.mukewang.com/5b8cd6570001575102000200-100-100.jpg" alt="" class="avatar">
						<h4 class="nickname">weixin_慕UI0052680</h4>
						<div class="comment-text">epoll 是怎么做到同时关注多个套子节的呢？难道不是通过轮询？如果是通过轮询，那为什么就要比自己实现的轮询更好？</div>
						<div>
							
								<div class="reply">讲师回复：epoll跟select不一样，它不是简单的轮询。epoll_ctl监控套接字时，会向套接字注册一个回调函数。当套接字有事件发生时，会调用该回调函数，回调函数将套接字放入就绪队列。epoll_wait只需阻塞在就绪队列上，当队列不为空时，将事件取出并返回给进程。退一步讲，就算采用基于轮询的select，性能也比自己在用户空间轮询要好。因为在内核空间不断轮询多个套接字，无须在用户态和内核态间来回切换。而在用户空间轮询套接字，每个send/recv系统调用都需要来回切换一次。</div>
							
						</div>
					</a>
					<p class="bottom">
						<span class="l">2020-09-10</span>
						<a href="/read/commentdetail/6759">
							<span class="icon r"><i class="imwap-comment"></i><em>1</em></span>
						</a>
						<span data-cid="6759" class="icon r js-comment-upvote "><i class="imwap-thumb_up"></i><em>2</em></span>
					</p>
				</li>
				
			</ul>
			
		
	</div>
	
	

	
		
	
	
	
		<div class="bottom-con">
			
			
				<div class="inner">
					
						<div class="price-con js-price-con">
							<span class="now">￥68.00</span>
						</div>
							
					
					
					<a class="gobuy js-gobuy" href="//m.imooc.com/account/login?backurl=//m.imooc.com/confirmorder?type=30&typeid=76">
					
						立即购买
					</a>  
				</div>
			
		</div>
	
	<div class="layer-catalog js-layer-catalog hide">
		<div class="layer-title clearfix">
			<div class="l">
				课程目录
			</div>
			
		</div>
		<div class="layer-wrap">
			<div class="js-catalog-container">
			</div>
		</div>
	</div>
	<div class="layer-comment">
		<div class="inner">
			<h5>
				<span class="btn l js-cancel-comment">取消</span>
				评论
				<span class="btn r js-send-comment">发送</span>
			</h5>
			<textarea id="comment-txt" maxlength="20000" placeholder="欢迎在这里发表留言，作者筛选后可公开显示"></textarea>
		</div>
	</div>


            </div>
        </div>
        
            
         
        
        
        
        




<script>
	// 设置字号大小及选中
	(function() {
			var fs = window.localStorage.getItem('font-size') || 'normal';
			var $c = document.querySelector('#middle>.content');
			var $points = document.querySelectorAll('.setting-box .point');
			try{
				// 抢读完了时 该元素不渲染 会有报错
				$c.className = 'content ' + fs;
				for(var i = 0; i < $points.length; i++) {
					if($points[i].className.indexOf(fs) > -1) {
						$points[i].className = $points[i].className + ' current';
					}
				}
			} catch(e) {}
			
	})();
</script>

<script type="text/javascript">
	window.onload = function() {
			zhuge.track('LearnCourse', {
					'Category': '专栏',
					'Name': '39 再造轮子：手把手教你设计协程库',
					'CID': '1935',
					'Teacher': 'fasionchan'
			});
	}
</script>

        
            <script type="text/javascript">
                var shareData = { 
                    title:  "39 再造轮子：手把手教你设计协程库",
                    desc: "突破技术瓶颈，迈向更高岗位",
                    imgUrl: 'https:https://img3.mukewang.com/5eb68ab400017cda05400720.jpg',
                    otherImgUrl: 'https://img3.mukewang.com/5eb68ab400017cda05400720.jpg',
                    text: '我正在参加@慕课网的课程，很不错哦！快来一起学习吧！',
                    // url: 'https://www.imooc.com' + window.location.pathname + window.location.search
                    url: 'https://m.imooc.com/read/76',
                    link: 'https://m.imooc.com/read/76'
                }
            </script>
            
        
        <div style="display:none;">
            <!-- 百度统计 -->
            <script>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?c92536284537e1806a07ef3e6873f2b3";
              var s = document.getElementsByTagName("script")[0];
              s.parentNode.insertBefore(hm, s);
            })();
            </script>

            <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
            </script>
        </div>
        
    <script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/zhugeio/init_f9752c3.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/jquery-2.1.0.min_ac9f840.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/common_84429c0.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/juicer/juicer.min_8643248.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/previewImage/previewImage.min_43b970d.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/msg_bed8d10.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/read/7.2.8/article_30e5762.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/course/advertisementReport_6e58a98.js"></script></body>
</html>
