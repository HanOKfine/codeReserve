<!doctype html>
<html lang="zh_CN">

    

    

    
    
    
    <head>
        
        <title>26 React Hooks 原理与最佳实践</title>
        
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="前端进阶必备，未来少走弯路">
        <meta name="keywords" content="慕课网">
        <meta name="author" content="">
        <meta name = "format-detection" content="telephone=no">
        <meta http-equiv="Cache-Control" content="no-transform " />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <link rel="shortcut icon" href="https://m.imooc.com/static/wap/static/favicon.ico" />
        
        
        
        <script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/flexible.js"></script>
        
        <script type="text/javascript">
            var userInfo = "";
            
                var isApp = 0;
            
        </script>
         
<!-- 专栏首页列表模板 -->
<script type="text/template" id="index-list-tpl">
<ul class="list-con">
    {@each data.data as item}
        <li>
            <a href="/read/${item.id}" class="item clearfix">
                <div class="img l" style="background-image: url(${item.app_pic1})">
                    {@if item.is_new }
                        <div class="icon new">
                            上新
                        </div>
                    {@else if item.is_marking} 
                        <div class="icon">
                            经典
                        </div>
                    {@/if} 
                </div>
                <div class="text-con l">
                    <div class="title">
                        ${item.title}
                    </div>
                    <div class="desc">
                        ${item.chapter_num}节 · ${item.description}
                    </div>
                     <div class="user-info">
                        ${item.nickname}
                        {@if item.author_title }
                        <span class="dot">
                            ·
                        </span>
                        ${item.author_title}
                        {@/if}
                    </div>
                    <div class="info clearfix">
                    {@if !item.isBuy } 
                        <!-- 未购买才显示 -->
                        <div class="price-con l">
                        {@if item.open_discount == "1" }
                            <span class="now">￥${item.pay_price}</span>
                            <span class="ori">￥${item.price}</span>
                            <p class="sale">${item.discount_name}</p>
                        {@else}
                            <span class="now">￥${item.price}</span>
                        {@/if}
                        </div>
                    {@/if}
                        <div class="taste-con r">
                            <span>${item.numbers}人订阅</span>
                            {@if !item.isBuy }
                                <span class="gotaste">试读</span>
                            {@else}
                                <span class="gotaste">学习</span>
                            {@/if}
                        </div>
                    </div>
                </div>
            </a>
        </li>
    {@/each}
</ul>
</script>



<!-- 专栏目录 买后目录页、 -->
<script type="text/template" id="detail-catalog-tpl">
<ul class="catalog-list">
{@each data.list as item}
    <li class="zhang">
        {@if data.structure_mode == "1" }
            <!--章节模式-->
            <div class="zhang-title">
                ${item.title}（${item.count}节）
            </div>
            <div class="zhang-sub-title">
                ${item.short_introduce}
            </div>
        {@/if}  
        <ul class="zhang-detail">
            {@each item.list as it,i}
                <li class="jie">
                    {@if data.isLogin }
                        <!-- 购买了  -->
                        {@if data.isBuy }
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read">
                        {@else}
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read" >
                        {@/if}
                    {@else}
                        <!-- 未登录  -->
                        {@if data.isApp }
                            <a href="javascript:;" onclick="window.nativeSupport.login();">
                        {@else}
                            <a href="//m.imooc.com/account/login?backurl=/read/${data.column_id}">
                        {@/if}
                    {@/if}
                        <div class="jie-con {@if data.last_chapter == it.id }recent{@/if}">
                            
                            <div class="text-con">
                                <div class="jie-title">
                                    ${it.title}
                                </div>
                                <div class="jie-status">
                                    {@if it.is_open == "0" }
                                        <span class="update-time" >${it.open_time_fmt}</span>
                                    {@/if}
                                    {@if it.view_num > 100 }
                                    <div class="learn-num">
                                        <i class="imwap-set-sns"></i>
                                        <span>${it.view_num}</span>
                                    </div>
                                    {@/if}
                                    {@if it.in_24hours == "1" }
                                        <span class="update-recent">最近更新</span>
                                    {@/if}
                                </div>
                            </div>
                        </div>
                        {@if it.is_learned }
                            <div class="jie-right haslearn is_learned js-learn" data-type="1">
                                已学
                            </div>
                        {@else}
                            <!-- 购买了  -->
                            {@if data.isBuy }
                                <div class="jie-right learn js-learn" data-type="1">
                                    学习
                                </div>
                            {@else}
                                {@if it.is_pay == "0" }
                                <!--免费小节 不占用试读次数  -->
                                    <div class="jie-right learn js-learn" data-type="1">
                                        免费
                                    </div>
                                {@else}
                                    <div class="jie-right learn js-learn" data-type="0">
                                        学习
                                    </div>
                                {@/if}
                            {@/if}
                            
                            
                        {@/if}
                    </a>
                </li>
            {@/each}
        </ul>
    </li>
{@/each}
</ul>
</script> 

<!-- 阅读页 阅读页   专栏目录  -->
<script type="text/template" id="catalog-tpl">
<div>
    <h2 class="article-title">${data.a_name}</h2>
    <ul class="catalog">
    {@each data.list as item}
        <li class="zhang">
            {@if data.structure_mode == "1" }
                <!--章节模式-->
                <div class="zhang-title">
                    ${item.title}
                    <!-- <div class="num">共${item.count}节</div> -->
                </div>
            {@/if}  
            <ul class="zhang-detail">
                {@each item.list as it,i}
                    <li class="jie">
                        <!--买了且开放的-->
                        <a href="/read/${data.column_id}/article/${it.id}">
                            <div class="jie-title clearfix full">
                                <p>
                                    {@if data.last_chapter == it.id }
                                        <span class="recent">最近阅读</span>
                                    {@/if}
                                    ${it.title}
                                </p>
                            </div>
                        </a>
                    </li>
                {@/each}
            </ul>
        </li>
    {@/each}
    </ul>
</div>
</script>





<script type="text/javascript">
	var isApp = "";
	var clientVersion = "0";
	var count_num = "0";
	var chapter_id = "1677";
	var chapter_title = "26 React Hooks 原理与最佳实践";
	var aid = "72";
	var a_name = "Web前端开发修炼指南";
	var a_price = "58.00";
	var a_pic = "https://img3.mukewang.com/5e6af0f50001b61d05400720.jpg";
	var userId = 0;

	var column_id = '72';
	var isLogin = 0;
	

</script>
<!-- 引入字体 -->
<script type="text/javascript" src="//cdn.webfont.youziku.com/wwwroot/js/wf/youziku.api.min.js"></script>
<script type="text/javascript">
$youziku.load(".top-con .title, .cl-preview-section h1,.cl-preview-section h2,.cl-preview-section h3,.cl-preview-section h4,.cl-preview-section h5,.cl-preview-section h6", "37af461390fa4d138f5c3d277f7286dc", "SourceHanSerifSC-Heavy"); // 思源宋体heavy
$youziku.load(".lead-motto, .cl-preview-section blockquote", "d9a0d855583142c3b2cc3bf1646a8473", "SourceHanSerifSC-Regular"); // 思源宋体regular
$youziku.load("#article_content, .cl-preview-section pre, .cl-preview-section code, #code-copy", "3d84aabcf9e44b6f8c6fa91c61fa926e", "HYQiHei-55S"); // 汉仪旗黑55s
$youziku.load(".cl-preview-section strong", "fd94fff3a17546a28913a79613bddcec", "HYQiHei-77S"); // 汉仪旗黑70s

$youziku.draw();
</script>

<style type="text/css">
  header{
    display: none!important;
  }
  
  #wrapper{
  	padding-top:0px !important;
  }
  
</style>



    <link rel="stylesheet" href="https://m.imooc.com/static/wap/static/common/css/common_d42b1ef.css" /><link rel="stylesheet" href="https://m.imooc.com/static/wap/static/css/read/7.2.8/article_2d28313.css" /></head>
    <body >
        
          
        

        
          
        

        
          







<header class="directory2">
	<div class="header clearfix">
		
			
				<div class="page-title clearfix">
					<a href="//m.imooc.com" class="imwap-icon-imooc"></a>
					<div class="page-title-name js-page-name">
						<span>专栏</span>
						<i class="imwap-arrow_d"></i>
					</div>
				</div>
			

			
			<div class="drawer-box js-drawer-more">
				<i class="imwap-more_vert"></i>
				<div class="drawer-content js-drawer-content">
					<p class="line-row"></p>
					<a class="drawer-item" href="//m.imooc.com"><i class="imwap-center"></i>回到首页</a>
					<a class="drawer-item" href="//www.imooc.com/m/web/user/usercenter.html"><i class="imwap-peaple"></i>个人中心</a>
					<a class="drawer-item" href="//m.imooc.com/feedback"><i class="imwap-comment"></i>反馈问题</a>
					
					<a class="drawer-item" href="//m.imooc.com/account/login"><i class="imwap-out"></i>注册登录</a>
					
				</div>
			</div>
			

			
				<a id="js-appload" href="Javascript:;" class="app-load"><span>下载APP</span></a>
			

		
	</div>
	
	<div class="page-tab-wrap">
		<div class="page-tab-list">
			<a href="//m.imooc.com" class="page-tab-item">首页</a>
			<a href="//m.imooc.com/course/list" class="page-tab-item">课程</a>
			<a href="//coding.m.imooc.com" class="page-tab-item">实战</a>
			<a href="//class.m.imooc.com" class="page-tab-item">金职位</a>
			<a href="//m.imooc.com/article" class="page-tab-item">手记</a>
			<a href="//m.imooc.com/read" class="page-tab-item active">专栏</a>
			<a href="//m.imooc.com/wenda" class="page-tab-item">猿问</a>
			<a href="//m.imooc.com/wiki" class="page-tab-item">慕课教程</a>
			
		</div>
	</div>
	
</header>


        

        <div id="wrapper">
            <div id="middle" class="container ">

                

                
	
		
	
	<div class="top-con">
		<p class="update-time"><span>2020-05-11&nbsp;&nbsp;&nbsp;更新</span></p>
		<div class="title">
			26 React Hooks 原理与最佳实践
		</div>
	</div>
	
		<div class="article-img" style="background-image: url('https://img.mukewang.com/5eb8b6c70001e87a06400359.jpg')"></div>
	
	
		<a href="/read/72">
			<div class="course-entry">
				<img src="https://img3.mukewang.com/5e6c7ecc00012eaa10000884-40-40.jpg" alt="sh22n">
				<h3>Web前端开发修炼指南</h3>
				<p>sh22n · 前携程高级前端工程师</p>
				<i class="imwap-arrow_r"></i>
			</div>
		</a>
	
	
		<div class="lead-motto">
			<div class="content">世界上最宽阔的是海洋，比海洋更宽阔的是天空，比天空更宽阔的是人的胸怀。<p class="author">——雨果</p></div>
		</div>
	
	
		<div class="content" id="article_content">
			
			<div class="cl-preview-section"><h2 id="前言">1. 前言</h2>
</div><div class="cl-preview-section"><p>React Hooks 是 React 16.8 引入的新特性，允许我们在不使用 Class 的前提下使用 state 和其他特性。<br>
React Hooks 要解决的问题是状态共享，是继 render-props 和 higher-order components 之后的第三种状态逻辑复用方案，不会产生 JSX 嵌套地狱问题。</p>
</div><div class="cl-preview-section"><h2 id="状态逻辑复用">2. 状态逻辑复用</h2>
</div><div class="cl-preview-section"><p>一般来说，组件是 UI 和逻辑，但是逻辑这一层面却很难复用。对用户而言，组件就像一个黑盒，我们应该拿来即用。</p>
</div><div class="cl-preview-section"><p>但当组件的样式或者结构不满足需求的时候，我们只能去重新实现这个组件。</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/vwz9xje6u2v1f81peabrfmdq/image_1e3u5c2lfjin1v3cmj3bfs1gp5m.png" alt="image_1e3u5c2lfjin1v3cmj3bfs1gp5m.png-44.4kB"></p>
</div><div class="cl-preview-section"><p>在我们开发 React 应用的时候，经常会遇到类似下面这种场景，你可能会有两个疑问：</p>
</div><div class="cl-preview-section"><ol>
<li>Loading 是否可以复用？</li>
<li>Loading 该怎么复用？</li>
</ol>
</div><div class="cl-preview-section"><pre><code>const Button = ({ isLoading }) =&gt; {
    return (
        &lt;&gt;
            { isLoading &amp;&amp; &lt;p&gt;加载中...&lt;/p&gt; }
            &lt;button&gt;&lt;/button&gt;
    )
}
const Table = ({ isLoading }) =&gt; {
    return (
        &lt;&gt;
            { isLoading &amp;&amp; &lt;p&gt;加载中...&lt;/p&gt; }
            &lt;table&gt;&lt;/table&gt;
    )
}
const List = ({ isLoading }) =&gt; {
    return (
        &lt;&gt;
            { isLoading &amp;&amp; &lt;p&gt;加载中...&lt;/p&gt; }
            &lt;ul&gt;&lt;/ul&gt;
    )
}
</code></pre>
</div><div class="cl-preview-section"><p>这几个例子都指向了同一个问题，那就是如何实现组件的逻辑复用？</p>
</div><div class="cl-preview-section"><h3 id="render-props">2.1 render props</h3>
</div><div class="cl-preview-section"><p>将函数作为 props 传给父组件，父组件中的状态共享，通过参数传给函数，实现渲染，这就是 <code>render props</code>。<br>
使用 <code>render prop</code> 的库有 React Router、Downshift 以及 Formik。<br>
以下面这个 Toggle 组件为例子，我们一般可以这样用：</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function App() {
    return (
        &lt;Toggle initial={false}&gt;
            {({ on, toggle }) =&gt; (
                &lt;&gt;
                    &lt;Button type="primary" onClick={toggle}&gt; Open Modal &lt;/Button&gt;
                    &lt;Modal visible={on} onOk={toggle} onCancel={toggle}/&gt;
                &lt;/&gt;
            )}
        &lt;/Toggle&gt;
    )
}
</code></pre>
</div><div class="cl-preview-section"><p>可以看到，控制 Modal 组件是否展示的状态被提取到了 Toggle 组件中，这个 Toggle 组件还可以拿来多次复用到其他组件里面。</p>
</div><div class="cl-preview-section"><p>那么这个 Toggle 是怎么实现的呢？看到实现后你就会理解 <code>render props</code> 的原理。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">class Toggle extends Component {
    constructor(props) {
        this.state = {
            on: props.initial
        }
    }
    toggle = () =&gt; {
        this.setState({
            on: !this.state.on
        })
    }
    render() {
        return this.props.children({
            on: this.state.on,
            toggle: this.toggle
        })
    }
}
</code></pre>
</div><div class="cl-preview-section"><p>关于 <code>render props</code> 的更多内容可以参考 React 中文网的相关章节：<a href="https://zh-hans.reactjs.org/docs/render-props.html">Render Props<br>
</a></p>
</div><div class="cl-preview-section"><h3 id="higher-order-components">2.2 higher-order components</h3>
</div><div class="cl-preview-section"><p>higher-order components 一般简称 hoc，中文翻译为高阶组件。从名字上就可以看出来，高阶组件肯定和高阶函数有什么千丝万缕的关系。<br>
高阶组件的本质是一个高阶函数，它接收一个组件，返回一个新的组件。在这个新的组件中的状态共享，通过 props 传给原来的组件。<br>
以刚刚那个 Toggle 组件为例子，高阶组件同样可以被多次复用，常常可以配合装饰器一起使用。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">@Toggle(false)
class App extends Component {
    const { on, toggle } = this.props;
    return (
        &lt;&gt;
            &lt;Button type="primary" onClick={toggle}&gt; Open Modal &lt;/Button&gt;
            &lt;Modal visible={on} onOk={toggle} onCancel={toggle}/&gt;
        &lt;/&gt;
    )
}
</code></pre>
</div><div class="cl-preview-section"><p>高阶组件的实现和 <code>render props</code> 也不太一样，主要是一个高阶函数。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">const Toggle = initial =&gt; WrappedComponent =&gt; {
    return class extends Component {
        constructor(props) {
            this.state = {
                on: props.initial
            }
        }
        toggle = () =&gt; {
            this.setState({
                on: !this.state.on
            })
        }
        render() {
            const newProps = {
                ...this.props,
                on: this.state.on,
                toggle: this.toggle
            }
            return &lt;WrappedComponent ...newProps /&gt;
        }
    }
}
</code></pre>
</div><div class="cl-preview-section"><h3 id="render-props-和高阶组件的弊端">2.3 render props 和高阶组件的弊端</h3>
</div><div class="cl-preview-section"><p>不管是 render props 还是高阶组件，他们要做的都是实现状态逻辑的复用，可这俩是完美的解决方案吗？<br>
考虑一下，如果我们依赖了多个需要复用的状态逻辑的时候，该怎么写呢？以 render props 为例：</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function MyForm() {
    return (
        &lt;Fetcher&gt;
            {data =&gt; (
                &lt;Actions&gt;
                    {actions =&gt; (
                        &lt;Translations&gt; 
                            {translations =&gt; (
                                &lt;Style&gt;
                                    {styles =&gt; (
                                        // ...
                                    )}
                                &lt;/Style&gt;
                            )}
                        &lt;/Translations&gt;
                    )}
                &lt;/Actions&gt;
            )}
        &lt;/Fetcher&gt;
    )
}
</code></pre>
</div><div class="cl-preview-section"><p>看看这个代码，你有没有一种似曾相识的感觉？这一天，我们终于想起被“回调地狱”支配的恐惧。<br>
不得不再次祭出这张图了。</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/9y38p6w51x5qqqqdac2ubtgy/image_1e7vdnoh01696i186qif8minn13.png" alt="image_1e7vdnoh01696i186qif8minn13.png-139.4kB"></p>
</div><div class="cl-preview-section"><p>同样地，高阶组件也会有这个问题，但由于装饰器的简洁性，没有 render props 看起来那么可怕。<br>
除此之外，他们俩还有另一个问题，那就是组件嵌套过深之后，会给调试带来很大的麻烦。<br>
这个是 render props 中组件嵌套在 React 开发者工具中的表现。</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/g2ym5re5m0xvxlsqat7o7l9b/image_1e3u98kich8210e41ct117qffqt1g.png" alt="image_1e3u98kich8210e41ct117qffqt1g.png-47.2kB"></p>
</div><div class="cl-preview-section"><p>对于高阶组件来说，如果你没有对组件手动设置 <code>name/displayName</code>，就会遇到更严重的问题，那就是一个个匿名组件嵌套。毕竟上面 render props 的嵌套至少能知道组件名。</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/gkj4q9s2z32gx3hm2f8dl044/image.png" alt="image.png-101.1kB"></p>
</div><div class="cl-preview-section"><p>社区里面也已经有很多解决 render props 嵌套的方案，其中 Epitath 提供了一种以 generator 的方法来解决嵌套问题，利用 generator 实现了伪同步代码。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">const App = epitath(function*() {
  const { count } = yield &lt;Counter /&gt;
  const { on } = yield &lt;Toggle /&gt;

  return (
    &lt;MyComponent counter={count} toggle={on} /&gt;
  )
})

&lt;App /&gt;
</code></pre>
</div><div class="cl-preview-section"><p>更多细节可以参考黄子毅的这篇文章：<a href="https://segmentfault.com/a/1190000016682454">精读《Epitath 源码 - renderProps 新用法》</a></p>
</div><div class="cl-preview-section"><h3 id="react-hooks">2.4 React Hooks</h3>
</div><div class="cl-preview-section"><p>React Hooks 则可以完美解决上面的嵌套问题，它拥有下面这几个特性。</p>
</div><div class="cl-preview-section"><ol>
<li>多个状态不会产生嵌套，写法还是平铺的；</li>
<li>允许函数组件使用 state 和部分生命周期；</li>
<li>更容易将组件的 UI 与状态分离。</li>
</ol>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function useWindowWidth(){
    const [width, setWidth] = useState(window.innerWidth);

    useEffect(() =&gt; {
        const handleResize = ()=&gt;{
            setWidth(window.innerWidth);
        }
        window.addEventListener('resize', handleResize);
        return () =&gt; {
            window.removeEventListener('resize', handleResize);
        }
    }, [width]); 

    return width;
}
</code></pre>
</div><div class="cl-preview-section"><p>上面是一个结合了 useState 和 useEffect 两个 hook 方法的例子，主要是在 resize 事件触发时获取到当前的 <code>window.innerWidth</code>。这个 useWindowWidth 方法可以拿来在多个地方使用。<br>
常用的 Hook 方法如下：</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/6re1qc38j6omnyxmhw3urz1h/image_1e3ubtm4c10eijcbtrhjf31aj534.png" alt="image_1e3ubtm4c10eijcbtrhjf31aj534.png-55.3kB"></p>
</div><div class="cl-preview-section"><h2 id="usestate--useref">3. useState &amp; useRef</h2>
</div><div class="cl-preview-section"><p>useState 是 React Hooks 中很基本的一个 API，它的用法主要有这几种：</p>
</div><div class="cl-preview-section"><ol>
<li>useState 接收一个初始值，返回一个数组，数组里面分别是当前值和修改这个值的方法（类似 state 和 setState）；</li>
<li>useState 接收一个函数，返回一个数组；</li>
<li>setCount 可以接收新值，也可以接收一个返回新值的函数。</li>
</ol>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">const [ count1, setCount1 ] = useState(0);
const [ count2, setCount2 ] = useState(() =&gt; 0);
setCount1(1); // 修改 state
</code></pre>
</div><div class="cl-preview-section"><h3 id="和-class-state-的区别">3.1 和 class state 的区别</h3>
</div><div class="cl-preview-section"><p>虽然函数组件也有了 state，但是 function state 和 class state 还是有一些差异：</p>
</div><div class="cl-preview-section"><ol>
<li>function state 的粒度更细，class state 过于无脑；</li>
<li>function state 保存的是快照，class state 保存的是最新值；</li>
<li>引用类型的情况下，class state 不需要传入新的引用，而 function state 必须保证是个新的引用。</li>
</ol>
</div><div class="cl-preview-section"><h3 id="快照（闭包）-vs-最新值（引用）">3.2 快照（闭包） vs 最新值（引用）</h3>
</div><div class="cl-preview-section"><p>在开始前，先抛出这么一个问题。在 1s 内频繁点击10次按钮，下面代码的执行表现是什么？</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">class App extends Component {
    state = {
        count: 0
    }
    increment = () =&gt; {
        setTimeout(() =&gt; {
            this.setState({
                count: this.state.count + 1
            })
        }, 1000)
    }
    render() {
        return &lt;h1 onClick={this.increment}&gt;{this.state.count}&lt;/h1&gt;
    }
}
</code></pre>
</div><div class="cl-preview-section"><p>如果是这段代码呢？它又会是什么表现？</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function App() {
    const [ count, setCount ] = useState(0)
    const increment = () =&gt; {
        setTimeout(() =&gt; {
            setCount(count + 1)
        }, 1000)
    }
    return &lt;h1 onClick={increment}&gt;{count}&lt;/h1&gt;
}
</code></pre>
</div><div class="cl-preview-section"><p>如果你能成功答对，那么恭喜你，你已经掌握了 useState 的用法。</p>
</div><div class="cl-preview-section"><p>在第一个例子中，连续点击十次，页面上的数字会从 0 增长到 10。而第二个例子中，连续点击十次，页面上的数字只会从 0 增长到 1。</p>
</div><div class="cl-preview-section"><p>这个是为什么呢？其实这主要是引用和闭包的区别。</p>
</div><div class="cl-preview-section"><p>class 组件里面可以通过 this.state 引用到 count，所以每次 setTimeout 的时候都能通过引用拿到上一次的最新 count，所以点击多少次最后就加了多少。</p>
</div><div class="cl-preview-section"><p>在 function component 里面每次更新都是重新执行当前函数，也就是说 setTimeout 里面读取到的 count 是通过闭包获取的，而这个 count 实际上只是初始值，并不是上次执行完成后的最新值，所以最后只加了 1 次。</p>
</div><div class="cl-preview-section"><h3 id="快照和引用的转换">3.3 快照和引用的转换</h3>
</div><div class="cl-preview-section"><p>如果我想让函数组件也是从 0 加到 10，那么该怎么来解决呢？聪明的你一定会想到，如果模仿类组件里面的 <code>this.state</code>，我们用一个引用来保存 count 不就好了吗？</p>
</div><div class="cl-preview-section"><p>没错，这样是可以解决，只是这个引用该怎么写呢？我在 state 里面设置一个对象好不好？就像下面这样：</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">const [state, setState] = useState({ count: 0 }) 
</code></pre>
</div><div class="cl-preview-section"><p>答案是不行，因为即使 state 是个对象，但每次更新的时候，要传一个新的引用进去，这样的引用依然是没有意义。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">setState({
    count: state.count + 1
})
</code></pre>
</div><div class="cl-preview-section"><h3 id="useref">3.3 useRef</h3>
</div><div class="cl-preview-section"><p>想要解决这个问题，那就涉及到另一个新的 Hook 方法 —— useRef。<br>
useRef 是一个对象，它拥有一个 current 属性，并且不管函数组件执行多少次，而 useRef 返回的对象永远都是原来那一个。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function App() {
    const [ count, setCount ] = useState(0)
    const ref = useRef(0)
    const increment = () =&gt; {
        setTimeout(() =&gt; {
            setCount((ref.current += 1))
        }, 1000)
    }
    return &lt;h1 onClick={increment}&gt;{count}&lt;/h1&gt;
}
</code></pre>
</div><div class="cl-preview-section"><p><strong>useRef 有下面这几个特点：</strong></p>
</div><div class="cl-preview-section"><ol>
<li><code>useRef</code> 是一个只能用于函数组件的方法；</li>
<li><code>useRef</code> 是除字符串 <code>ref</code>、函数 <code>ref</code>、<code>createRef</code> 之外的第四种获取 <code>ref</code> 的方法；</li>
<li><code>useRef</code> 在渲染周期内永远不会变，因此可以用来引用某些数据；</li>
<li>修改 <code>ref.current</code> 不会引发组件重新渲染。</li>
</ol>
</div><div class="cl-preview-section"><p><strong>useRef vs createRef：</strong></p>
</div><div class="cl-preview-section"><ol>
<li>两者都是获取 ref 的方式，都有一个 current 属性；</li>
<li>useRef 只能用于函数组件，createRef 可以用在类组件中；</li>
<li>useRef 在每次重新渲染后都保持不变，而 createRef 每次都会发生变化。</li>
</ol>
</div><div class="cl-preview-section"><h3 id="写需求遇到的坑">3.4 写需求遇到的坑</h3>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/sm011g2hac1t161109c5ha70/image.png" alt="image.png-105.5kB"></p>
</div><div class="cl-preview-section"><p>之前在写需求的时候遇到过这样的一个坑。<code>bankId</code> 和 <code>ref</code> 都是从接口获取到的，这里很自然就想到在 <code>useCallback</code> 里面指定依赖。</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/uo231to10du2j1kmu0xhgu6i/image.png" alt="image.png-222.8kB"></p>
</div><div class="cl-preview-section"><p>但是呢，这个 <code>handlerReappear</code> 方法需要在第一次进入页面的时候，向 JS Bridge 注册的事件，这就导致了一个问题，不管后来 <code>handlerReappear</code> 如何变化，<code>registerHandler</code> 里面依赖的 <code>callback</code> 都是第一次的，这也是闭包导致的问题。<br>
当然，你可能会说，我在 <code>useEffect</code> 里面也指定了依赖不好吗？但要注意这是个注册事件，意味着每次我都要清除上一次的事件，需要调用到 JS Bridge，在性能上肯定不是个好办法。</p>
</div><div class="cl-preview-section"><p>最终，我选择使用 <code>useRef</code> 来保存 <code>bankId</code> 和 <code>ref</code>，这样就可以通过引用来获取到最新的值。</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/qnxtfuqq88gvsjk6oyufsn8x/image.png" alt="image.png-326.7kB"></p>
</div><div class="cl-preview-section"><h3 id="vue3-composition-api">3.5 Vue3 Composition API</h3>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/0v8617tcgfvdh60quel7oj5n/image.png" alt="image.png-280.6kB"></p>
</div><div class="cl-preview-section"><p>在 vue3 里面提供了新的 Composition API，之前知乎有个问题是 <a href="https://www.zhihu.com/question/378861485">React Hooks 是否可以改为用类似 Vue 3 Composition API 的方式实现？</a></p>
</div><div class="cl-preview-section"><p>然后我写了一篇文章，利用 <code>Object.defineProperty</code> 简单实现了 Composition API，可以参考：<a href="https://zhuanlan.zhihu.com/p/122516099">用 React Hooks 简单实现 Vue3 Composition API</a></p>
</div><div class="cl-preview-section"><p>当然这个实现还有很多问题，也比较简单，可以参考工业聚写的完整实现：<a href="https://github.com/Lucifier129/react-use-setup">react-use-setup</a>。</p>
</div><div class="cl-preview-section"><h2 id="useeffect">4. useEffect</h2>
</div><div class="cl-preview-section"><p><code>useEffect</code> 是一个 <code>Effect Hook</code>，常用于一些副作用的操作，在一定程度上可以充当 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code> 这三个生命周期。</p>
</div><div class="cl-preview-section"><p><code>useEffect</code> 是非常重要的一个方法，可以说是 React Hooks 的灵魂，它用法主要有这么几种：</p>
</div><div class="cl-preview-section"><ol>
<li><code>useEffect</code> 接收两个参数，分别是要执行的回调函数、依赖数组；</li>
<li>如果依赖数组为空数组，那么回调函数会在第一次渲染结束后（<code>componentDidMount</code>）执行，返回的函数会在组件卸载时（<code>componentWillUnmount</code>）执行；</li>
<li>如果不传依赖数组，那么回调函数会在每一次渲染结束后（<code>componentDidMount</code> 和 <code>componentDidUpdate</code>）执行；</li>
<li>如果依赖数组不为空数组，那么回调函数会在依赖值每次更新渲染结束后（componentDidUpdate）执行，这个依赖值一般是 state 或者 props。</li>
</ol>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function App() {
    useEffect(() =&gt; {
        // 第一次��染结束执行
        const handleScroll = () =&gt; {}
        window.addEventListener("scoll", handleScroll);
        return () =&gt; {
            // 组件卸载之前执行
            window.removeEventListener("scoll", handleScroll);
        }
    }, []);
    
    useEffect(() =&gt; {
        console.log("每次渲染结束都会执行")
    })
    
    useEffect(() =&gt; {
        console.log("只有在 count 变化后才会执行")
    }, [count])
}
</code></pre>
</div><div class="cl-preview-section"><p>useEffect 比较重要，它主要有这几个作用：</p>
</div><div class="cl-preview-section"><ol>
<li>代替部分生命周期，如 componentDidMount、componentDidUpdate、componentWillUnmount；</li>
<li>更加 reactive，类似 mobx 的 reaction 和 vue 的 watch；</li>
<li>从命令式变成声明式，不需要再关注应该在哪一步做某些操作，只需要关注依赖数据；</li>
<li>通过 useEffect 和 useState 可以编写一系列自定义的 Hook。</li>
</ol>
</div><div class="cl-preview-section"><h3 id="useeffect-vs-uselayouteffect">4.1 useEffect vs useLayoutEffect</h3>
</div><div class="cl-preview-section"><p>useLayoutEffect 也是一个 Hook 方法，从名字上看和 useEffect 差不多，他俩用法也比较像。<br>
在90%的场景下我们都会用 useEffect，然而在某些场景下却不得不用 useLayoutEffect。</p>
</div><div class="cl-preview-section"><p>useEffect 和 useLayoutEffect 的区别是：</p>
</div><div class="cl-preview-section"><ol>
<li>useEffect 不会 block 浏览器渲染，而 useLayoutEffect 会；</li>
<li>useEffect 会在浏览器渲染结束后执行，useLayoutEffect 则是在 DOM 更新完成后，浏览器绘制之前执行。</li>
</ol>
</div><div class="cl-preview-section"><p>这两句话该怎么来理解呢？我们以一个移动的方块为例子：</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">const moveTo = (dom, delay, options) =&gt; {
    dom.style.transform = `translate(${options.x}px)`
    dom.style.transition = `left ${delay}ms`
}
const Animate = () =&gt; {
    const ref = useRef();
    useEffect(() =&gt; {
        moveTo(ref.current, 500, { x: 600 })
    }, [])
    return (
        &lt;div className="animate"&gt;
            &lt;div ref={ref}&gt;方块&lt;/div&gt;
        &lt;/div&gt;
    )
}
</code></pre>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/q6r3g4sqz2srbwkv3t0v5x77/%E6%96%B9%E5%9D%971.gif" alt="方块1.gif-80.3kB"></p>
</div><div class="cl-preview-section"><p>在 useEffect 里面会让这个方块往后移动 600px 距离，可以看到这个方块在移动过程中会闪一下。<br>
但如果换成了 useLayoutEffect 呢？会发现方块不会再闪动，而是直接出现在了 600px 的位置。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">const Animate = () =&gt; {
    const ref = useRef();
    useLayoutEffect(() =&gt; {
        moveTo(ref.current, 500, { x: 600 })
    }, [])
    return (
        &lt;div className="animate"&gt;
            &lt;div ref={ref}&gt;方块&lt;/div&gt;
        &lt;/div&gt;
    )
}
</code></pre>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/5xs5n2tkbrxmenh8uh6p1t7s/%E6%96%B9%E5%9D%972.gif" alt="方块2.gif-98.4kB"></p>
</div><div class="cl-preview-section"><p>原因是 useEffect 是在浏览器绘制之后执行的，所以方块一开始就在最左边，于是我们看到了方块移动的动画。<br>
然而 useLayoutEffect 是在绘制之前执行的，会阻塞页面的绘制，所以页面会在 useLayoutEffect 里面的代码执行结束后才去继续绘制，于是方块就直接出现在了右边。</p>
</div><div class="cl-preview-section"><p>那么这里的代码是怎么实现的呢？以 preact 为例，useEffect 在 <code>options.commit</code> 阶段执行，而 useLayoutEffect 在 <code>options.diffed</code> 阶段执行。</p>
</div><div class="cl-preview-section"><p>然而在实现 useEffect 的时候使用了 <code>requestAnimationFrame</code>，<code>requestAnimationFrame</code> 可以控制 useEffect 里面的函数在浏览器重绘结束，下次绘制之前执行。</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/ud1cwq5sb9rjeczmrekiafmx/image_1e405qmdf15ucvhr128s1upfd2o9.png" alt="image_1e405qmdf15ucvhr128s1upfd2o9.png-34kB"></p>
</div><div class="cl-preview-section"><h2 id="usememo">5. useMemo</h2>
</div><div class="cl-preview-section"><p>useMemo 的用法类似 useEffect，常常用于缓存一些复杂计算的结果。useMemo 接收一个函数和依赖数组，当数组中依赖项变化的时候，这个函数就会执行，返回新的值。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">const sum = useMemo(() =&gt; {
    // 一系列计算
}, [count])
</code></pre>
</div><div class="cl-preview-section"><p>举个例子会更加清楚 useMemo 的使用场景，我们就以下面这个 DatePicker 组件的计算为例：</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">const render = useMemo(
    () =&gt; {
      const dateTable: Moment[] = [];
      const firstDayOfMonth = (defaultValue || moment()).clone(); // clone
      firstDayOfMonth.date(1); // 当月第一天
      const day = firstDayOfMonth.day(); // 这天是周几
      // 求出卡片展示的第一天（直接用算出本月第一天是周几进行计算）
      const lastMonthDiffDay = (day + 6) % 7;
      const lastMonth1 = firstDayOfMonth.clone();
      lastMonth1.add(0 - lastMonthDiffDay - 1, 'days'); // 求出当前卡片展示的第一天（因为周日展示在第一天，所以要多算一天）
      for (let i = 0; i &lt; DATE.DATE_COL_COUNT * DATE.DATE_ROW_COUNT; i++) {
        current = lastMonth1.clone().add(i, 'days');
        dateTable.push(current);
      }
      return dateTable;
    },
    [defaultValue]
  );
</code></pre>
</div><div class="cl-preview-section"><p>DatePicker 组件每次打开或者切换月份的时候，都需要大量的计算来算出当前需要展示哪些日期。<br>
然后再将计算后的结果渲染到单元格里面，这里可以使用 useMemo 来缓存，只有当传入的日期变化时才去计算。</p>
</div><div class="cl-preview-section"><h2 id="usecallback">6. useCallback</h2>
</div><div class="cl-preview-section"><p>和 useMemo 类似，只不过 useCallback 是用来缓存函数。</p>
</div><div class="cl-preview-section"><h3 id="匿名函数导致不必要的渲染">6.1 匿名函数导致不必要的渲染</h3>
</div><div class="cl-preview-section"><p>在我们编写 React 组件的时候，经常会用到事件处理函数，很多人都会简单粗暴的传一个箭头函数。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">class App extends Component {
    render() {
        return &lt;h1 onClick={() =&gt; {}}&gt;&lt;/h1&gt;
    }
}
</code></pre>
</div><div class="cl-preview-section"><p>这种箭头函数有个问题，那就是在每一次组件重新渲染的时候都会生成一个重复的匿名箭头函数，导致传给组件的参数发生了变化，对性能造成一定的损耗。</p>
</div><div class="cl-preview-section"><p>在函数组件里面，同样会有这个传递新的匿名函数的问题。从下面这个例子来看，每次点击 div，就会引起 Counter 组件重新渲染。</p>
</div><div class="cl-preview-section"><p>这次更新明显和 Input 组件无关，但每次重新渲染之后，都会创建新的 onChange 方法。这样相当于传给 Input 的 onChange 参数变化，即使 Input 内部做过 shadowEqual 也没有意义了，都会跟着重新渲染。</p>
</div><div class="cl-preview-section"><p>原本只想更新 count 值的，可 Input 组件 却做了不必要的渲染。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function App() {
    const [ count, setCount ] = useState(0)
    const [ inputValue, setInputValue ] = useState('')
    
    const onChange = (e) =&gt; {
        setInputValue(e.target.value);
    }
    const increment = () =&gt; {
        setCount(count + 1)
    }
    return (
        &lt;&gt;
            &lt;Input value={inputValue} onChange={onChange} /&gt;
            &lt;div onClick={increment}&gt;{count}&lt;/div&gt;
        &lt;/&gt;
    )
}
</code></pre>
</div><div class="cl-preview-section"><p>这就是体现 useCallback 价值的地方了，我们可以用 useCallback 指定依赖项。在无关更新之后，通过 useCallback 取的还是上一次缓存起来的函数。</p>
</div><div class="cl-preview-section"><p>因此，useCallback 常常配合 <code>React.memo</code> 来一起使用，用于进行性能优化。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function App() {
    const [ count, setCount ] = useState(0)
    const [ inputValue, setInputValue ] = useState('')
    
    const onChange = useCallback((e) =&gt; {
        setInputValue(e.target.value);
    }, [])
    const increment = useCallback(() =&gt; {
        setCount(count + 1)
    }, [count])
    return (
        &lt;&gt;
            &lt;Input value={inputValue} onChange={onChange} /&gt;
            &lt;div onClick={increment}&gt;{count}&lt;/div&gt;
        &lt;/&gt;
    )
}
</code></pre>
</div><div class="cl-preview-section"><h2 id="usereducer--usecontext">7. useReducer &amp;&amp; useContext</h2>
</div><div class="cl-preview-section"><h3 id="usereducer">7.1 useReducer</h3>
</div><div class="cl-preview-section"><p>useReducer 和 useState 的用法很相似，甚至在 preact 中，两者实现都是一样的。<br>
useReducer 接收一个 reducer 函数和初始 state，返回了 state 和 dispatch 函数，常常用于管理一些复杂的状态，适合 action 比较多的场景。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function Counter() {
    const [count, dispatch] = useReducer((state, action) =&gt; {
        switch(action.type) {
            case "increment": 
                return state + 1;
            case "decrement": 
                return state - 1;
            default:
                return state;
        }
    }, 0)
    return (
        &lt;div&gt;
            &lt;h1&gt;{count}&lt;/h1&gt;
            &lt;button onClick={() =&gt; dispatch({ type: "increment"})}&gt;
                increment
            &lt;/button&gt;
            &lt;button onClick={() =&gt; dispatch({ type: "decrement"})}&gt;
                decrement
            &lt;/button&gt;
        &lt;/div&gt;
    )
}
</code></pre>
</div><div class="cl-preview-section"><h3 id="usecontext">7.2 useContext</h3>
</div><div class="cl-preview-section"><p>在上一节讲解 React16 新特性的时候，我们讲过新版 Context API 的用法。</p>
</div><div class="cl-preview-section"><p>新版 Context 常常有一个提供数据的生产者（Provider），和一个消费数据的消费者（Consumer），我们需要通过 Consumer 来以 <code>render props</code> 的形式获取到数据。</p>
</div><div class="cl-preview-section"><p>如果从祖先组件传来了多个 Provider，那最终就又陷入了 <code>render props</code> 嵌套地狱。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">&lt;Context1.Consumer&gt;
    {context1 =&gt; (
        &lt;Context2.Consumer&gt;
            {context2 =&gt; (
                 &lt;Context3.Consumer&gt;
                    {context3 =&gt; (
                        &lt;div&gt;&lt;/div&gt;
                    )}
                &lt;/Context3.Consumer&gt;
            )}
        &lt;/Context2.Consumer&gt;
    )}
&lt;/Context1.Consumer&gt;
</code></pre>
</div><div class="cl-preview-section"><p>useContext 允许我们以扁平化的形式获取到 Context 数据。即使有多个祖先组件使用多个 Context.Provider 传值，我们也可以扁平化获取到每一个 Context 数据。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">const Context = createContext(null);

function App() {
    return (
        &lt;Context.Provider value={{ title: "hello, world" }}
            &lt;Child /&gt;
        &lt;/Context.Provider&gt;
    )
}
function Child() {
    const context = useContext(Context);
    return &lt;h1&gt;{ context.title }&lt;/h1&gt;
}
</code></pre>
</div><div class="cl-preview-section"><h3 id="实现一个简单的-redux">7.3 实现一个简单的 Redux</h3>
</div><div class="cl-preview-section"><p>通过 useReducer 和 useContext，我们完全可以实现一个小型的 Redux。<br>
<em><strong>reducer.js</strong></em></p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">export const reducer = (state, action) =&gt; {
        switch(action.type) {
            case "increment": 
                return state + 1;
            case "decrement": 
                return state - 1;
            default:
                return state;
        }
    }
export const defaultState = 0;
</code></pre>
</div><div class="cl-preview-section"><p><em><strong>Context.js</strong></em></p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">export const Context = createContext(null);
</code></pre>
</div><div class="cl-preview-section"><p><em><strong>App.js</strong></em></p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function App() {
    const [state, dispatch] = useReducer(reducer, defaultState)

    return (
        &lt;Context.Provider value={{state, dispatch}}&gt;
            &lt;ChildOne /&gt;
            &lt;ChildTwo /&gt;
        &lt;/Context.Provider&gt;
    )
}
function ChildOne() {
    const { state, dispatch } = useContext(Context);
    return (
        &lt;div&gt;
            &lt;h1&gt;{state}&lt;/h1&gt;
            &lt;button onClick={() =&gt; dispatch({ type: "increment"})}&gt;
                increment
            &lt;/button&gt;
            &lt;button onClick={() =&gt; dispatch({ type: "decrement"})}&gt;
                decrement
            &lt;/button&gt;
        &lt;/div&gt;
    )
}
</code></pre>
</div><div class="cl-preview-section"><h2 id="custom-hooks">8. Custom Hooks</h2>
</div><div class="cl-preview-section"><p>对于 react 来说，在函数组件中使用 state 固然有一些价值，但最有价值的还是可以编写通用 custom hooks 的能力。</p>
</div><div class="cl-preview-section"><p>想像一下，一个单纯不依赖 UI 的业务逻辑 hook，我们开箱即用。不仅可以在不同的项目中复用，甚至还可以跨平台使用，react、react native、react vr 等等。</p>
</div><div class="cl-preview-section"><p>编写自定义 hook 也需要以 use 开头，这样保证可以配合 eslint 插件使用。</p>
</div><div class="cl-preview-section"><p>在 custom hooks 中也可以调用其他 hook，当前的 hook 也可以被其他 hook 或者组件调用。<br>
以官网上这个获取好友状态的自定义 Hook 为例：</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">import { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  useEffect(() =&gt; {
    function handleStatusChange(status) {
      setIsOnline(status.isOnline);
    }

    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}
</code></pre>
</div><div class="cl-preview-section"><p>这个自定义 Hook 里面对好友的状态进行了监听，每次状态更新的时候都会去更新 isOnline，当组件卸载的时候会清除掉这个监听。</p>
</div><div class="cl-preview-section"><p>这就是 React Hooks 最有用的地方，它允许我们编写自定义 Hook，然后这个自定义 Hook 可以复用给多个组件，并且不会和 UI 耦合到一起。</p>
</div><div class="cl-preview-section"><h2 id="react-hooks-原理">9. React Hooks 原理</h2>
</div><div class="cl-preview-section"><p>由于 preact hooks 的代码和原有的逻辑耦合度很小，这里为了更加浅显易懂，我选用了 preact hooks 的源码来解读。</p>
</div><div class="cl-preview-section"><h3 id="hooks-执行流程">9.1 Hooks 执行流程</h3>
</div><div class="cl-preview-section"><p>在 React 中，组件返回的 JSX 元素也会被转换为虚拟 DOM，就是下方的 vnode，每个 vnode 上面挂载了一个 _component 属性，这个属性指向了组件实例。</p>
</div><div class="cl-preview-section"><p>而在组件实例上面又挂载了一个 _hooks 属性，这个 _hooks 属性里面保存了我们执行一个组件的时候，里面所有 Hook 方法相关的信息。</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/arsxh7oq5g3rkxdw7jcaank7/hooks1.png" alt="image_1e40lsn871ojp1n0m6hg179d1nk99.png-33.5kB"></p>
</div><div class="cl-preview-section"><p>首先，我们有一个全局的 currentIndex 变量，当组件第一次渲染或者更新的时候，它会在每次进入一个函数组件的时候都重置为 0，每次遇到一个 Hook 方法就会增加 1，同时将这个 Hook 方法的信息放到 _list 里面。</p>
</div><div class="cl-preview-section"><p>当我们下次进来或者进入下一个组件的时候， currentIndex 又会被置为 0。</p>
</div><div class="cl-preview-section"><blockquote>
<p>组件渲染 =&gt; currentIndex 重置 0 =&gt; 遇到 Hooks 方法，放进 _list =&gt; currentIndex++ =&gt; 渲染结束</p>
</blockquote>
</div><div class="cl-preview-section"><blockquote>
<p>组件更新 =&gt; currentIndex 重置 0 =&gt; 遇到 Hooks 方法，获取 _list[currentIndex]=&gt; currentIndex++ =&gt; 重复上面步骤 =&gt; 更新结束</p>
</blockquote>
</div><div class="cl-preview-section"><p>这个时候就会从刚才的 _list 里面根据 currentIndex 来取出对应项，所以我们每次进来执行 useState，它依然能拿到上一次更新后的值，因为这里是缓存了起来。</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/rfeornwr8f34fesapdw3ycsl/hooks2.png" alt="hooks2.png-79.6kB"></p>
</div><div class="cl-preview-section"><p>通过上面的分析，你就不难发现，为什么 hooks 方法不能放在条件语句里面了。</p>
</div><div class="cl-preview-section"><p><strong>因为每次进入这个函数的时候，都是要和 currentIndex 一一匹配的，如果更新前后少了一个 Hook 方法，那么就完全对不上了，导致出现大问题。</strong></p>
</div><div class="cl-preview-section"><h3 id="usestate-和-usereducer">9.2 useState 和 useReducer</h3>
</div><div class="cl-preview-section"><p>这样你再来看下面 useState 和 useReducer 的源码就会更容易理解一些。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">function useState(initialState) {
	return useReducer(invokeOrReturn, initialState);
}

export function useReducer(reducer, initialState, init) {
	const hookState = getHookState(currentIndex++);
	if (!hookState._component) {
		hookState._component = currentComponent;
		hookState._value = [
			!init ? invokeOrReturn(undefined, initialState) : init(initialState),

			action =&gt; {
				const nextValue = reducer(hookState._value[0], action);
				if (hookState._value[0] !== nextValue) {
					hookState._value[0] = nextValue;
					hookState._component.setState({});
				}
			}
		];
	}

	return hookState._value;
}
</code></pre>
</div><div class="cl-preview-section"><p>很明显，getHookState 是根据 currentIndex 来从 _list 里面取和当前 Hook 相关的一些信息。如果是初始化状态（即没有 <code>hookState._component</code>）这个属性的时候，就会去初始化 useState 的两个返回值，否则就会直接返回上一次缓存的结果。</p>
</div><div class="cl-preview-section"><h3 id="useeffect-1">9.3 useEffect</h3>
</div><div class="cl-preview-section"><p>useEffect 和 useState 差不多，区别就在 useEffect 接收的函数会放到一个 _pendingEffects 里面，而非 _list 里面。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">export function useEffect(callback, args) {
	const state = getHookState(currentIndex++);
	// 如果依赖项发生了变化，那就更新 callback 和 args
	if (argsChanged(state._args, args)) {
		state._value = callback;
		state._args = args;

		currentComponent.__hooks._pendingEffects.push(state);
	}
}
</code></pre>
</div><div class="cl-preview-section"><p>在 diff 结束之后会从 _pendingEffects 里面取出来函数一个个执行。afterPaint 里面使用了 requestAnimateFrame 这个方法，所以传给 useEffect 里面的方法是在浏览器绘制结束之后才会执行的。</p>
</div><div class="cl-preview-section"><pre class="  language-react"><code class="prism  language-react">options.diffed = vnode =&gt; {
	if (oldAfterDiff) oldAfterDiff(vnode);

	const c = vnode._component;
	if (!c) return;

	const hooks = c.__hooks;
	if (hooks) {
		if (hooks._pendingEffects.length) {
			afterPaint(afterPaintEffects.push(c));
		}
	}
};
</code></pre>
</div><div class="cl-preview-section"><h3 id="总结">9.4 总结</h3>
</div><div class="cl-preview-section"><p>最后，这里对 React Hooks 的整个运行流程来进行一下总结和梳理。</p>
</div><div class="cl-preview-section"><ol>
<li>每个组件实例上挂载一个 _hooks 属性，保证了组件之间不会影响；</li>
<li>每当遇到一个 hooks 方法，就将其 push 到 <code>currentComponent._hooks._list</code> 中，且 currentIndex 加一；</li>
<li>每次渲染进入一个组件的时候，都会从将 currentIndex 重置为 0 。遇到 hooks 方法时，currentIndex 重复第二步。这样可以把 currentIndex 和 <code>currentComponent._hooks._list</code> 中的对应项匹配起来，直接取上次缓存的值；</li>
<li>函数组件每次重新执行后，useState 中还能保持上一次的值，就是来自于步骤 3 中的缓存；</li>
<li>由于依赖了 currentComponent 实例，所以 hooks 不能用于普通函数中。</li>
</ol>
</div><div class="cl-preview-section"><h2 id="react-hooks-实践">10. React Hooks 实践</h2>
</div><div class="cl-preview-section"><p>得益于 react hooks 将业务逻辑从 ui 中抽离出来，目前社区里面关于 react hooks 的实践，大都是从功能点出发。</p>
</div><div class="cl-preview-section"><p>从最简单的 api 封装，例如 useDebounce、useThrottle、useImmerState 等等，再到业务层面功能封装，比较出名的库有 react-use、umijs/hooks 等等。</p>
</div><div class="cl-preview-section"><p>举个栗子：umijs/hooks 的表格：</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/odmkfbmnydhxqkhcq00wscmc/image_1e7vdlm041bccc781qes1u391uf19.png" alt="image_1e7vdlm041bccc781qes1u391uf19.png-241kB"></p>
</div><div class="cl-preview-section"><p>在后台管理系统开发中，表格是非常常见的场景，将分页、查询、loading、排序等等功能打包封装成通用 Hook，就能发挥很大的潜力。</p>
</div><div class="cl-preview-section"><p><img src="http://static.zybuluo.com/gyyin/hhgsinkoqog39p95d8i99cpq/image_1e7vdm5r2177p3561vk3u1i15s0m.png" alt="image_1e7vdm5r2177p3561vk3u1i15s0m.png-532.5kB"></p>
</div><div class="cl-preview-section"><h2 id="推荐阅读">11. 推荐阅读</h2>
</div><div class="cl-preview-section"><ol>
<li><a href="https://zhuanlan.zhihu.com/p/103150605">Umi Hooks - 助力拥抱 React Hooks</a></li>
<li><a href="https://www.zhihu.com/question/343314784/answer/940546189">为什么 React 现在要推行函数式组件，用 class 不好吗？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/106796295">useRequest- 蚂蚁中台标准请求 Hooks</a></li>
</ol>
</div>
			
		</div>
	
	
	<div class="finish-learn">
		<p class="copyright">©版权归慕课网所有，未经许可不得转载</p>
		
		
		
		<div class="ad_pic">
			<img src="https://img.mukewang.com/5eb8b6cb00011d7f06700192.jpg">
		</div>
		
		
		
		
	</div>
	<div class="comment-con">
		<h4 class="title">
			精选留言
			
				<a href="javascript: void(0);" class="add-comment js-comment-click"><i class="imwap-xieliuyan"></i><span>写留言</span></a>
			
		</h4>
		
			<p class="bottom-text empty">暂无精选留言</p>
		
	</div>
	
	

	
		
	
	
	
		<div class="bottom-con">
			
			
				<div class="inner">
					
						<div class="price-con js-price-con">
							<span class="now">￥58.00</span>
						</div>
							
					
					
					<a class="gobuy js-gobuy" href="//m.imooc.com/account/login?backurl=//m.imooc.com/confirmorder?type=30&typeid=72">
					
						立即购买
					</a>  
				</div>
			
		</div>
	
	<div class="layer-catalog js-layer-catalog hide">
		<div class="layer-title clearfix">
			<div class="l">
				课程目录
			</div>
			
		</div>
		<div class="layer-wrap">
			<div class="js-catalog-container">
			</div>
		</div>
	</div>
	<div class="layer-comment">
		<div class="inner">
			<h5>
				<span class="btn l js-cancel-comment">取消</span>
				评论
				<span class="btn r js-send-comment">发送</span>
			</h5>
			<textarea id="comment-txt" maxlength="20000" placeholder="欢迎在这里发表留言，作者筛选后可公开显示"></textarea>
		</div>
	</div>


            </div>
        </div>
        
            
         
        
        
        
        




<script>
	// 设置字号大小及选中
	(function() {
			var fs = window.localStorage.getItem('font-size') || 'normal';
			var $c = document.querySelector('#middle>.content');
			var $points = document.querySelectorAll('.setting-box .point');
			try{
				// 抢读完了时 该元素不渲染 会有报错
				$c.className = 'content ' + fs;
				for(var i = 0; i < $points.length; i++) {
					if($points[i].className.indexOf(fs) > -1) {
						$points[i].className = $points[i].className + ' current';
					}
				}
			} catch(e) {}
			
	})();
</script>

<script type="text/javascript">
	window.onload = function() {
			zhuge.track('LearnCourse', {
					'Category': '专栏',
					'Name': '26 React Hooks 原理与最佳实践',
					'CID': '1677',
					'Teacher': 'sh22n'
			});
	}
</script>

        
            <script type="text/javascript">
                var shareData = { 
                    title:  "26 React Hooks 原理与最佳实践",
                    desc: "前端进阶必备，未来少走弯路",
                    imgUrl: 'https:https://img3.mukewang.com/5e6af0f50001b61d05400720.jpg',
                    otherImgUrl: 'https://img3.mukewang.com/5e6af0f50001b61d05400720.jpg',
                    text: '我正在参加@慕课网的课程，很不错哦！快来一起学习吧！',
                    // url: 'https://www.imooc.com' + window.location.pathname + window.location.search
                    url: 'https://m.imooc.com/read/72',
                    link: 'https://m.imooc.com/read/72'
                }
            </script>
            
        
        <div style="display:none;">
            <!-- 百度统计 -->
            <script>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?c92536284537e1806a07ef3e6873f2b3";
              var s = document.getElementsByTagName("script")[0];
              s.parentNode.insertBefore(hm, s);
            })();
            </script>

            <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
            </script>
        </div>
        
    <script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/zhugeio/init_f9752c3.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/jquery-2.1.0.min_ac9f840.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/common_84429c0.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/juicer/juicer.min_8643248.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/previewImage/previewImage.min_43b970d.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/msg_bed8d10.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/read/7.2.8/article_30e5762.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/course/advertisementReport_6e58a98.js"></script></body>
</html>
