<!doctype html>
<html lang="zh_CN">

    

    

    
    
    
    <head>
        
        <title>21 GIL 全局锁，束缚Python的紧箍圈</title>
        
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="突破技术瓶颈，迈向更高岗位">
        <meta name="keywords" content="慕课网">
        <meta name="author" content="">
        <meta name = "format-detection" content="telephone=no">
        <meta http-equiv="Cache-Control" content="no-transform " />
        <meta http-equiv="Cache-Control" content="no-siteapp" />
        <link rel="shortcut icon" href="https://m.imooc.com/static/wap/static/favicon.ico" />
        
        
        
        <script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/flexible.js"></script>
        
        <script type="text/javascript">
            var userInfo = "";
            
                var isApp = 0;
            
        </script>
         
<!-- 专栏首页列表模板 -->
<script type="text/template" id="index-list-tpl">
<ul class="list-con">
    {@each data.data as item}
        <li>
            <a href="/read/${item.id}" class="item clearfix">
                <div class="img l" style="background-image: url(${item.app_pic1})">
                    {@if item.is_new }
                        <div class="icon new">
                            上新
                        </div>
                    {@else if item.is_marking} 
                        <div class="icon">
                            经典
                        </div>
                    {@/if} 
                </div>
                <div class="text-con l">
                    <div class="title">
                        ${item.title}
                    </div>
                    <div class="desc">
                        ${item.chapter_num}节 · ${item.description}
                    </div>
                     <div class="user-info">
                        ${item.nickname}
                        {@if item.author_title }
                        <span class="dot">
                            ·
                        </span>
                        ${item.author_title}
                        {@/if}
                    </div>
                    <div class="info clearfix">
                    {@if !item.isBuy } 
                        <!-- 未购买才显示 -->
                        <div class="price-con l">
                        {@if item.open_discount == "1" }
                            <span class="now">￥${item.pay_price}</span>
                            <span class="ori">￥${item.price}</span>
                            <p class="sale">${item.discount_name}</p>
                        {@else}
                            <span class="now">￥${item.price}</span>
                        {@/if}
                        </div>
                    {@/if}
                        <div class="taste-con r">
                            <span>${item.numbers}人订阅</span>
                            {@if !item.isBuy }
                                <span class="gotaste">试读</span>
                            {@else}
                                <span class="gotaste">学习</span>
                            {@/if}
                        </div>
                    </div>
                </div>
            </a>
        </li>
    {@/each}
</ul>
</script>



<!-- 专栏目录 买后目录页、 -->
<script type="text/template" id="detail-catalog-tpl">
<ul class="catalog-list">
{@each data.list as item}
    <li class="zhang">
        {@if data.structure_mode == "1" }
            <!--章节模式-->
            <div class="zhang-title">
                ${item.title}（${item.count}节）
            </div>
            <div class="zhang-sub-title">
                ${item.short_introduce}
            </div>
        {@/if}  
        <ul class="zhang-detail">
            {@each item.list as it,i}
                <li class="jie">
                    {@if data.isLogin }
                        <!-- 购买了  -->
                        {@if data.isBuy }
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read">
                        {@else}
                        <a href="javascript:;" data-link="/read/${data.column_id}/article/${it.id}" class="js-go-read" >
                        {@/if}
                    {@else}
                        <!-- 未登录  -->
                        {@if data.isApp }
                            <a href="javascript:;" onclick="window.nativeSupport.login();">
                        {@else}
                            <a href="//m.imooc.com/account/login?backurl=/read/${data.column_id}">
                        {@/if}
                    {@/if}
                        <div class="jie-con {@if data.last_chapter == it.id }recent{@/if}">
                            
                            <div class="text-con">
                                <div class="jie-title">
                                    ${it.title}
                                </div>
                                <div class="jie-status">
                                    {@if it.is_open == "0" }
                                        <span class="update-time" >${it.open_time_fmt}</span>
                                    {@/if}
                                    {@if it.view_num > 100 }
                                    <div class="learn-num">
                                        <i class="imwap-set-sns"></i>
                                        <span>${it.view_num}</span>
                                    </div>
                                    {@/if}
                                    {@if it.in_24hours == "1" }
                                        <span class="update-recent">最近更新</span>
                                    {@/if}
                                </div>
                            </div>
                        </div>
                        {@if it.is_learned }
                            <div class="jie-right haslearn is_learned js-learn" data-type="1">
                                已学
                            </div>
                        {@else}
                            <!-- 购买了  -->
                            {@if data.isBuy }
                                <div class="jie-right learn js-learn" data-type="1">
                                    学习
                                </div>
                            {@else}
                                {@if it.is_pay == "0" }
                                <!--免费小节 不占用试读次数  -->
                                    <div class="jie-right learn js-learn" data-type="1">
                                        免费
                                    </div>
                                {@else}
                                    <div class="jie-right learn js-learn" data-type="0">
                                        学习
                                    </div>
                                {@/if}
                            {@/if}
                            
                            
                        {@/if}
                    </a>
                </li>
            {@/each}
        </ul>
    </li>
{@/each}
</ul>
</script> 

<!-- 阅读页 阅读页   专栏目录  -->
<script type="text/template" id="catalog-tpl">
<div>
    <h2 class="article-title">${data.a_name}</h2>
    <ul class="catalog">
    {@each data.list as item}
        <li class="zhang">
            {@if data.structure_mode == "1" }
                <!--章节模式-->
                <div class="zhang-title">
                    ${item.title}
                    <!-- <div class="num">共${item.count}节</div> -->
                </div>
            {@/if}  
            <ul class="zhang-detail">
                {@each item.list as it,i}
                    <li class="jie">
                        <!--买了且开放的-->
                        <a href="/read/${data.column_id}/article/${it.id}">
                            <div class="jie-title clearfix full">
                                <p>
                                    {@if data.last_chapter == it.id }
                                        <span class="recent">最近阅读</span>
                                    {@/if}
                                    ${it.title}
                                </p>
                            </div>
                        </a>
                    </li>
                {@/each}
            </ul>
        </li>
    {@/each}
    </ul>
</div>
</script>





<script type="text/javascript">
	var isApp = "";
	var clientVersion = "0";
	var count_num = "8";
	var chapter_id = "1917";
	var chapter_title = "21 GIL 全局锁，束缚Python的紧箍圈";
	var aid = "76";
	var a_name = "Python 源码深度剖析";
	var a_price = "68.00";
	var a_pic = "https://img3.mukewang.com/5eb68ab400017cda05400720.jpg";
	var userId = 0;

	var column_id = '76';
	var isLogin = 0;
	

</script>
<!-- 引入字体 -->
<script type="text/javascript" src="//cdn.webfont.youziku.com/wwwroot/js/wf/youziku.api.min.js"></script>
<script type="text/javascript">
$youziku.load(".top-con .title, .cl-preview-section h1,.cl-preview-section h2,.cl-preview-section h3,.cl-preview-section h4,.cl-preview-section h5,.cl-preview-section h6", "37af461390fa4d138f5c3d277f7286dc", "SourceHanSerifSC-Heavy"); // 思源宋体heavy
$youziku.load(".lead-motto, .cl-preview-section blockquote", "d9a0d855583142c3b2cc3bf1646a8473", "SourceHanSerifSC-Regular"); // 思源宋体regular
$youziku.load("#article_content, .cl-preview-section pre, .cl-preview-section code, #code-copy", "3d84aabcf9e44b6f8c6fa91c61fa926e", "HYQiHei-55S"); // 汉仪旗黑55s
$youziku.load(".cl-preview-section strong", "fd94fff3a17546a28913a79613bddcec", "HYQiHei-77S"); // 汉仪旗黑70s

$youziku.draw();
</script>

<style type="text/css">
  header{
    display: none!important;
  }
  
  #wrapper{
  	padding-top:0px !important;
  }
  
</style>



    <link rel="stylesheet" href="https://m.imooc.com/static/wap/static/common/css/common_d42b1ef.css" /><link rel="stylesheet" href="https://m.imooc.com/static/wap/static/css/read/7.2.8/article_2d28313.css" /></head>
    <body >
        
          
        

        
          
        

        
          







<header class="directory2">
	<div class="header clearfix">
		
			
				<div class="page-title clearfix">
					<a href="//m.imooc.com" class="imwap-icon-imooc"></a>
					<div class="page-title-name js-page-name">
						<span>专栏</span>
						<i class="imwap-arrow_d"></i>
					</div>
				</div>
			

			
			<div class="drawer-box js-drawer-more">
				<i class="imwap-more_vert"></i>
				<div class="drawer-content js-drawer-content">
					<p class="line-row"></p>
					<a class="drawer-item" href="//m.imooc.com"><i class="imwap-center"></i>回到首页</a>
					<a class="drawer-item" href="//www.imooc.com/m/web/user/usercenter.html"><i class="imwap-peaple"></i>个人中心</a>
					<a class="drawer-item" href="//m.imooc.com/feedback"><i class="imwap-comment"></i>反馈问题</a>
					
					<a class="drawer-item" href="//m.imooc.com/account/login"><i class="imwap-out"></i>注册登录</a>
					
				</div>
			</div>
			

			
				<a id="js-appload" href="Javascript:;" class="app-load"><span>下载APP</span></a>
			

		
	</div>
	
	<div class="page-tab-wrap">
		<div class="page-tab-list">
			<a href="//m.imooc.com" class="page-tab-item">首页</a>
			<a href="//m.imooc.com/course/list" class="page-tab-item">课程</a>
			<a href="//coding.m.imooc.com" class="page-tab-item">实战</a>
			<a href="//class.m.imooc.com" class="page-tab-item">金职位</a>
			<a href="//m.imooc.com/article" class="page-tab-item">手记</a>
			<a href="//m.imooc.com/read" class="page-tab-item active">专栏</a>
			<a href="//m.imooc.com/wenda" class="page-tab-item">猿问</a>
			<a href="//m.imooc.com/wiki" class="page-tab-item">慕课教程</a>
			
		</div>
	</div>
	
</header>


        

        <div id="wrapper">
            <div id="middle" class="container ">

                

                
	
		
	
	<div class="top-con">
		<p class="update-time"><span>2020-08-03&nbsp;&nbsp;&nbsp;更新</span></p>
		<div class="title">
			21 GIL 全局锁，束缚Python的紧箍圈
		</div>
	</div>
	
		<div class="article-img" style="background-image: url('https://img2.mukewang.com/5efbf2fd0001073206400426.jpg')"></div>
	
	
		<a href="/read/76">
			<div class="course-entry">
				<img src="https://img.mukewang.com/5e4a3ec90001ef8d04000400-40-40.jpg" alt="fasionchan">
				<h3>Python 源码深度剖析</h3>
				<p>fasionchan · 资深 Python 研发工程师</p>
				<i class="imwap-arrow_r"></i>
			</div>
		</a>
	
	
		<div class="lead-motto">
			<div class="content">立志是事业的大门，工作是登堂入室的旅程。<p class="author">——巴斯德</p></div>
		</div>
	
	
		<div class="content" id="article_content">
			
			<div class="cl-preview-section"><p>请问 <em>GIL</em> 全局锁的作用是什么？对 <em>Python</em> 程序有什么影响？<em>Python</em> 程序如何充分利用多核 <em>CPU</em> 的计算能力？这几个问题在 <em>Python</em> 面试基本都是必问的，然而有不少候选人对此只是一知半解，知其然而不知其所以然。</p>
</div><div class="cl-preview-section"><p><em>GIL</em> 作为 <em>Python</em> 虚拟机最大的局限性，对 <em>Python</em> 程序运行性能影响深刻。因此，<em>Python</em> 工程师必须明白虚拟机引入 <em>GIL</em> 的前因后果，避免多线程程序被 <em>Python</em> 虚拟机戴上金箍圈，进而产生不可预料的性能问题。</p>
</div><div class="cl-preview-section"><p>由于 <em>GIL</em> 的存在不可避免，只有想方设法绕过 <em>GIL</em> 的限制才能最大限度地提升 <em>Python</em> 程序的多核执行能力。</p>
</div><div class="cl-preview-section"><h2 id="gil由来">GIL 由来</h2>
</div><div class="cl-preview-section"><p>我们先思考一个问题：我们在前面介绍的 <em>list</em> 、 <em>dict</em> 等内建对象是 <strong>线程安全</strong> 的吗？</p>
</div><div class="cl-preview-section"><p>在 <em>Python</em> 层面，<em>list</em> 、<em>dict</em> 等内建对象是线程安全的，这是最基本的常识。研究 <em>list</em>、<em>dict</em> 等内建对象源码时，我们并没有看到任何 <strong>互斥锁</strong> 的痕迹，这多少有点令人意外。以 <em>list</em> 对象 <em>append</em> 方法为例，主要步骤如下：</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">app1</span><span class="token punctuation">(</span>PyListObject <span class="token operator">*</span>self<span class="token punctuation">,</span> PyObject <span class="token operator">*</span>v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Py_ssize_t n <span class="token operator">=</span> <span class="token function">PyList_GET_SIZE</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">assert</span> <span class="token punctuation">(</span>v <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> PY_SSIZE_T_MAX<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">PyErr_SetString</span><span class="token punctuation">(</span>PyExc_OverflowError<span class="token punctuation">,</span>
            <span class="token string">"cannot add more objects to list"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">list_resize</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token function">Py_INCREF</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">PyList_SET_ITEM</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><ol>
<li>调用 <em>list_resize</em> 将列表长度扩大 <em>1</em> (第 <em>13-14</em> 行)；</li>
<li>将被追加元素设置到末尾位置 (第 <em>16-17</em> 行)；</li>
</ol>
</div><div class="cl-preview-section"><p>由此可见，<em>append</em> 方法不是一个 <strong>原子操作</strong> 。假设线程 <em>A</em> 调用 <em>append</em> 方法，执行长度扩容后便发生 <strong>线程调度</strong> ；系统唤醒线程 <em>B</em> 开始执行 <em>l[-1]</em> 语句访问 list 末尾元素，会怎样呢？由于 <em>list</em> 长度已经扩容但追加元素尚未设置，线程 B 将得到一个非法对象！</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5efbf32c0001c7b210450525.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>这种有多线程并发操作导致的 <strong>竞争条件</strong> ，一般通过互斥锁加以解决。我们可以为每个 <em> list</em> 对象分配一个互斥锁，当一个 <em>list</em> 操作开始执行前，先获取锁；执行完毕后，再释放锁。进入 <strong> 对象锁</strong> 后，竞争条件便消除了。</p>
</div><div class="cl-preview-section"><pre class="  language-c"><code class="prism  language-c"><span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">some_op</span><span class="token punctuation">(</span>PyListObject <span class="token operator">*</span>self<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// acquire lock</span>
    <span class="token function">lock</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// process operation</span>
    <span class="token comment">// ...</span>
    
    <span class="token comment">// release lock</span>
    <span class="token function">unlock</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p>可我们在源码中并没有发现，这又是为什么呢？莫非 <em>Python</em> 采用了其他什么野路子？</p>
</div><div class="cl-preview-section"><p>的确如此。<em>Python</em> 虚拟机维护了一个 <strong>全局锁</strong> ，这就是众所周知的 <em>GIL</em>。<em>Python</em> 线程想在虚拟机中执行字节码，必须取得全局锁。这样一来，不管任何时刻，只有一个线程在虚拟机中运行。那么，虚拟机如何交替执行不同线程呢？</p>
</div><div class="cl-preview-section"><p><em>Python</em> 线程调度实现方式参考了操作系统进程调度中 <strong> 时间片</strong> 的思路，只不过将时间片换成 <strong>字节码</strong> 。当一个线程取得 <em> GIL</em> 全局锁并开始执行字节码时，对已执行字节码进行计数。当执行字节码达到一定数量 (比如 100 条) 时，线程主动释放 <em>GIL</em> 全局锁并唤醒其他线程。其他等待 <em>GIL</em> 全局锁的线程取得锁后，将得到虚拟机控制权并开始执行。因此，虚拟机就像一颗软件 <em>CPU</em> ，<em>Python</em> 线程交替在虚拟机上执行：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5efbf3380001e51009210675.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>如图，绿色为当前正在虚拟机中执行的线程；蓝色为等待到虚拟机上执行的线程；黄色为阻塞在 <em>IO</em> 操作上的线程。对于 <em>Running</em> 线程，如果已执行字节码达到一定数量，则自动让出 <em>GIL</em> 并唤醒其他线程，状态变更为 <em>Ready</em> ；如果执行 <em>IO</em> 操作，在执行阻塞型系统调用前先让出 <em>GIL</em> ，状态变更为 <em>IO Blocked</em> 。当 Ready 线程取得 GIL 后，获得虚拟机控制权并开始执行字节码，状态变更为 <em>Running</em> 。 <em>IO Blocked</em> 线程一开始阻塞在系统调用上，当系统调用返回后，状态变更为 <em>Ready</em> ，再次等待 <em>GIL</em> 以便获得虚拟机执行权。</p>
</div><div class="cl-preview-section"><p>那么，<em>Python</em> 为啥采用 <em>GIL</em> 这么简单粗暴的解决方案，而不是对象锁呢？首先，对象锁方案为每个需要保护的对象分配一个互斥锁，内存开销巨大。其次，频繁的加解锁操作严重影响执行效率，特别是 <em>dict</em> 等对象使用频率很高。</p>
</div><div class="cl-preview-section"><div class="table-wrapper"><table>
<thead>
<tr>
<th><strong>线程安全方案</strong></th>
<th><strong>优势</strong></th>
<th><strong>劣势</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>对象锁</td>
<td>多线程可并行执行</td>
<td>加解锁开销巨大</td>
</tr>
<tr>
<td> GIL</td>
<td> 无需频繁加解锁</td>
<td>多线程只能交替执行</td>
</tr>
</tbody>
</table>
</div></div><div class="cl-preview-section"><p>有测试结果表明，引入对象锁获得的多线程 <strong>并行执行</strong> 能力，几乎被加解锁开销完全抵消。而在单线程环境下， <em>GIL</em> 方案优势明显。这样看来，<em>Python</em> 作者们采用 <em>GIL</em> 方案也就理所当然了。</p>
</div><div class="cl-preview-section"><h2 id="gil影响">GIL 影响</h2>
</div><div class="cl-preview-section"><p>在 <em>GIL</em> 的束缚下，<em>Python</em> 虚拟机同一时刻只能执行一个线程。这是否意味着多线程完全无法优化程序性能呢？由于程序运行特征千差万别，这个问题得分情况讨论。开始之前，我们先来了解两种不同的运行特征：</p>
</div><div class="cl-preview-section"><p>程序在运行时，一般都处于两种状态：</p>
</div><div class="cl-preview-section"><ol>
<li><strong>可执行</strong> 状态，包括 <em>Running</em> 以及 <em>Ready</em> 两种情况，这时竞争处理器资源；</li>
<li><strong>阻塞</strong> 状态，一般为等待 <em>IO</em> 处理，这时让出处理器资源；</li>
</ol>
</div><div class="cl-preview-section"><p>根据程序分别处于 <em>Running</em> 以及 <em>IO Blocked</em> 两种状态的时间占比，可分为两种：</p>
</div><div class="cl-preview-section"><ul>
<li><strong>计算密集型</strong> ，程序执行时大部分时间处于 <em>Running</em> 状态；</li>
<li><strong>IO 密集型</strong> ，程序执行时大部分时间处于 <em>IO Blocked</em> 状态；</li>
</ul>
</div><div class="cl-preview-section"><h3 id="io密集型">IO 密集型</h3>
</div><div class="cl-preview-section"><p>典型 <strong>IO 密集型</strong> 程序时间轴如下，绿色为 <em>Running</em> 状态，黄色为 <em>IO Blocked</em> 状态：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5efbf3440001ef3305900138.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p><strong>IO 密集型</strong> 程序受 GIL 影响相对有限，因为线程在等待 IO 处理时可以让出 GIL 以便其他线程拿到虚拟机执行权：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5efbf35d0001517d07430362.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>批量下载网页就是一个典型的 <strong>IO 密集型</strong> 场景，大部分时间花在等待服务器响应，请求发起以及网页处理所占的时间非常少。因此，一个多线程网络爬虫程序可以极大缩短程序运行时间。</p>
</div><div class="cl-preview-section"><h3 id="计算密集型">计算密集型</h3>
</div><div class="cl-preview-section"><p>诸如科学计算这样的 <strong>计算密集型</strong> 程序就不一样了，除了开始前读取参数，结束后保存结果，大部分时间都在运算：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5efbf3670001788d06170138.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p><strong>计算密集型</strong> 程序受 <em> GIL</em> 影响就大了 —— 在 <em>GIL</em> 约束下，虚拟机只能交替执行不同的线程：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5efbf3720001458d12460366.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p>由此可见，<em>Python</em> 线程并不具备多核并行执行能力，不能缩短计算密集型程序的运行时间。</p>
</div><div class="cl-preview-section"><h2 id="如何提升多核执行能力">如何提升多核执行能力</h2>
</div><div class="cl-preview-section"><p>我们以 <strong>随机数估算 π 值</strong> 这个典型的 <strong>计算密集型</strong> 场景为例，探索 <em>Python</em> 多核执行能力提升之道：</p>
</div><div class="cl-preview-section"><p><img src="https://img.mukewang.com/5efbf37e000181f103760353.png" alt="图片描述"></p>
</div><div class="cl-preview-section"><p><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">π</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.03588em;">π</span></span></span></span></span> 值可以通过随机试验进行估算，具体做法是：制作一个边长为 <em>1</em> 的正方形，绘出内切扇形，如上图。正方形的面积为 <em>1</em> ，内切扇形的面积为 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>π</mi><msup><mi>r</mi><mn>2</mn></msup></mrow><mrow><mn>4</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{πr^2 }{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 1.01792em;"></span><span class="strut bottom" style="height: 1.36292em; vertical-align: -0.345em;"></span><span class="base"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01792em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">4</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line hide-tail" style="height: 0.04em;"><svg width="400em" height="400em" viewBox="0 0 400000 400000" preserveAspectRatio="xMinYMin slice"><path d="M0 0 h400000 v400000 h-400000z M0 0 h400000 v400000 h-400000z"></path></svg></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">π</span><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.891314em;"><span class="" style="top: -2.931em; margin-right: 0.0714286em;"><span class="pstrut" style="height: 2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathrm mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>，即 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>π</mi></mrow><mrow><mn>4</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{π }{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.695392em;"></span><span class="strut bottom" style="height: 1.04039em; vertical-align: -0.345em;"></span><span class="base"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">4</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line hide-tail" style="height: 0.04em;"><svg width="400em" height="400em" viewBox="0 0 400000 400000" preserveAspectRatio="xMinYMin slice"><path d="M0 0 h400000 v400000 h-400000z M0 0 h400000 v400000 h-400000z"></path></svg></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。随机往正方形发射一个点，该点落在扇形内的概率为<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi> π</mi></mrow><mrow><mn>4</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{π }{4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.695392em;"></span><span class="strut bottom" style="height: 1.04039em; vertical-align: -0.345em;"></span><span class="base"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.695392em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">4</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line hide-tail" style="height: 0.04em;"><svg width="400em" height="400em" viewBox="0 0 400000 400000" preserveAspectRatio="xMinYMin slice"><path d="M0 0 h400000 v400000 h-400000z M0 0 h400000 v400000 h-400000z"></path></svg></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。现随机往正方形内发射 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span> 个点，统计其中落在扇形内的点个数  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">in\_sectors</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.96952em; vertical-align: -0.31em;"></span><span class="base"><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">s</span></span></span></span></span>，那么 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">π</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.03588em;">π</span></span></span></span></span> 值可以这样估算：<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi><mo>=</mo><mfrac><mrow><mn>4</mn><mo>∗</mo><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow><mrow><mi>n</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">π = \frac{4 * in\_sectors}{n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.988664em;"></span><span class="strut bottom" style="height: 1.33366em; vertical-align: -0.345em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.03588em;">π</span><span class="mrel">=</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.988664em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight">n</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line hide-tail" style="height: 0.04em;"><svg width="400em" height="400em" viewBox="0 0 400000 400000" preserveAspectRatio="xMinYMin slice"><path d="M0 0 h400000 v400000 h-400000z M0 0 h400000 v400000 h-400000z"></path></svg></span></span><span class="" style="top: -3.527em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathrm mtight">4</span><span class="mbin mtight">∗</span><span class="mord mathit mtight">i</span><span class="mord mathit mtight">n</span><span class="mord mathrm mtight" style="margin-right: 0.02778em;">_</span><span class="mord mathit mtight">s</span><span class="mord mathit mtight">e</span><span class="mord mathit mtight">c</span><span class="mord mathit mtight">t</span><span class="mord mathit mtight">o</span><span class="mord mathit mtight" style="margin-right: 0.02778em;">r</span><span class="mord mathit mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>。试验次数越大，估算出来的  <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">π</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.03588em;">π</span></span></span></span></span> 值也就越准确，当然也意味着巨大的计算量。</p>
</div><div class="cl-preview-section"><p>现在，借助 <em>random</em> 模块生成随机数，编写一个试验函数 <em>sample</em>，以试验次数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span> 为参数，返回试验次数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">n</span></span></span></span></span> 以及落在扇形内的次数 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mi>n</mi><mi mathvariant="normal">_</mi><mi>s</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">in\_sectors</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.96952em; vertical-align: -0.31em;"></span><span class="base"><span class="mord mathit">i</span><span class="mord mathit">n</span><span class="mord mathrm" style="margin-right: 0.02778em;">_</span><span class="mord mathit">s</span><span class="mord mathit">e</span><span class="mord mathit">c</span><span class="mord mathit">t</span><span class="mord mathit">o</span><span class="mord mathit" style="margin-right: 0.02778em;">r</span><span class="mord mathit">s</span></span></span></span></span>：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">import</span> random

<span class="token keyword">def</span> <span class="token function">sample</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    in_sectors <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token comment"># 循环试验n次</span>
    <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 随机生成一个点，坐标均在0到1之间</span>
        x<span class="token punctuation">,</span> y <span class="token operator">=</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> random<span class="token punctuation">.</span>random<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment"># 如果该点到原点的距离平方小于1，则在扇形内</span>
        <span class="token keyword">if</span> x<span class="token operator">*</span>x <span class="token operator">+</span> y<span class="token operator">*</span>y <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">:</span>
            in_sectors <span class="token operator">+=</span> <span class="token number">1</span>
    <span class="token keyword">return</span> n<span class="token punctuation">,</span> in_sectors
</code></pre>
</div><div class="cl-preview-section"><p>根据试验结果，<em>eval_pi</em> 计算 <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>π</mi></mrow><annotation encoding="application/x-tex">π</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.43056em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.03588em;">π</span></span></span></span></span> 的近似值：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">eval_pi</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> in_sectors<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">.</span> <span class="token operator">*</span> in_sectors <span class="token operator">/</span> n
</code></pre>
</div><div class="cl-preview-section"><p>现在，我们以单线程模式执行 <em>1</em> 亿次随机试验，<em>estimate_pi</em> 执行耗时 <em>4.59</em> 秒：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">def</span> <span class="token function">estimate_pi</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> eval_pi<span class="token punctuation">(</span><span class="token operator">*</span>sample<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p>接下来，我们再以多线程模式执行 <em>1</em> 亿次随机试验，并与单线程模式进行对比。为此我们设计了多线程版的估算函数 <em>estimate_pi_with_threads</em> ，<em>thread_num</em> 参数为线程数：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">from</span> queue <span class="token keyword">import</span> Queue
<span class="token keyword">from</span> threading <span class="token keyword">import</span> Thread

<span class="token keyword">def</span> <span class="token function">estimate_pi_with_threads</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> thread_num<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 用于收集线程执行结果的队列</span>
    queue <span class="token operator">=</span> Queue<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 线程执行函数</span>
    <span class="token keyword">def</span> <span class="token function">thread_routine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 将试验次数n分为thread_num份</span>
        <span class="token comment"># 执行试验并将试验结果放入队列</span>
        queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>sample<span class="token punctuation">(</span>n <span class="token operator">//</span> thread_num<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># 创建执行线程</span>
    threads <span class="token operator">=</span> <span class="token punctuation">[</span>
        Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>thread_routine<span class="token punctuation">)</span>
        <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>thread_num<span class="token punctuation">)</span>
    <span class="token punctuation">]</span>

    <span class="token comment"># 启动执行线程</span>
    <span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">:</span>
        thread<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 从任务队列收集试验结果</span>
    total_n<span class="token punctuation">,</span> total_in_sectors <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>
    <span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">:</span>
        n<span class="token punctuation">,</span> in_sectors <span class="token operator">=</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
        total_n <span class="token operator">+=</span> n
        total_in_sectors <span class="token operator">+=</span> in_sectors

    <span class="token comment"># 回收线程资源</span>
    <span class="token keyword">for</span> thread <span class="token keyword">in</span> threads<span class="token punctuation">:</span>
        thread<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> eval_pi<span class="token punctuation">(</span>total_n<span class="token punctuation">,</span> total_in_sectors<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>estimate_pi_with_threads</em> 估算函数执行 <em>1</em> 亿次试验耗时 <em>4.63</em> 秒，多线程对程序没有任何提升。</p>
</div><div class="cl-preview-section"><p>那么，是否意味着 <em>Python</em> 程序无法充分利用多核 <em>CPU</em> 的执行能力呢？</p>
</div><div class="cl-preview-section"><p>肯定不是。虽然我们没有办法避免 <em>GIL</em> 的影响，但是我们可以想法设法绕过它，例如采用 <strong>多进程模式</strong> 。在 <em>Python</em> 程序中，每个进程独立运行一个虚拟机。因此，不同 <em>Python</em> 进程可以在多核 <em>CPU</em> 上并行运行，不受 <em>GIL</em> 限制。</p>
</div><div class="cl-preview-section"><p>最后，我们再以 <strong>多进程模式</strong> 执行 <em>1</em> 亿次随机试验，看执行效率是否如预期有所提升。为此我们设计了多进程版的估算函数 <em>estimate_pi_with_processes</em> ，<em>process_num</em> 参数为子进程数：</p>
</div><div class="cl-preview-section"><pre class="  language-python"><code class="prism  language-python"><span class="token keyword">from</span> multiprocessing <span class="token keyword">import</span> Process<span class="token punctuation">,</span> Queue <span class="token keyword">as</span> ProcessQueue

<span class="token keyword">def</span> <span class="token function">estimate_pi_with_processes</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> process_num<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 用于收集子进程执行结果的队列</span>
    queue <span class="token operator">=</span> ProcessQueue<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 子进程执行函数</span>
    <span class="token keyword">def</span> <span class="token function">process_routine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 将试验次数n分为process_num份</span>
        <span class="token comment"># 执行试验并将试验结果放入队列</span>
        queue<span class="token punctuation">.</span>put<span class="token punctuation">(</span>sample<span class="token punctuation">(</span>n <span class="token operator">//</span> process_num<span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token comment"># 创建执行进程</span>
    processes <span class="token operator">=</span> <span class="token punctuation">[</span>
        Process<span class="token punctuation">(</span>target<span class="token operator">=</span>process_routine<span class="token punctuation">)</span>
        <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>process_num<span class="token punctuation">)</span>
    <span class="token punctuation">]</span>

    <span class="token comment"># 启动执行进程</span>
    <span class="token keyword">for</span> process <span class="token keyword">in</span> processes<span class="token punctuation">:</span>
        process<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># 从任务队列收集试验结果</span>
    total_n<span class="token punctuation">,</span> total_in_sectors <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span>
    <span class="token keyword">for</span> process <span class="token keyword">in</span> processes<span class="token punctuation">:</span>
        n<span class="token punctuation">,</span> in_sectors <span class="token operator">=</span> queue<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span>
        total_n <span class="token operator">+=</span> n
        total_in_sectors <span class="token operator">+=</span> in_sectors

    <span class="token comment"># 回收子进程资源</span>
    <span class="token keyword">for</span> process <span class="token keyword">in</span> processes<span class="token punctuation">:</span>
        process<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> eval_pi<span class="token punctuation">(</span>total_n<span class="token punctuation">,</span> total_in_sectors<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p><em>estimate_pi_with_processes</em> 估算函数执行 <em>1</em> 亿次试验耗时 <em>2.56</em> 秒，几乎比单线程版快了一倍！如果增加子进程数，程序执行速度还可以进一步提升。需要特别注意，超出 <em>CPU</em> 核数的进程数则没有任何意义了。</p>
</div><div class="cl-preview-section"><div class="table-wrapper"><table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>试验函数</strong></th>
<th><strong>耗时 (秒)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td> 单线程</td>
<td> estimate_pi(100000000)</td>
<td>4.59</td>
</tr>
<tr>
<td> 多线程</td>
<td> estimate_pi_with_threads(100000000, 2)</td>
<td>4.63</td>
</tr>
<tr>
<td> 多进程</td>
<td> estimate_pi_with_processes(100000000, 2)</td>
<td>2.56</td>
</tr>
</tbody>
</table>
</div></div>
			
		</div>
	
	
	<div class="finish-learn">
		<p class="copyright">©版权归慕课网所有，未经许可不得转载</p>
		
		
		
		<div class="ad_pic">
			<img src="https://img.mukewang.com/5efbf30d00011d7f06700192.jpg">
		</div>
		
		
		
		
	</div>
	<div class="comment-con">
		<h4 class="title">
			精选留言
			
				<a href="javascript: void(0);" class="add-comment js-comment-click"><i class="imwap-xieliuyan"></i><span>写留言</span></a>
			
		</h4>
		
			<ul class="comment-content">
				
				<li class="item">
					<a href="/read/commentdetail/6976">
						<img src="https://img4.mukewang.com/545865620001c45402760276-100-100.jpg" alt="" class="avatar">
						<h4 class="nickname">weixin_梦在天穹_0</h4>
						<div class="comment-text">”IO Blocked 线程一开始阻塞在系统调用上，当系统调用返回后“，这里的系统调用就是io操作吗， 有没有其他形式的操作也会让线程进入阻塞状态？</div>
						<div>
							
						</div>
					</a>
					<p class="bottom">
						<span class="l">2020-10-14</span>
						<a href="/read/commentdetail/6976">
							<span class="icon r"><i class="imwap-comment"></i><em>1</em></span>
						</a>
						<span data-cid="6976" class="icon r js-comment-upvote "><i class="imwap-thumb_up"></i><em>0</em></span>
					</p>
				</li>
				
				<li class="item">
					<a href="/read/commentdetail/6924">
						<img src="https://img4.mukewang.com/533e4c420001b2e502000200-100-100.jpg" alt="" class="avatar">
						<h4 class="nickname">慕勒6538951</h4>
						<div class="comment-text">GIL只能保证字节码原子执行，然而有的语句编译成字节码之后，对应多条字节码。所以GIL不能保证线程安全？</div>
						<div>
							
								<div class="reply">讲师回复：要看是哪个层面的&quot;线程安全&quot;。GIL保证虚拟机在执行一个字节码时，不会受到其他线程的干扰，因此虚拟机是线程安全的，或者说虚拟机内部状态是线程安全的。举个例子，虚拟机在往一个字典对象添加新数据时d[k]=v，底层字典对象操作函数执行时一定不会受到其他线程干扰，不会产生竞争态。但站在Python程序角度，如果没有显式引用锁，就不一定是线程安全的。例如，a+=1这个语句会编译成LOAD_NAME, BINARY_ADD以及STORE_NAME这3条典型的字节码。LOAD_NAME负责将变量a当前的值加载到栈，BINARY_ADD计算a与常量1的和，STORE_NAME将计算结果存回变量a。如果两个线程同时执行这个语句，可能以这样的顺序执行，假设a初始值是10：线程①加载变量a并计算出中间结果11；虚拟机切换到线程②，它加载a，这时由于a的计算结果还没有保存，因此a的值还是10！</div>
							
						</div>
					</a>
					<p class="bottom">
						<span class="l">2020-10-08</span>
						<a href="/read/commentdetail/6924">
							<span class="icon r"><i class="imwap-comment"></i><em>2</em></span>
						</a>
						<span data-cid="6924" class="icon r js-comment-upvote "><i class="imwap-thumb_up"></i><em>0</em></span>
					</p>
				</li>
				
				<li class="item">
					<a href="/read/commentdetail/6732">
						<img src="https://img1.mukewang.com/533e4bec0001ae5302000200-100-100.jpg" alt="" class="avatar">
						<h4 class="nickname">qq_六月的古明地觉_0</h4>
						<div class="comment-text">老师可不可以这样理解, GIL是为了方便解释器开发人员而设置的, 尤其是在内存管理方面。
假设没有GIL, 那么两个线程在销毁同一个对象的时候, 就会出现悬空指针的问题。
于是python引用了GIL, 它是以字节码为单位的, 不管何时, 只有一个线程在执行字节码。
如果当前的某条字节码没有执行完, 那么是不会发生线程切换的, 因此这样就保证了以字节码为单位的安全性。

但是我们在写python代码时, 由于一行代码一般会对应多条字节码, 所以这个时候会再通过threading.Lock()进行加锁

所以: GIL是以字节码为单位的, 它保证了每条字节码在执行的时候不会被打断
而threading.Lock()是以代码为单位的, 它是保证python层面上的一行或多行代码在执行时不会被打断</div>
						<div>
							
								<div class="reply">讲师回复：没错，就是这样的~</div>
							
						</div>
					</a>
					<p class="bottom">
						<span class="l">2020-09-06</span>
						<a href="/read/commentdetail/6732">
							<span class="icon r"><i class="imwap-comment"></i><em>1</em></span>
						</a>
						<span data-cid="6732" class="icon r js-comment-upvote "><i class="imwap-thumb_up"></i><em>0</em></span>
					</p>
				</li>
				
				<li class="item">
					<a href="/read/commentdetail/6342">
						<img src="https://img.mukewang.com/images/unknow-160.png" alt="" class="avatar">
						<h4 class="nickname">weixin_慕九州5232177</h4>
						<div class="comment-text">python有没有彻底解决GIL这个性能禁锢的可能？</div>
						<div>
							
								<div class="reply">讲师回复：有一些尝试，但目前看仍不成熟，官方实现也还无法解决GIL。</div>
							
						</div>
					</a>
					<p class="bottom">
						<span class="l">2020-07-29</span>
						<a href="/read/commentdetail/6342">
							<span class="icon r"><i class="imwap-comment"></i><em>1</em></span>
						</a>
						<span data-cid="6342" class="icon r js-comment-upvote "><i class="imwap-thumb_up"></i><em>0</em></span>
					</p>
				</li>
				
				<li class="item">
					<a href="/read/commentdetail/6286">
						<img src="https://img4.mukewang.com/533e4c3300019caf02000200-100-100.jpg" alt="" class="avatar">
						<h4 class="nickname">蒙古力_康康康</h4>
						<div class="comment-text">线程安全方案	优势	劣势
对象锁	多线程可并行执行	加解锁开销巨大
GIL	无需频繁加解锁	多进程只能交替执行   老师这个地方应该是多线程只能交替执行吧？</div>
						<div>
							
								<div class="reply">讲师回复：对的，多谢指出~</div>
							
						</div>
					</a>
					<p class="bottom">
						<span class="l">2020-07-24</span>
						<a href="/read/commentdetail/6286">
							<span class="icon r"><i class="imwap-comment"></i><em>1</em></span>
						</a>
						<span data-cid="6286" class="icon r js-comment-upvote "><i class="imwap-thumb_up"></i><em>0</em></span>
					</p>
				</li>
				
				<li class="item">
					<a href="/read/commentdetail/6258">
						<img src="https://img1.mukewang.com/5b8cd58d0001a8d102000200-100-100.jpg" alt="" class="avatar">
						<h4 class="nickname">weixin_慕虎2462690</h4>
						<div class="comment-text">有个点不太明白，仍以list.append为例，为什么在使用GIL方式时，不会发生由于执行的字节码数量达到限制而产生的线程调度？</div>
						<div>
							
								<div class="reply">讲师回复：换句话讲，执行字节码数量达到一定数量，必然会发生线程调度。但是调度是以字节码为单位的，不会存在某个字节码执行一半被其他线程抢占的情况。因此，调度方式时，要么关键字节码CALL_METHOD还没执行；要么它已经执行完毕，对象已经成功追加到列表；不会存在中间状态调度的情况。</div>
							
						</div>
					</a>
					<p class="bottom">
						<span class="l">2020-07-22</span>
						<a href="/read/commentdetail/6258">
							<span class="icon r"><i class="imwap-comment"></i><em>2</em></span>
						</a>
						<span data-cid="6258" class="icon r js-comment-upvote "><i class="imwap-thumb_up"></i><em>1</em></span>
					</p>
				</li>
				
				<li class="item">
					<a href="/read/commentdetail/6256">
						<img src="https://img3.mukewang.com/545862440001cef302200220-100-100.jpg" alt="" class="avatar">
						<h4 class="nickname">weixin_AaronZJ</h4>
						<div class="comment-text">很实在的文章，点赞</div>
						<div>
							
						</div>
					</a>
					<p class="bottom">
						<span class="l">2020-07-22</span>
						<a href="/read/commentdetail/6256">
							<span class="icon r"><i class="imwap-comment"></i><em>0</em></span>
						</a>
						<span data-cid="6256" class="icon r js-comment-upvote "><i class="imwap-thumb_up"></i><em>1</em></span>
					</p>
				</li>
				
			</ul>
			
		
	</div>
	
	

	
		
	
	
	
		<div class="bottom-con">
			
			
				<div class="inner">
					
						<div class="price-con js-price-con">
							<span class="now">￥68.00</span>
						</div>
							
					
					
					<a class="gobuy js-gobuy" href="//m.imooc.com/account/login?backurl=//m.imooc.com/confirmorder?type=30&typeid=76">
					
						立即购买
					</a>  
				</div>
			
		</div>
	
	<div class="layer-catalog js-layer-catalog hide">
		<div class="layer-title clearfix">
			<div class="l">
				课程目录
			</div>
			
		</div>
		<div class="layer-wrap">
			<div class="js-catalog-container">
			</div>
		</div>
	</div>
	<div class="layer-comment">
		<div class="inner">
			<h5>
				<span class="btn l js-cancel-comment">取消</span>
				评论
				<span class="btn r js-send-comment">发送</span>
			</h5>
			<textarea id="comment-txt" maxlength="20000" placeholder="欢迎在这里发表留言，作者筛选后可公开显示"></textarea>
		</div>
	</div>


            </div>
        </div>
        
            
         
        
        
        
        




<script>
	// 设置字号大小及选中
	(function() {
			var fs = window.localStorage.getItem('font-size') || 'normal';
			var $c = document.querySelector('#middle>.content');
			var $points = document.querySelectorAll('.setting-box .point');
			try{
				// 抢读完了时 该元素不渲染 会有报错
				$c.className = 'content ' + fs;
				for(var i = 0; i < $points.length; i++) {
					if($points[i].className.indexOf(fs) > -1) {
						$points[i].className = $points[i].className + ' current';
					}
				}
			} catch(e) {}
			
	})();
</script>

<script type="text/javascript">
	window.onload = function() {
			zhuge.track('LearnCourse', {
					'Category': '专栏',
					'Name': '21 GIL 全局锁，束缚Python的紧箍圈',
					'CID': '1917',
					'Teacher': 'fasionchan'
			});
	}
</script>

        
            <script type="text/javascript">
                var shareData = { 
                    title:  "21 GIL 全局锁，束缚Python的紧箍圈",
                    desc: "突破技术瓶颈，迈向更高岗位",
                    imgUrl: 'https:https://img3.mukewang.com/5eb68ab400017cda05400720.jpg',
                    otherImgUrl: 'https://img3.mukewang.com/5eb68ab400017cda05400720.jpg',
                    text: '我正在参加@慕课网的课程，很不错哦！快来一起学习吧！',
                    // url: 'https://www.imooc.com' + window.location.pathname + window.location.search
                    url: 'https://m.imooc.com/read/76',
                    link: 'https://m.imooc.com/read/76'
                }
            </script>
            
        
        <div style="display:none;">
            <!-- 百度统计 -->
            <script>
            var _hmt = _hmt || [];
            (function() {
              var hm = document.createElement("script");
              hm.src = "https://hm.baidu.com/hm.js?c92536284537e1806a07ef3e6873f2b3";
              var s = document.getElementsByTagName("script")[0];
              s.parentNode.insertBefore(hm, s);
            })();
            </script>

            <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
            </script>
        </div>
        
    <script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/zhugeio/init_f9752c3.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/jquery-2.1.0.min_ac9f840.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/common_84429c0.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/juicer/juicer.min_8643248.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/lib/previewImage/previewImage.min_43b970d.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/common/js/msg_bed8d10.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/read/7.2.8/article_30e5762.js"></script><script type="text/javascript" src="https://m.imooc.com/static/wap/static/js/course/advertisementReport_6e58a98.js"></script></body>
</html>
